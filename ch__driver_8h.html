<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chirp SonicLib: invn/soniclib/details/ch_driver.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Chirp SonicLib
   &#160;<span id="projectnumber">4.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_e2bc8ccdb587e3c3e16dcbd6fd126654.html">invn</a></li><li class="navelem"><a class="el" href="dir_0ccdbf2c279b53b38c827faf1754ce51.html">soniclib</a></li><li class="navelem"><a class="el" href="dir_133614a7df5c2eea2a70e0c1e233ef25.html">details</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ch_driver.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Internal driver functions for operation with the Chirp ultrasonic sensor.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="soniclib_8h_source.html">invn/soniclib/soniclib.h</a>&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;invn/icu_interface/shasta_pmut_instruction.h&gt;</code><br />
</div>
<p><a href="ch__driver_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structchdrv__queue.html">chdrv_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue structure, for non-blocking access.  <a href="structchdrv__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structchdrv__transaction.html">chdrv_transaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transaction control structure.  <a href="structchdrv__transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:abb64488b78685db43351e9b313ff5d29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#abb64488b78685db43351e9b313ff5d29">CH_PROG_ADDR_DEV_I2C_ADDR_REG</a>&#160;&#160;&#160;(0x01C5)</td></tr>
<tr class="separator:abb64488b78685db43351e9b313ff5d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140a5c4c76733dcc1c4046d6d3fe98dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a140a5c4c76733dcc1c4046d6d3fe98dc">CH_PROG_ADDR_IDLE_LOC</a>&#160;&#160;&#160;(CHX01_PROG_MEM_ADDR + CHX01_PROG_MEM_SIZE - 4)</td></tr>
<tr class="separator:a140a5c4c76733dcc1c4046d6d3fe98dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa284c79f9590cfe93801f473a8a9c688"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#aa284c79f9590cfe93801f473a8a9c688">CH_PROG_ADDR_PMUT_CNTRL4_REG</a>&#160;&#160;&#160;(0x01A6)</td></tr>
<tr class="separator:aa284c79f9590cfe93801f473a8a9c688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb302b57d31a0229525f67d8098e41f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#aeb302b57d31a0229525f67d8098e41f2">CH_PROG_ADDR_WDT_REG</a>&#160;&#160;&#160;(0x0120)</td></tr>
<tr class="separator:aeb302b57d31a0229525f67d8098e41f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a08989a943d72f0bac975a55d02188"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ab2a08989a943d72f0bac975a55d02188">CH_PROG_REG_ADDR</a>&#160;&#160;&#160;0x05</td></tr>
<tr class="separator:ab2a08989a943d72f0bac975a55d02188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeea872b51aac7857db839b195a17edd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#aeeea872b51aac7857db839b195a17edd">CH_PROG_REG_CNT</a>&#160;&#160;&#160;0x07</td></tr>
<tr class="separator:aeeea872b51aac7857db839b195a17edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03da9ae6a40bdcf4f18ec119be88a7d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a03da9ae6a40bdcf4f18ec119be88a7d2">CH_PROG_REG_CPU</a>&#160;&#160;&#160;0x42</td></tr>
<tr class="separator:a03da9ae6a40bdcf4f18ec119be88a7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6e24b1c1d7525a5650797205c8c327"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a6c6e24b1c1d7525a5650797205c8c327">CH_PROG_REG_CTL</a>&#160;&#160;&#160;0x44</td></tr>
<tr class="separator:a6c6e24b1c1d7525a5650797205c8c327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5161dfbe240f20eb545642332d3000f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#af5161dfbe240f20eb545642332d3000f">CH_PROG_REG_DATA</a>&#160;&#160;&#160;0x06</td></tr>
<tr class="separator:af5161dfbe240f20eb545642332d3000f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac696e9971aa740b47aeb4602c622cfe0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ac696e9971aa740b47aeb4602c622cfe0">CH_PROG_REG_PING</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:ac696e9971aa740b47aeb4602c622cfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493f7894d846693e19f866eec5c48aad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a493f7894d846693e19f866eec5c48aad">CH_PROG_REG_STAT</a>&#160;&#160;&#160;0x43</td></tr>
<tr class="separator:a493f7894d846693e19f866eec5c48aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead6a50cc1df7dbabb33c2b948c7ac4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#aead6a50cc1df7dbabb33c2b948c7ac4a">CH_PROG_SIZEOF</a>(R)&#160;&#160;&#160;((R)&amp;0x40 ? 1 : 2)</td></tr>
<tr class="separator:aead6a50cc1df7dbabb33c2b948c7ac4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8330fd24a12c82e7a5d66446ba2c1e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ae8330fd24a12c82e7a5d66446ba2c1e9">CH_PROG_XFER_SIZE</a>&#160;&#160;&#160;(256)</td></tr>
<tr class="separator:ae8330fd24a12c82e7a5d66446ba2c1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d1dc5f889265639a1f76800868d3a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a17d1dc5f889265639a1f76800868d3a6">CHDRV_BANDWIDTH_INDEX_1</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a17d1dc5f889265639a1f76800868d3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4046fd810b274161f020c21ed02f9352"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a4046fd810b274161f020c21ed02f9352">CHDRV_BANDWIDTH_INDEX_2</a>&#160;&#160;&#160;	(<a class="el" href="ch__driver_8h.html#a17d1dc5f889265639a1f76800868d3a6">CHDRV_BANDWIDTH_INDEX_1</a> + 1)</td></tr>
<tr class="separator:a4046fd810b274161f020c21ed02f9352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e5378460204f913bbdc04b1cb7e9fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a66e5378460204f913bbdc04b1cb7e9fb">CHDRV_DEBUG_PIN_NUM</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:a66e5378460204f913bbdc04b1cb7e9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0b1e423d7189f8afbd237a518a223e"><td class="memItemLeft" align="right" valign="top"><a id="a7f0b1e423d7189f8afbd237a518a223e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHDRV_DELAY_EN_CHARGE_PUMP_MS</b>&#160;&#160;&#160;(5)</td></tr>
<tr class="separator:a7f0b1e423d7189f8afbd237a518a223e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba4dde00e9d53fb025d00695866ad5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#aeba4dde00e9d53fb025d00695866ad5e">CHDRV_DELAY_OVERHEAD_US</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:aeba4dde00e9d53fb025d00695866ad5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b2a185bec85a94cdd00f58ea1cc444"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a19b2a185bec85a94cdd00f58ea1cc444">CHDRV_EVENT_TIMEOUT_MS</a>&#160;&#160;&#160;(750)</td></tr>
<tr class="separator:a19b2a185bec85a94cdd00f58ea1cc444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d125b6ed3ddcc504f3bc2a5c0bbe84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a30d125b6ed3ddcc504f3bc2a5c0bbe84">CHDRV_FREQLOCK_TIMEOUT_MS</a>&#160;&#160;&#160;	100</td></tr>
<tr class="separator:a30d125b6ed3ddcc504f3bc2a5c0bbe84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632eb3a4c28778cbd004027e11fde059"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a632eb3a4c28778cbd004027e11fde059">CHDRV_I2C_MAX_WRITE_BYTES</a>&#160;&#160;&#160;256</td></tr>
<tr class="separator:a632eb3a4c28778cbd004027e11fde059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafd0645157c35f51250161f5379fa45"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#acafd0645157c35f51250161f5379fa45">CHDRV_I2C_SPEED_DEFAULT_HZ</a>&#160;&#160;&#160;(400000)</td></tr>
<tr class="separator:acafd0645157c35f51250161f5379fa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac527316c98bd7c0e1939500f02c43484"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ac527316c98bd7c0e1939500f02c43484">CHDRV_MAX_QUEUE_LENGTH</a>&#160;&#160;&#160;	CHIRP_MAX_NUM_SENSORS</td></tr>
<tr class="separator:ac527316c98bd7c0e1939500f02c43484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657a87e2e6fddfb7f06988954e814f9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a657a87e2e6fddfb7f06988954e814f9e">CHDRV_NB_TRANS_TYPE_EXTERNAL</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="separator:a657a87e2e6fddfb7f06988954e814f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f8dd7577f6e8522b16e20482fd2cc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a34f8dd7577f6e8522b16e20482fd2cc2">CHDRV_NB_TRANS_TYPE_PROG</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:a34f8dd7577f6e8522b16e20482fd2cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe569bd8389300a9d3a490de4392f293"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#abe569bd8389300a9d3a490de4392f293">CHDRV_NB_TRANS_TYPE_STD</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:abe569bd8389300a9d3a490de4392f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b793c41900e340a75d1fa246614f5ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a9b793c41900e340a75d1fa246614f5ff">CHDRV_POST_ALGO_INIT_DELAY_MS</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a9b793c41900e340a75d1fa246614f5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bcecff52fccdf97ea9c02e00b3ac80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#af1bcecff52fccdf97ea9c02e00b3ac80">CHDRV_POST_TRIG_IEN_DELAY_US</a>&#160;&#160;&#160;	10</td></tr>
<tr class="separator:af1bcecff52fccdf97ea9c02e00b3ac80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcabdd3a9dfdbf2a3bd10fa2ed6fa257"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#afcabdd3a9dfdbf2a3bd10fa2ed6fa257">CHDRV_PRETRIGGER_DELAY_US</a>&#160;&#160;&#160;600</td></tr>
<tr class="separator:afcabdd3a9dfdbf2a3bd10fa2ed6fa257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e47db4dea7e448c25f4f2a774c40a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a20e47db4dea7e448c25f4f2a774c40a2">CHDRV_SCALEFACTOR_INDEX</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a20e47db4dea7e448c25f4f2a774c40a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0c0ee859c73069800b1c8342c0144a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a1d0c0ee859c73069800b1c8342c0144a">CHDRV_TRIGGER_PULSE_US</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a1d0c0ee859c73069800b1c8342c0144a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c83f797e242ff35c2bb5603a0ee5d38"><td class="memItemLeft" align="right" valign="top"><a id="a7c83f797e242ff35c2bb5603a0ee5d38"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PMUT_CNTRL4_HVVDD_FON</b>&#160;&#160;&#160;(0x0400)</td></tr>
<tr class="separator:a7c83f797e242ff35c2bb5603a0ee5d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3875ea30d702dd4f4dad5c29319044f9"><td class="memItemLeft" align="right" valign="top"><a id="a3875ea30d702dd4f4dad5c29319044f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PMUT_CNTRL4_HVVSS_FON</b>&#160;&#160;&#160;(0x0200)</td></tr>
<tr class="separator:a3875ea30d702dd4f4dad5c29319044f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a31c849c39e5739e7a12da398cf9c4466"><td class="memItemLeft" align="right" valign="top"><a id="a31c849c39e5739e7a12da398cf9c4466"></a>
typedef struct <a class="el" href="structchdrv__queue.html">chdrv_queue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a31c849c39e5739e7a12da398cf9c4466">chdrv_queue_t</a></td></tr>
<tr class="memdesc:a31c849c39e5739e7a12da398cf9c4466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue structure, for non-blocking access. <br /></td></tr>
<tr class="separator:a31c849c39e5739e7a12da398cf9c4466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb6a38a59c07da652551cfde916ec35"><td class="memItemLeft" align="right" valign="top"><a id="a0eb6a38a59c07da652551cfde916ec35"></a>
typedef struct <a class="el" href="structchdrv__transaction.html">chdrv_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a0eb6a38a59c07da652551cfde916ec35">chdrv_transaction_t</a></td></tr>
<tr class="memdesc:a0eb6a38a59c07da652551cfde916ec35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transaction control structure. <br /></td></tr>
<tr class="separator:a0eb6a38a59c07da652551cfde916ec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6324da3f9d34e13da5e0ff3372f01f9a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a6324da3f9d34e13da5e0ff3372f01f9a">chdrv_adjust_rx_len</a> (volatile pmut_transceiver_inst_t *trx_inst, uint8_t cic_odr, int rx_len, int eof_idx)</td></tr>
<tr class="memdesc:a6324da3f9d34e13da5e0ff3372f01f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function trims the total RX length to remove excess ADC samples that don't result in additional IQ sample.  <a href="ch__driver_8h.html#a6324da3f9d34e13da5e0ff3372f01f9a">More...</a><br /></td></tr>
<tr class="separator:a6324da3f9d34e13da5e0ff3372f01f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29920c0933777700bce6f82ee6d72355"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a29920c0933777700bce6f82ee6d72355">chdrv_algo_cfg_read</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, void *algo_cfg_ptr)</td></tr>
<tr class="memdesc:a29920c0933777700bce6f82ee6d72355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the algorithm configuration data from a sensor.  <a href="ch__driver_8h.html#a29920c0933777700bce6f82ee6d72355">More...</a><br /></td></tr>
<tr class="separator:a29920c0933777700bce6f82ee6d72355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513dc5c9c35f504e8f0a65ec91da6d1a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a513dc5c9c35f504e8f0a65ec91da6d1a">chdrv_algo_cfg_write</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, const void *algo_cfg_ptr)</td></tr>
<tr class="memdesc:a513dc5c9c35f504e8f0a65ec91da6d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the algorithm configuration data to a sensor.  <a href="ch__driver_8h.html#a513dc5c9c35f504e8f0a65ec91da6d1a">More...</a><br /></td></tr>
<tr class="separator:a513dc5c9c35f504e8f0a65ec91da6d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9311967cfdd38fce74a494f38266da7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ad9311967cfdd38fce74a494f38266da7">chdrv_algo_info_read</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structicu__algo__info.html">ICU_ALGO_SHASTA_INFO</a> *algo_info_ptr)</td></tr>
<tr class="memdesc:ad9311967cfdd38fce74a494f38266da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the algorithm information data from a sensor.  <a href="ch__driver_8h.html#ad9311967cfdd38fce74a494f38266da7">More...</a><br /></td></tr>
<tr class="separator:ad9311967cfdd38fce74a494f38266da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd36bcd1cdce82fe2d5cc54dd6af551"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a9bd36bcd1cdce82fe2d5cc54dd6af551">chdrv_algo_init</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a9bd36bcd1cdce82fe2d5cc54dd6af551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the measurement algorithm on a sensor.  <a href="ch__driver_8h.html#a9bd36bcd1cdce82fe2d5cc54dd6af551">More...</a><br /></td></tr>
<tr class="separator:a9bd36bcd1cdce82fe2d5cc54dd6af551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b27cda636275719606d2ab710844965"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a6b27cda636275719606d2ab710844965">chdrv_algo_out_read</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, void *algo_out_ptr)</td></tr>
<tr class="memdesc:a6b27cda636275719606d2ab710844965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the algorithm output data from a sensor.  <a href="ch__driver_8h.html#a6b27cda636275719606d2ab710844965">More...</a><br /></td></tr>
<tr class="separator:a6b27cda636275719606d2ab710844965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5907f6e8360090c0c353a3f05eb805f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ad5907f6e8360090c0c353a3f05eb805f">chdrv_algo_state_read</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, void *algo_state_ptr)</td></tr>
<tr class="memdesc:ad5907f6e8360090c0c353a3f05eb805f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the algorithm state data from a sensor.  <a href="ch__driver_8h.html#ad5907f6e8360090c0c353a3f05eb805f">More...</a><br /></td></tr>
<tr class="separator:ad5907f6e8360090c0c353a3f05eb805f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada09b53019dc72dce9c861a4d6d3c7a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ada09b53019dc72dce9c861a4d6d3c7a3">chdrv_burst_read</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t mem_addr, uint8_t *data, uint16_t len)</td></tr>
<tr class="memdesc:ada09b53019dc72dce9c861a4d6d3c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from a sensor application register location.  <a href="ch__driver_8h.html#ada09b53019dc72dce9c861a4d6d3c7a3">More...</a><br /></td></tr>
<tr class="separator:ada09b53019dc72dce9c861a4d6d3c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7d461b257a90d3f05e68db1e2cbf36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#adf7d461b257a90d3f05e68db1e2cbf36">chdrv_burst_write</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t mem_addr, const uint8_t *data, uint16_t num_bytes)</td></tr>
<tr class="memdesc:adf7d461b257a90d3f05e68db1e2cbf36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple bytes to a sensor application register location.  <a href="ch__driver_8h.html#adf7d461b257a90d3f05e68db1e2cbf36">More...</a><br /></td></tr>
<tr class="separator:adf7d461b257a90d3f05e68db1e2cbf36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b2e6c2bf6c22421c45efc8d76cebf9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a29b2e6c2bf6c22421c45efc8d76cebf9">chdrv_check_reset_state</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t *reset_state)</td></tr>
<tr class="memdesc:a29b2e6c2bf6c22421c45efc8d76cebf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if sensor reset has occurred.  <a href="ch__driver_8h.html#a29b2e6c2bf6c22421c45efc8d76cebf9">More...</a><br /></td></tr>
<tr class="separator:a29b2e6c2bf6c22421c45efc8d76cebf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dea5da36604025423fcd06156e3c154"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a0dea5da36604025423fcd06156e3c154">chdrv_cpu_freq_adjust</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint32_t pmut_freq)</td></tr>
<tr class="memdesc:a0dea5da36604025423fcd06156e3c154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust sensor micro-controller CPU frequency.  <a href="ch__driver_8h.html#a0dea5da36604025423fcd06156e3c154">More...</a><br /></td></tr>
<tr class="separator:a0dea5da36604025423fcd06156e3c154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b6cbcfd12570d0b2a14adc3f40fd97"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a90b6cbcfd12570d0b2a14adc3f40fd97">chdrv_cpu_freq_calculate</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a90b6cbcfd12570d0b2a14adc3f40fd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sensor micro-controller CPU frequency, in Hz.  <a href="ch__driver_8h.html#a90b6cbcfd12570d0b2a14adc3f40fd97">More...</a><br /></td></tr>
<tr class="separator:a90b6cbcfd12570d0b2a14adc3f40fd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381f2412d7a8d916dbb5623580fc607f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a381f2412d7a8d916dbb5623580fc607f">chdrv_dbg_reg_read</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t reg_id, uint16_t *reg_value_ptr)</td></tr>
<tr class="memdesc:a381f2412d7a8d916dbb5623580fc607f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the debug register from a sensor.  <a href="ch__driver_8h.html#a381f2412d7a8d916dbb5623580fc607f">More...</a><br /></td></tr>
<tr class="separator:a381f2412d7a8d916dbb5623580fc607f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529370109a4cfcb39ca7eb04042adcd3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a529370109a4cfcb39ca7eb04042adcd3">chdrv_dbg_reg_write</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t reg_id, uint16_t reg_value)</td></tr>
<tr class="memdesc:a529370109a4cfcb39ca7eb04042adcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the debug register in a sensor.  <a href="ch__driver_8h.html#a529370109a4cfcb39ca7eb04042adcd3">More...</a><br /></td></tr>
<tr class="separator:a529370109a4cfcb39ca7eb04042adcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee4264f20f394d9a6c68dfc0fa654c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#abee4264f20f394d9a6c68dfc0fa654c4">chdrv_detect_and_program</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:abee4264f20f394d9a6c68dfc0fa654c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect, program, and start a sensor.  <a href="ch__driver_8h.html#abee4264f20f394d9a6c68dfc0fa654c4">More...</a><br /></td></tr>
<tr class="separator:abee4264f20f394d9a6c68dfc0fa654c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66665863732013c7ea8f0e608e3abaca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a66665863732013c7ea8f0e608e3abaca">chdrv_disable_mq_sanitize</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a66665863732013c7ea8f0e608e3abaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the measurement config sanitization step when loading configs.  <a href="ch__driver_8h.html#a66665863732013c7ea8f0e608e3abaca">More...</a><br /></td></tr>
<tr class="separator:a66665863732013c7ea8f0e608e3abaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6f6b232156ab586a7747731ddf0728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a9e6f6b232156ab586a7747731ddf0728">chdrv_enable_mq_sanitize</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a9e6f6b232156ab586a7747731ddf0728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the measurement config sanitization step when loading configs.  <a href="ch__driver_8h.html#a9e6f6b232156ab586a7747731ddf0728">More...</a><br /></td></tr>
<tr class="separator:a9e6f6b232156ab586a7747731ddf0728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4117080373fd81402ca3b88d21516bec"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a4117080373fd81402ca3b88d21516bec">chdrv_event_trigger</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t event)</td></tr>
<tr class="memdesc:a4117080373fd81402ca3b88d21516bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger an event on a sensor and return immediately.  <a href="ch__driver_8h.html#a4117080373fd81402ca3b88d21516bec">More...</a><br /></td></tr>
<tr class="separator:a4117080373fd81402ca3b88d21516bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839d70099302ddf05751dc5a8ae11167"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a839d70099302ddf05751dc5a8ae11167">chdrv_event_trigger_and_wait</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t event)</td></tr>
<tr class="memdesc:a839d70099302ddf05751dc5a8ae11167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger an event on a sensor and wait for completion.  <a href="ch__driver_8h.html#a839d70099302ddf05751dc5a8ae11167">More...</a><br /></td></tr>
<tr class="separator:a839d70099302ddf05751dc5a8ae11167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace484e88914368eaa699680d61e9ed4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ace484e88914368eaa699680d61e9ed4f">chdrv_external_queue</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, <a class="el" href="structch__dev__t.html">ch_dev_t</a> *instance, uint8_t rd_wrb, uint16_t addr, uint16_t nbytes, uint8_t *data)</td></tr>
<tr class="memdesc:ace484e88914368eaa699680d61e9ed4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an I2C/SPI transaction for an external device to the non-blocking queue.  <a href="ch__driver_8h.html#ace484e88914368eaa699680d61e9ed4f">More...</a><br /></td></tr>
<tr class="separator:ace484e88914368eaa699680d61e9ed4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11d0f71857658acbdd86368705916ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#af11d0f71857658acbdd86368705916ce">chdrv_group_detect_and_program</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:af11d0f71857658acbdd86368705916ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect, program, and start all sensors in a group.  <a href="ch__driver_8h.html#af11d0f71857658acbdd86368705916ce">More...</a><br /></td></tr>
<tr class="separator:af11d0f71857658acbdd86368705916ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08697d8ec41c448731e9dd990a98f83c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a08697d8ec41c448731e9dd990a98f83c">chdrv_group_hard_reset</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a08697d8ec41c448731e9dd990a98f83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a hard reset on a group of sensors.  <a href="ch__driver_8h.html#a08697d8ec41c448731e9dd990a98f83c">More...</a><br /></td></tr>
<tr class="separator:a08697d8ec41c448731e9dd990a98f83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30af69acd077caa33fc61cd792c8a4e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a30af69acd077caa33fc61cd792c8a4e9">chdrv_group_hw_trigger</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a30af69acd077caa33fc61cd792c8a4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a measurement in hardware triggered mode.  <a href="ch__driver_8h.html#a30af69acd077caa33fc61cd792c8a4e9">More...</a><br /></td></tr>
<tr class="separator:a30af69acd077caa33fc61cd792c8a4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0607fc0bdc3c2ac43e1ee568a470893c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a0607fc0bdc3c2ac43e1ee568a470893c">chdrv_group_irq_handler</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t bus_index)</td></tr>
<tr class="memdesc:a0607fc0bdc3c2ac43e1ee568a470893c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continue a non-blocking readout.  <a href="ch__driver_8h.html#a0607fc0bdc3c2ac43e1ee568a470893c">More...</a><br /></td></tr>
<tr class="separator:a0607fc0bdc3c2ac43e1ee568a470893c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa403f37e04225e36c94aa861008d8daa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#aa403f37e04225e36c94aa861008d8daa">chdrv_group_measure_pmut</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:aa403f37e04225e36c94aa861008d8daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the ultrasonic transducer frequency &amp; bandwidth.  <a href="ch__driver_8h.html#aa403f37e04225e36c94aa861008d8daa">More...</a><br /></td></tr>
<tr class="separator:aa403f37e04225e36c94aa861008d8daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8340741f29416ac3574add49552ba12c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a8340741f29416ac3574add49552ba12c">chdrv_group_measure_rtc</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a8340741f29416ac3574add49552ba12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate the sensor real-time clock against the host microcontroller clock.  <a href="ch__driver_8h.html#a8340741f29416ac3574add49552ba12c">More...</a><br /></td></tr>
<tr class="separator:a8340741f29416ac3574add49552ba12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b00db198daeb94f05224a07a83dcef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a63b00db198daeb94f05224a07a83dcef">chdrv_group_measure_rtc_no_pulse</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a63b00db198daeb94f05224a07a83dcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate the sensor real-time clock without using a pulse.  <a href="ch__driver_8h.html#a63b00db198daeb94f05224a07a83dcef">More...</a><br /></td></tr>
<tr class="separator:a63b00db198daeb94f05224a07a83dcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9847ced274a5565b784ef3598c67e39f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a9847ced274a5565b784ef3598c67e39f">chdrv_group_prepare</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a9847ced274a5565b784ef3598c67e39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize data structures and hardware for sensor interaction and reset sensors.  <a href="ch__driver_8h.html#a9847ced274a5565b784ef3598c67e39f">More...</a><br /></td></tr>
<tr class="separator:a9847ced274a5565b784ef3598c67e39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cff3a57de90f11a05179a4c7a43d9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a52cff3a57de90f11a05179a4c7a43d9a">chdrv_group_queue</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, <a class="el" href="structch__dev__t.html">ch_dev_t</a> *instance, uint8_t rd_wrb, uint8_t type, uint16_t addr, uint16_t nbytes, uint8_t *data)</td></tr>
<tr class="memdesc:a52cff3a57de90f11a05179a4c7a43d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an I2C/SPI transaction to the non-blocking queue.  <a href="ch__driver_8h.html#a52cff3a57de90f11a05179a4c7a43d9a">More...</a><br /></td></tr>
<tr class="separator:a52cff3a57de90f11a05179a4c7a43d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2965d93ed511809740890444c0d050c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ac2965d93ed511809740890444c0d050c">chdrv_group_soft_reset</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:ac2965d93ed511809740890444c0d050c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a soft reset on a group of sensors.  <a href="ch__driver_8h.html#ac2965d93ed511809740890444c0d050c">More...</a><br /></td></tr>
<tr class="separator:ac2965d93ed511809740890444c0d050c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ebcc31b2f386dd673c1b4161830b67"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a84ebcc31b2f386dd673c1b4161830b67">chdrv_group_start</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a84ebcc31b2f386dd673c1b4161830b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize and start a group of sensors.  <a href="ch__driver_8h.html#a84ebcc31b2f386dd673c1b4161830b67">More...</a><br /></td></tr>
<tr class="separator:a84ebcc31b2f386dd673c1b4161830b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad875c0fbd76673955c1932ed86e237bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ad875c0fbd76673955c1932ed86e237bb">chdrv_group_start_nb</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:ad875c0fbd76673955c1932ed86e237bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a non-blocking sensor readout.  <a href="ch__driver_8h.html#ad875c0fbd76673955c1932ed86e237bb">More...</a><br /></td></tr>
<tr class="separator:ad875c0fbd76673955c1932ed86e237bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749c1460a862744d642dd7c79dc768f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a749c1460a862744d642dd7c79dc768f3">chdrv_group_wait_for_lock</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a749c1460a862744d642dd7c79dc768f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all sensors to finish start-up procedure.  <a href="ch__driver_8h.html#a749c1460a862744d642dd7c79dc768f3">More...</a><br /></td></tr>
<tr class="separator:a749c1460a862744d642dd7c79dc768f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d365a4847bea8941720fea048d4164"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a00d365a4847bea8941720fea048d4164">chdrv_hw_trigger</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a00d365a4847bea8941720fea048d4164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a measurement in hardware triggered mode on one sensor.  <a href="ch__driver_8h.html#a00d365a4847bea8941720fea048d4164">More...</a><br /></td></tr>
<tr class="separator:a00d365a4847bea8941720fea048d4164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c3a9471210a1db098ccf321d71d350"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ad9c3a9471210a1db098ccf321d71d350">chdrv_init</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t i2c_addr, uint8_t io_index, uint8_t bus_index, uint16_t part_number)</td></tr>
<tr class="memdesc:ad9c3a9471210a1db098ccf321d71d350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the sensor device configuration.  <a href="ch__driver_8h.html#ad9c3a9471210a1db098ccf321d71d350">More...</a><br /></td></tr>
<tr class="separator:ad9c3a9471210a1db098ccf321d71d350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e0ec9efd96a9470dee37e6df5a6047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a57e0ec9efd96a9470dee37e6df5a6047">chdrv_int_callback</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t dev_num)</td></tr>
<tr class="memdesc:a57e0ec9efd96a9470dee37e6df5a6047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver callback routine for sensor interrupt.  <a href="ch__driver_8h.html#a57e0ec9efd96a9470dee37e6df5a6047">More...</a><br /></td></tr>
<tr class="separator:a57e0ec9efd96a9470dee37e6df5a6047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f045c98d7f0219f18e0de939fb77d00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a7f045c98d7f0219f18e0de939fb77d00">chdrv_int_callback_deferred</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t dev_num)</td></tr>
<tr class="memdesc:a7f045c98d7f0219f18e0de939fb77d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver callback deferred routine for sensor interrupt.  <a href="ch__driver_8h.html#a7f045c98d7f0219f18e0de939fb77d00">More...</a><br /></td></tr>
<tr class="separator:a7f045c98d7f0219f18e0de939fb77d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396170bdd891cf5177cd87203580a152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a396170bdd891cf5177cd87203580a152">chdrv_int_group_assert</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a396170bdd891cf5177cd87203580a152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert the interrupt lines for all sensors in a group.  <a href="ch__driver_8h.html#a396170bdd891cf5177cd87203580a152">More...</a><br /></td></tr>
<tr class="separator:a396170bdd891cf5177cd87203580a152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1d1f445752b38043011e785ae71b37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a3e1d1f445752b38043011e785ae71b37">chdrv_int_group_deassert</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a3e1d1f445752b38043011e785ae71b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-assert the interrupt lines for all sensors in a group.  <a href="ch__driver_8h.html#a3e1d1f445752b38043011e785ae71b37">More...</a><br /></td></tr>
<tr class="separator:a3e1d1f445752b38043011e785ae71b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9706b1ff5e390d393af514ce983202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a8f9706b1ff5e390d393af514ce983202">chdrv_int_group_interrupt_disable</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a8f9706b1ff5e390d393af514ce983202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable interrupts on the interrupt lines for all sensors in a group.  <a href="ch__driver_8h.html#a8f9706b1ff5e390d393af514ce983202">More...</a><br /></td></tr>
<tr class="separator:a8f9706b1ff5e390d393af514ce983202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7ee9bd8040e1fdf05002f9f0e37996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#aac7ee9bd8040e1fdf05002f9f0e37996">chdrv_int_group_interrupt_enable</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:aac7ee9bd8040e1fdf05002f9f0e37996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupts on the interrupt lines for all sensors in a group.  <a href="ch__driver_8h.html#aac7ee9bd8040e1fdf05002f9f0e37996">More...</a><br /></td></tr>
<tr class="separator:aac7ee9bd8040e1fdf05002f9f0e37996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b42cd5b8a5143bbe70071806d88ed79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a3b42cd5b8a5143bbe70071806d88ed79">chdrv_int_group_set_dir_in</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a3b42cd5b8a5143bbe70071806d88ed79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the interrupt lines for all sensors in a group as inputs.  <a href="ch__driver_8h.html#a3b42cd5b8a5143bbe70071806d88ed79">More...</a><br /></td></tr>
<tr class="separator:a3b42cd5b8a5143bbe70071806d88ed79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3acb2bef24fed9a2def336958eda23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a8d3acb2bef24fed9a2def336958eda23">chdrv_int_group_set_dir_out</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a8d3acb2bef24fed9a2def336958eda23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the interrupt lines for all sensors in a group as outputs.  <a href="ch__driver_8h.html#a8d3acb2bef24fed9a2def336958eda23">More...</a><br /></td></tr>
<tr class="separator:a8d3acb2bef24fed9a2def336958eda23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd2a9a3814143d3c4d6791a53e659b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a7fd2a9a3814143d3c4d6791a53e659b9">chdrv_int_interrupt_disable</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a7fd2a9a3814143d3c4d6791a53e659b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable interrupts on the interrupt line for a sensor.  <a href="ch__driver_8h.html#a7fd2a9a3814143d3c4d6791a53e659b9">More...</a><br /></td></tr>
<tr class="separator:a7fd2a9a3814143d3c4d6791a53e659b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa7ef214382f49f248e22235c7872a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a21aa7ef214382f49f248e22235c7872a">chdrv_int_interrupt_enable</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a21aa7ef214382f49f248e22235c7872a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupts on the interrupt line for a sensor.  <a href="ch__driver_8h.html#a21aa7ef214382f49f248e22235c7872a">More...</a><br /></td></tr>
<tr class="separator:a21aa7ef214382f49f248e22235c7872a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36ec5b06f3e75d0a84b1dcffc8ca2e3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ae36ec5b06f3e75d0a84b1dcffc8ca2e3">chdrv_int_notify</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t dev_num)</td></tr>
<tr class="memdesc:ae36ec5b06f3e75d0a84b1dcffc8ca2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify SonicLib that a sensor interrupt was received.  <a href="ch__driver_8h.html#ae36ec5b06f3e75d0a84b1dcffc8ca2e3">More...</a><br /></td></tr>
<tr class="separator:ae36ec5b06f3e75d0a84b1dcffc8ca2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebb9684c74cad8c53ab2ce34fc69872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a2ebb9684c74cad8c53ab2ce34fc69872">chdrv_int_set_dir_in</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a2ebb9684c74cad8c53ab2ce34fc69872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the interrupt line for a sensor as an input.  <a href="ch__driver_8h.html#a2ebb9684c74cad8c53ab2ce34fc69872">More...</a><br /></td></tr>
<tr class="separator:a2ebb9684c74cad8c53ab2ce34fc69872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768a64eb2c8d6dd9a0c04b3f255e83a2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a768a64eb2c8d6dd9a0c04b3f255e83a2">chdrv_is_mq_sanitize_enabled</a> (const <a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a768a64eb2c8d6dd9a0c04b3f255e83a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the measurement config sanitization is enabled.  <a href="ch__driver_8h.html#a768a64eb2c8d6dd9a0c04b3f255e83a2">More...</a><br /></td></tr>
<tr class="separator:a768a64eb2c8d6dd9a0c04b3f255e83a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9741825591693ed0c4884d96f34cee8e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a9741825591693ed0c4884d96f34cee8e">chdrv_meas_queue_read</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, measurement_queue_t *q_buf_ptr)</td></tr>
<tr class="memdesc:a9741825591693ed0c4884d96f34cee8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the measurement queue from a sensor.  <a href="ch__driver_8h.html#a9741825591693ed0c4884d96f34cee8e">More...</a><br /></td></tr>
<tr class="separator:a9741825591693ed0c4884d96f34cee8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cd4dacdd3d867e791b5502f8110a45"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#aa2cd4dacdd3d867e791b5502f8110a45">chdrv_meas_queue_write</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, measurement_queue_t *q_buf_ptr)</td></tr>
<tr class="memdesc:aa2cd4dacdd3d867e791b5502f8110a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the measurement queue to a sensor.  <a href="ch__driver_8h.html#aa2cd4dacdd3d867e791b5502f8110a45">More...</a><br /></td></tr>
<tr class="separator:aa2cd4dacdd3d867e791b5502f8110a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145c3f53fda70a1b872d1cdd1d877090"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a145c3f53fda70a1b872d1cdd1d877090">chdrv_one_way_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t tof, uint16_t tof_sf)</td></tr>
<tr class="memdesc:a145c3f53fda70a1b872d1cdd1d877090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the sensor register values to a range using the calibration data in the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> struct.  <a href="ch__driver_8h.html#a145c3f53fda70a1b872d1cdd1d877090">More...</a><br /></td></tr>
<tr class="separator:a145c3f53fda70a1b872d1cdd1d877090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9638c4040534fca4c03b23128a61caa6"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a9638c4040534fca4c03b23128a61caa6">chdrv_otpmem_copy</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, otp_copy_t *otp_copy_ptr)</td></tr>
<tr class="memdesc:a9638c4040534fca4c03b23128a61caa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy OTP memory contents.  <a href="ch__driver_8h.html#a9638c4040534fca4c03b23128a61caa6">More...</a><br /></td></tr>
<tr class="separator:a9638c4040534fca4c03b23128a61caa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2709af034db554ab779aa3621dedc39b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a2709af034db554ab779aa3621dedc39b">chdrv_otpmem_read</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a2709af034db554ab779aa3621dedc39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read OTP memory contents.  <a href="ch__driver_8h.html#a2709af034db554ab779aa3621dedc39b">More...</a><br /></td></tr>
<tr class="separator:a2709af034db554ab779aa3621dedc39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe45d0fa08f49bb074d682d61eae3a2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#abe45d0fa08f49bb074d682d61eae3a2c">chdrv_pretrigger_delay_set</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint16_t delay_us)</td></tr>
<tr class="memdesc:abe45d0fa08f49bb074d682d61eae3a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pre-trigger delay for rx-only sensors.  <a href="ch__driver_8h.html#abe45d0fa08f49bb074d682d61eae3a2c">More...</a><br /></td></tr>
<tr class="separator:abe45d0fa08f49bb074d682d61eae3a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f733653cb68d04027d0b584390c3489"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a1f733653cb68d04027d0b584390c3489">chdrv_prog_i2c_read</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t *message, uint16_t len)</td></tr>
<tr class="memdesc:a1f733653cb68d04027d0b584390c3489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from a CHx01 device in programming mode.  <a href="ch__driver_8h.html#a1f733653cb68d04027d0b584390c3489">More...</a><br /></td></tr>
<tr class="separator:a1f733653cb68d04027d0b584390c3489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcc9cf511218786c38e470f324c8ea1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#abbcc9cf511218786c38e470f324c8ea1">chdrv_prog_i2c_read_nb</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t *message, uint16_t len)</td></tr>
<tr class="memdesc:abbcc9cf511218786c38e470f324c8ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from a CHx01 device in programming mode, non-blocking.  <a href="ch__driver_8h.html#abbcc9cf511218786c38e470f324c8ea1">More...</a><br /></td></tr>
<tr class="separator:abbcc9cf511218786c38e470f324c8ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2eb401431b1de7dd57f7943b055ae79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#af2eb401431b1de7dd57f7943b055ae79">chdrv_prog_i2c_write</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, const uint8_t *message, uint16_t len)</td></tr>
<tr class="memdesc:af2eb401431b1de7dd57f7943b055ae79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to a CHx01 device in programming mode.  <a href="ch__driver_8h.html#af2eb401431b1de7dd57f7943b055ae79">More...</a><br /></td></tr>
<tr class="separator:af2eb401431b1de7dd57f7943b055ae79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733216ad3603716b4fe86a3877e4ae48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a733216ad3603716b4fe86a3877e4ae48">chdrv_prog_mem_write</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t addr, const uint8_t *message, uint16_t nbytes)</td></tr>
<tr class="memdesc:a733216ad3603716b4fe86a3877e4ae48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to CHx01 sensor memory.  <a href="ch__driver_8h.html#a733216ad3603716b4fe86a3877e4ae48">More...</a><br /></td></tr>
<tr class="separator:a733216ad3603716b4fe86a3877e4ae48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405a865671417df936af2c6ba44337c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a405a865671417df936af2c6ba44337c3">chdrv_prog_ping</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a405a865671417df936af2c6ba44337c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect a connected sensor.  <a href="ch__driver_8h.html#a405a865671417df936af2c6ba44337c3">More...</a><br /></td></tr>
<tr class="separator:a405a865671417df936af2c6ba44337c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ceb695e4b6b6979bba4b2d485dd1935"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a6ceb695e4b6b6979bba4b2d485dd1935">chdrv_prog_write</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t reg_addr, uint16_t data)</td></tr>
<tr class="memdesc:a6ceb695e4b6b6979bba4b2d485dd1935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a CHx01 programming register.  <a href="ch__driver_8h.html#a6ceb695e4b6b6979bba4b2d485dd1935">More...</a><br /></td></tr>
<tr class="separator:a6ceb695e4b6b6979bba4b2d485dd1935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388813ed8eaf01de8e17401f3d565973"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a388813ed8eaf01de8e17401f3d565973">chdrv_read_buf_addr</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a388813ed8eaf01de8e17401f3d565973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the IQ buffer address from the sensor and store in dev_ptr.  <a href="ch__driver_8h.html#a388813ed8eaf01de8e17401f3d565973">More...</a><br /></td></tr>
<tr class="separator:a388813ed8eaf01de8e17401f3d565973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63ea7f93bc9f4a468b119a97b3b02df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#aa63ea7f93bc9f4a468b119a97b3b02df">chdrv_read_byte</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t mem_addr, uint8_t *data)</td></tr>
<tr class="memdesc:aa63ea7f93bc9f4a468b119a97b3b02df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read byte from a sensor application register.  <a href="ch__driver_8h.html#aa63ea7f93bc9f4a468b119a97b3b02df">More...</a><br /></td></tr>
<tr class="separator:aa63ea7f93bc9f4a468b119a97b3b02df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada67defc2806336af483ee207d927a3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ada67defc2806336af483ee207d927a3c">chdrv_read_word</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t mem_addr, uint16_t *data)</td></tr>
<tr class="memdesc:ada67defc2806336af483ee207d927a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 16 bits from a sensor application register.  <a href="ch__driver_8h.html#ada67defc2806336af483ee207d927a3c">More...</a><br /></td></tr>
<tr class="separator:ada67defc2806336af483ee207d927a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b38b3e25bdee314ff1692fcb9477775"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a8b38b3e25bdee314ff1692fcb9477775">chdrv_restart</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a8b38b3e25bdee314ff1692fcb9477775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart a sensor.  <a href="ch__driver_8h.html#a8b38b3e25bdee314ff1692fcb9477775">More...</a><br /></td></tr>
<tr class="separator:a8b38b3e25bdee314ff1692fcb9477775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84facb2b2a58d769f1ffd8270c398340"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a84facb2b2a58d769f1ffd8270c398340">chdrv_round_trip_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t tof, uint16_t tof_sf)</td></tr>
<tr class="memdesc:a84facb2b2a58d769f1ffd8270c398340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the sensor register values to a round-trip range using the calibration data in the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> struct.  <a href="ch__driver_8h.html#a84facb2b2a58d769f1ffd8270c398340">More...</a><br /></td></tr>
<tr class="separator:a84facb2b2a58d769f1ffd8270c398340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1a1019ba79ce882b5eb5145ff1e4f8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ade1a1019ba79ce882b5eb5145ff1e4f8">chdrv_run_bist</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ade1a1019ba79ce882b5eb5145ff1e4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run built-in self test (BIST) on sensor.  <a href="ch__driver_8h.html#ade1a1019ba79ce882b5eb5145ff1e4f8">More...</a><br /></td></tr>
<tr class="separator:ade1a1019ba79ce882b5eb5145ff1e4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28642d48731b4e3671d7ca9ade203655"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a28642d48731b4e3671d7ca9ade203655">chdrv_set_idle</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a28642d48731b4e3671d7ca9ade203655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put CHx01 sensor(s) in idle state.  <a href="ch__driver_8h.html#a28642d48731b4e3671d7ca9ade203655">More...</a><br /></td></tr>
<tr class="separator:a28642d48731b4e3671d7ca9ade203655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80b197a070c298b5890fe9aba4263f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ab80b197a070c298b5890fe9aba4263f2">chdrv_soft_reset</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ab80b197a070c298b5890fe9aba4263f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a soft reset on a sensor.  <a href="ch__driver_8h.html#ab80b197a070c298b5890fe9aba4263f2">More...</a><br /></td></tr>
<tr class="separator:ab80b197a070c298b5890fe9aba4263f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6c78fa9f5201f1d075af591b6f46bc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#aea6c78fa9f5201f1d075af591b6f46bc">chdrv_sys_ctrl_read</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t *reg_value_ptr)</td></tr>
<tr class="memdesc:aea6c78fa9f5201f1d075af591b6f46bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the system control register from a sensor.  <a href="ch__driver_8h.html#aea6c78fa9f5201f1d075af591b6f46bc">More...</a><br /></td></tr>
<tr class="separator:aea6c78fa9f5201f1d075af591b6f46bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cea354c8635b2966fae3d29b7369be"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a96cea354c8635b2966fae3d29b7369be">chdrv_sys_ctrl_write</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t reg_value)</td></tr>
<tr class="memdesc:a96cea354c8635b2966fae3d29b7369be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the system control register in a sensor.  <a href="ch__driver_8h.html#a96cea354c8635b2966fae3d29b7369be">More...</a><br /></td></tr>
<tr class="separator:a96cea354c8635b2966fae3d29b7369be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8f74c8a25453be98107dfd79f79708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a6f8f74c8a25453be98107dfd79f79708">chdrv_trig_assert</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a6f8f74c8a25453be98107dfd79f79708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert the hardware trigger line for a sensor.  <a href="ch__driver_8h.html#a6f8f74c8a25453be98107dfd79f79708">More...</a><br /></td></tr>
<tr class="separator:a6f8f74c8a25453be98107dfd79f79708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc765a2d807b342663885146ee42ab36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#afc765a2d807b342663885146ee42ab36">chdrv_trig_deassert</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:afc765a2d807b342663885146ee42ab36"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-assert the hardware trigger line for a sensor.  <a href="ch__driver_8h.html#afc765a2d807b342663885146ee42ab36">More...</a><br /></td></tr>
<tr class="separator:afc765a2d807b342663885146ee42ab36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92499dcecad1de83c11c294f51d019cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a92499dcecad1de83c11c294f51d019cc">chdrv_trig_group_assert</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a92499dcecad1de83c11c294f51d019cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert the hardware trigger lines for all sensors in a group.  <a href="ch__driver_8h.html#a92499dcecad1de83c11c294f51d019cc">More...</a><br /></td></tr>
<tr class="separator:a92499dcecad1de83c11c294f51d019cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf1c16036d133563467f06b7b5062e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#abbf1c16036d133563467f06b7b5062e2">chdrv_trig_group_deassert</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:abbf1c16036d133563467f06b7b5062e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-assert the hardware trigger lines for all sensors in a group.  <a href="ch__driver_8h.html#abbf1c16036d133563467f06b7b5062e2">More...</a><br /></td></tr>
<tr class="separator:abbf1c16036d133563467f06b7b5062e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d1cb524f6276eeae7ce46caf489932"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ad7d1cb524f6276eeae7ce46caf489932">chdrv_trig_group_set_dir_out</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:ad7d1cb524f6276eeae7ce46caf489932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the hardware trigger lines for all sensors in a group as outputs.  <a href="ch__driver_8h.html#ad7d1cb524f6276eeae7ce46caf489932">More...</a><br /></td></tr>
<tr class="separator:ad7d1cb524f6276eeae7ce46caf489932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f982f7bee02ab91d1f6d09e2fd8c13c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a6f982f7bee02ab91d1f6d09e2fd8c13c">chdrv_trig_set_dir_out</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a6f982f7bee02ab91d1f6d09e2fd8c13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the hardware trigger line for a sensor as an output.  <a href="ch__driver_8h.html#a6f982f7bee02ab91d1f6d09e2fd8c13c">More...</a><br /></td></tr>
<tr class="separator:a6f982f7bee02ab91d1f6d09e2fd8c13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac453b83c7c8197be1e5caea164086cf4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#ac453b83c7c8197be1e5caea164086cf4">chdrv_wait_for_lock</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t timeout_ms)</td></tr>
<tr class="memdesc:ac453b83c7c8197be1e5caea164086cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for an individual sensor to finish start-up procedure.  <a href="ch__driver_8h.html#ac453b83c7c8197be1e5caea164086cf4">More...</a><br /></td></tr>
<tr class="separator:ac453b83c7c8197be1e5caea164086cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f710a85393015065e787f0e28a8392d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a8f710a85393015065e787f0e28a8392d">chdrv_write_byte</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t mem_addr, uint8_t data)</td></tr>
<tr class="memdesc:a8f710a85393015065e787f0e28a8392d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write byte to a sensor application register.  <a href="ch__driver_8h.html#a8f710a85393015065e787f0e28a8392d">More...</a><br /></td></tr>
<tr class="separator:a8f710a85393015065e787f0e28a8392d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843af52db125cb64cccca7dd454a8ec7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__driver_8h.html#a843af52db125cb64cccca7dd454a8ec7">chdrv_write_word</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t mem_addr, uint16_t data)</td></tr>
<tr class="memdesc:a843af52db125cb64cccca7dd454a8ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 16 bits to a sensor application register.  <a href="ch__driver_8h.html#a843af52db125cb64cccca7dd454a8ec7">More...</a><br /></td></tr>
<tr class="separator:a843af52db125cb64cccca7dd454a8ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Internal driver functions for operation with the Chirp ultrasonic sensor. </p>
<p>This file contains definitions for the internal Chirp sensor driver functions and structures within SonicLib. These functions are provided in source code form to simplify integration with an embedded application and for reference only.</p>
<p>The Chirp driver functions provide an interface between the SonicLib public API layer and the actual sensor devices. The driver manages all software-defined aspects of the Chirp sensor, including the register set.</p>
<p>You should not need to edit this file or call the driver functions directly. Doing so will reduce your ability to benefit from future enhancements and releases from Chirp. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="abb64488b78685db43351e9b313ff5d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb64488b78685db43351e9b313ff5d29">&#9670;&nbsp;</a></span>CH_PROG_ADDR_DEV_I2C_ADDR_REG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_ADDR_DEV_I2C_ADDR_REG&#160;&#160;&#160;(0x01C5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device own I2C addr register address </p>

</div>
</div>
<a id="a140a5c4c76733dcc1c4046d6d3fe98dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140a5c4c76733dcc1c4046d6d3fe98dc">&#9670;&nbsp;</a></span>CH_PROG_ADDR_IDLE_LOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_ADDR_IDLE_LOC&#160;&#160;&#160;(CHX01_PROG_MEM_ADDR + CHX01_PROG_MEM_SIZE - 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IDLE loop location </p>

</div>
</div>
<a id="aa284c79f9590cfe93801f473a8a9c688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa284c79f9590cfe93801f473a8a9c688">&#9670;&nbsp;</a></span>CH_PROG_ADDR_PMUT_CNTRL4_REG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_ADDR_PMUT_CNTRL4_REG&#160;&#160;&#160;(0x01A6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PMUT CNTRL4 register address </p>

</div>
</div>
<a id="aeb302b57d31a0229525f67d8098e41f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb302b57d31a0229525f67d8098e41f2">&#9670;&nbsp;</a></span>CH_PROG_ADDR_WDT_REG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_ADDR_WDT_REG&#160;&#160;&#160;(0x0120)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Watchdog register address </p>

</div>
</div>
<a id="ab2a08989a943d72f0bac975a55d02188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a08989a943d72f0bac975a55d02188">&#9670;&nbsp;</a></span>CH_PROG_REG_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_REG_ADDR&#160;&#160;&#160;0x05</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data transfer starting address register address. </p>

</div>
</div>
<a id="aeeea872b51aac7857db839b195a17edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeea872b51aac7857db839b195a17edd">&#9670;&nbsp;</a></span>CH_PROG_REG_CNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_REG_CNT&#160;&#160;&#160;0x07</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data transfer size register address. </p>

</div>
</div>
<a id="a03da9ae6a40bdcf4f18ec119be88a7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03da9ae6a40bdcf4f18ec119be88a7d2">&#9670;&nbsp;</a></span>CH_PROG_REG_CPU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_REG_CPU&#160;&#160;&#160;0x42</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Processor control register address. </p>

</div>
</div>
<a id="a6c6e24b1c1d7525a5650797205c8c327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6e24b1c1d7525a5650797205c8c327">&#9670;&nbsp;</a></span>CH_PROG_REG_CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_REG_CTL&#160;&#160;&#160;0x44</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data transfer control register address. </p>

</div>
</div>
<a id="af5161dfbe240f20eb545642332d3000f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5161dfbe240f20eb545642332d3000f">&#9670;&nbsp;</a></span>CH_PROG_REG_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_REG_DATA&#160;&#160;&#160;0x06</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data transfer value register address. </p>

</div>
</div>
<a id="ac696e9971aa740b47aeb4602c622cfe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac696e9971aa740b47aeb4602c622cfe0">&#9670;&nbsp;</a></span>CH_PROG_REG_PING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_REG_PING&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read-only register used during device discovery. </p>

</div>
</div>
<a id="a493f7894d846693e19f866eec5c48aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493f7894d846693e19f866eec5c48aad">&#9670;&nbsp;</a></span>CH_PROG_REG_STAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_REG_STAT&#160;&#160;&#160;0x43</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Processor status register address. </p>

</div>
</div>
<a id="aead6a50cc1df7dbabb33c2b948c7ac4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead6a50cc1df7dbabb33c2b948c7ac4a">&#9670;&nbsp;</a></span>CH_PROG_SIZEOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_SIZEOF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">R</td><td>)</td>
          <td>&#160;&#160;&#160;((R)&amp;0x40 ? 1 : 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to determine programming register size. </p>

</div>
</div>
<a id="ae8330fd24a12c82e7a5d66446ba2c1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8330fd24a12c82e7a5d66446ba2c1e9">&#9670;&nbsp;</a></span>CH_PROG_XFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_PROG_XFER_SIZE&#160;&#160;&#160;(256)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>max size of a read operation via programming interface </p>

</div>
</div>
<a id="a17d1dc5f889265639a1f76800868d3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d1dc5f889265639a1f76800868d3a6">&#9670;&nbsp;</a></span>CHDRV_BANDWIDTH_INDEX_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_BANDWIDTH_INDEX_1&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index of first sample to use for calculating bandwidth. </p>

</div>
</div>
<a id="a4046fd810b274161f020c21ed02f9352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4046fd810b274161f020c21ed02f9352">&#9670;&nbsp;</a></span>CHDRV_BANDWIDTH_INDEX_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_BANDWIDTH_INDEX_2&#160;&#160;&#160;	(<a class="el" href="ch__driver_8h.html#a17d1dc5f889265639a1f76800868d3a6">CHDRV_BANDWIDTH_INDEX_1</a> + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index of second sample to \ use for calculating bandwidth. </p>

</div>
</div>
<a id="a66e5378460204f913bbdc04b1cb7e9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e5378460204f913bbdc04b1cb7e9fb">&#9670;&nbsp;</a></span>CHDRV_DEBUG_PIN_NUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_DEBUG_PIN_NUM&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>debug pin number (index) to use for debug indication </p>

</div>
</div>
<a id="aeba4dde00e9d53fb025d00695866ad5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba4dde00e9d53fb025d00695866ad5e">&#9670;&nbsp;</a></span>CHDRV_DELAY_OVERHEAD_US</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_DELAY_OVERHEAD_US&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tuning parameter to adjust pre-trigger timing </p>

</div>
</div>
<a id="a19b2a185bec85a94cdd00f58ea1cc444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b2a185bec85a94cdd00f58ea1cc444">&#9670;&nbsp;</a></span>CHDRV_EVENT_TIMEOUT_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_EVENT_TIMEOUT_MS&#160;&#160;&#160;(750)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max time to wait for sensor event, in ms </p>

</div>
</div>
<a id="a30d125b6ed3ddcc504f3bc2a5c0bbe84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d125b6ed3ddcc504f3bc2a5c0bbe84">&#9670;&nbsp;</a></span>CHDRV_FREQLOCK_TIMEOUT_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_FREQLOCK_TIMEOUT_MS&#160;&#160;&#160;	100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time to wait in <a class="el" href="ch__driver_8h.html#a84ebcc31b2f386dd673c1b4161830b67" title="Initialize and start a group of sensors.">chdrv_group_start()</a> for sensor \ initialization, in milliseconds. <br  />
 </p>

</div>
</div>
<a id="a632eb3a4c28778cbd004027e11fde059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632eb3a4c28778cbd004027e11fde059">&#9670;&nbsp;</a></span>CHDRV_I2C_MAX_WRITE_BYTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_I2C_MAX_WRITE_BYTES&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum number of bytes in a single I2C write </p>

</div>
</div>
<a id="acafd0645157c35f51250161f5379fa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafd0645157c35f51250161f5379fa45">&#9670;&nbsp;</a></span>CHDRV_I2C_SPEED_DEFAULT_HZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_I2C_SPEED_DEFAULT_HZ&#160;&#160;&#160;(400000)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default I2C speed assumed if CHIRP_I2C_SPEED_HZ not defined in BSP </p>

</div>
</div>
<a id="ac527316c98bd7c0e1939500f02c43484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac527316c98bd7c0e1939500f02c43484">&#9670;&nbsp;</a></span>CHDRV_MAX_QUEUE_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_MAX_QUEUE_LENGTH&#160;&#160;&#160;	CHIRP_MAX_NUM_SENSORS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max queued non-blocking I2C/SPI transactions - value from <a class="el" href="chirp__board__config_8h_source.html">chirp_board_config.h</a> </p>

</div>
</div>
<a id="a657a87e2e6fddfb7f06988954e814f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657a87e2e6fddfb7f06988954e814f9e">&#9670;&nbsp;</a></span>CHDRV_NB_TRANS_TYPE_EXTERNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_NB_TRANS_TYPE_EXTERNAL&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>externally requested non-blocking I/O transaction </p>

</div>
</div>
<a id="a34f8dd7577f6e8522b16e20482fd2cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f8dd7577f6e8522b16e20482fd2cc2">&#9670;&nbsp;</a></span>CHDRV_NB_TRANS_TYPE_PROG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_NB_TRANS_TYPE_PROG&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>non-blocking I/O via low-level programming interface </p>

</div>
</div>
<a id="abe569bd8389300a9d3a490de4392f293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe569bd8389300a9d3a490de4392f293">&#9670;&nbsp;</a></span>CHDRV_NB_TRANS_TYPE_STD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_NB_TRANS_TYPE_STD&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>standard non-blocking I/O transaction </p>

</div>
</div>
<a id="a9b793c41900e340a75d1fa246614f5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b793c41900e340a75d1fa246614f5ff">&#9670;&nbsp;</a></span>CHDRV_POST_ALGO_INIT_DELAY_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_POST_ALGO_INIT_DELAY_MS&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time to delay after triggering algorithm init on sensor, in ms </p>

</div>
</div>
<a id="af1bcecff52fccdf97ea9c02e00b3ac80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bcecff52fccdf97ea9c02e00b3ac80">&#9670;&nbsp;</a></span>CHDRV_POST_TRIG_IEN_DELAY_US</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_POST_TRIG_IEN_DELAY_US&#160;&#160;&#160;	10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time to delay after triggering shared int/trig before re-enabling interrupt </p>

</div>
</div>
<a id="afcabdd3a9dfdbf2a3bd10fa2ed6fa257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcabdd3a9dfdbf2a3bd10fa2ed6fa257">&#9670;&nbsp;</a></span>CHDRV_PRETRIGGER_DELAY_US</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_PRETRIGGER_DELAY_US&#160;&#160;&#160;600</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time to delay between triggering rx-only and tx/rx nodes, in us </p>

</div>
</div>
<a id="a20e47db4dea7e448c25f4f2a774c40a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e47db4dea7e448c25f4f2a774c40a2">&#9670;&nbsp;</a></span>CHDRV_SCALEFACTOR_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_SCALEFACTOR_INDEX&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index for calculating scalefactor. </p>

</div>
</div>
<a id="a1d0c0ee859c73069800b1c8342c0144a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0c0ee859c73069800b1c8342c0144a">&#9670;&nbsp;</a></span>CHDRV_TRIGGER_PULSE_US</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHDRV_TRIGGER_PULSE_US&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of INT pulse to trigger sensor, in microseconds - minimum 800ns. <br  />
 </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6324da3f9d34e13da5e0ff3372f01f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6324da3f9d34e13da5e0ff3372f01f9a">&#9670;&nbsp;</a></span>chdrv_adjust_rx_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_adjust_rx_len </td>
          <td>(</td>
          <td class="paramtype">volatile pmut_transceiver_inst_t *&#160;</td>
          <td class="paramname"><em>trx_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cic_odr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rx_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eof_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function trims the total RX length to remove excess ADC samples that don't result in additional IQ sample. </p>
<p>The ICU-x0201 parts use an oversampling ADC. The PMUT state machine time-base is in terms of the ADC clock. That is, when you set the length of the instruction, you are specifying the length in ADC clock cycles. There are many values of total RX length that result in the same number of total IQ samples. This function trims the excess RX length.</p>
<p>It is required to run this function before loading the config to avoid particular values of RX length that can cause some undesirable or unexpected behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_inst</td><td>a pointer to a instruction sequence. The instructions will potentially be modified by this function </td></tr>
    <tr><td class="paramname">rx_len</td><td>the total rx length in SMCLK cycles </td></tr>
    <tr><td class="paramname">eof_idx</td><td>the index of the EOF instruction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">1</td><td>The trim could not be completed because it would result in a 0 length RX instruction. Either remove the final RX instruction or make it longer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29920c0933777700bce6f82ee6d72355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29920c0933777700bce6f82ee6d72355">&#9670;&nbsp;</a></span>chdrv_algo_cfg_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_algo_cfg_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>algo_cfg_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the algorithm configuration data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if failure detected</dd></dl>
<p>This function reads the algorithm configuration data for an algorithm that has been programmed into an ICU sensor. The format of the configuration data is defined by the specific algorithm being used. </p>

</div>
</div>
<a id="a513dc5c9c35f504e8f0a65ec91da6d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513dc5c9c35f504e8f0a65ec91da6d1a">&#9670;&nbsp;</a></span>chdrv_algo_cfg_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_algo_cfg_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>algo_cfg_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the algorithm configuration data to a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if failure detected</dd></dl>
<p>This function write the algorithm configuration data for an algorithm that has been programmed into an ICU sensor. The format of the configuration data is defined by the specific algorithm being used. </p>

</div>
</div>
<a id="ad9311967cfdd38fce74a494f38266da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9311967cfdd38fce74a494f38266da7">&#9670;&nbsp;</a></span>chdrv_algo_info_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_algo_info_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicu__algo__info.html">ICU_ALGO_SHASTA_INFO</a> *&#160;</td>
          <td class="paramname"><em>algo_info_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the algorithm information data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if failure detected</dd></dl>
<p>This function reads the algorithm information data for an algorithm that has been programmed into an ICU sensor. </p>

</div>
</div>
<a id="a9bd36bcd1cdce82fe2d5cc54dd6af551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd36bcd1cdce82fe2d5cc54dd6af551">&#9670;&nbsp;</a></span>chdrv_algo_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_algo_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the measurement algorithm on a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if failure detected</dd></dl>
<p>This function initializes a measurement algorithm that has already been programmed into an ICU sensor. </p>

</div>
</div>
<a id="a6b27cda636275719606d2ab710844965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b27cda636275719606d2ab710844965">&#9670;&nbsp;</a></span>chdrv_algo_out_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_algo_out_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>algo_out_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the algorithm output data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if failure detected</dd></dl>
<p>This function reads the algorithm output data for an algorithm that has been programmed into an ICU sensor. The format of the output data is defined by the specific algorithm being used. </p>

</div>
</div>
<a id="ad5907f6e8360090c0c353a3f05eb805f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5907f6e8360090c0c353a3f05eb805f">&#9670;&nbsp;</a></span>chdrv_algo_state_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_algo_state_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>algo_state_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the algorithm state data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if failure detected</dd></dl>
<p>This function reads the algorithm state data for an algorithm that has been programmed into an ICU sensor. The format of the state data is defined by the specific algorithm being used. </p>

</div>
</div>
<a id="ada09b53019dc72dce9c861a4d6d3c7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada09b53019dc72dce9c861a4d6d3c7a3">&#9670;&nbsp;</a></span>chdrv_burst_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_burst_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from a sensor application register location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">mem_addr</td><td>sensor memory/register address </td></tr>
    <tr><td class="paramname">data</td><td>pointer to receive buffer </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">mem_addr</td><td>sensor memory/register address </td></tr>
    <tr><td class="paramname">data_ptr</td><td>pointer to receive buffer </td></tr>
    <tr><td class="paramname">num_bytes</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise </dd></dl>

</div>
</div>
<a id="adf7d461b257a90d3f05e68db1e2cbf36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7d461b257a90d3f05e68db1e2cbf36">&#9670;&nbsp;</a></span>chdrv_burst_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_burst_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes to a sensor application register location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">mem_addr</td><td>sensor memory/register address </td></tr>
    <tr><td class="paramname">data</td><td>pointer to transmit buffer containing data to send </td></tr>
    <tr><td class="paramname">num_bytes</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">mem_addr</td><td>sensor memory/register address </td></tr>
    <tr><td class="paramname">data_ptr</td><td>pointer to transmit buffer containing data to send </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise </dd></dl>

</div>
</div>
<a id="a29b2e6c2bf6c22421c45efc8d76cebf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b2e6c2bf6c22421c45efc8d76cebf9">&#9670;&nbsp;</a></span>chdrv_check_reset_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_check_reset_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>reset_state_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if sensor reset has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">reset_state_ptr</td><td>pointer to variable that will be updated with 0 = No Reset, 1 = Reset has occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function checks if an PUC (Power Up Clear) main reset event has occurred by checking the PUC_PND status bit in CPU_STAT debug register. The function updates the "<em>reset_state_ptr</em> is set to 1 if the sensor was reset, otherwise it is set to zero. Note this will continue to return a reset state as set until the PUC_PND bit is cleared by writing a 1 to it, which is done in reset_and_run function. </p>

</div>
</div>
<a id="a0dea5da36604025423fcd06156e3c154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dea5da36604025423fcd06156e3c154">&#9670;&nbsp;</a></span>chdrv_cpu_freq_adjust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t chdrv_cpu_freq_adjust </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pmut_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust sensor micro-controller CPU frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">pmut_freq</td><td>PMUT transducer frequency, in Hz</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sensor CPU frequency after adjustment, in Hz</dd></dl>
<p>This function fine tunes the internal micro-controller processor frequency to avoid harmonic relationships with the PMUT transducer frequency.</p>
<p>See also <em><a class="el" href="ch__driver_8h.html#a90b6cbcfd12570d0b2a14adc3f40fd97" title="Calculate sensor micro-controller CPU frequency, in Hz.">chdrv_cpu_freq_calculate()</a></em> </p>

</div>
</div>
<a id="a90b6cbcfd12570d0b2a14adc3f40fd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b6cbcfd12570d0b2a14adc3f40fd97">&#9670;&nbsp;</a></span>chdrv_cpu_freq_calculate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t chdrv_cpu_freq_calculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate sensor micro-controller CPU frequency, in Hz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sensor CPU frequency, in Hz</dd></dl>
<p>This function calculates and returns the processor frequency, in Hz, of the internal micro-controller in the sensor. </p>

</div>
</div>
<a id="a381f2412d7a8d916dbb5623580fc607f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381f2412d7a8d916dbb5623580fc607f">&#9670;&nbsp;</a></span>chdrv_dbg_reg_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_dbg_reg_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>reg_value_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the debug register from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">reg_value_ptr</td><td>pointer to location to receive register value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if register read succeeded, non-zero otherwise</dd></dl>
<p>This function reads the debug register from an ICU sensor and returns the value in the location specified by <em>reg_value_ptr</em>. </p>

</div>
</div>
<a id="a529370109a4cfcb39ca7eb04042adcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529370109a4cfcb39ca7eb04042adcd3">&#9670;&nbsp;</a></span>chdrv_dbg_reg_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_dbg_reg_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>reg_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the debug register in a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">reg_value</td><td>register value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if register write succeeded, non-zero otherwise</dd></dl>
<p>This function writes <em>reg_value</em> to the debug register in an ICU sensor.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if register write succeeded, non-zero otherwise </dd></dl>

</div>
</div>
<a id="abee4264f20f394d9a6c68dfc0fa654c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee4264f20f394d9a6c68dfc0fa654c4">&#9670;&nbsp;</a></span>chdrv_detect_and_program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_detect_and_program </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect, program, and start a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if write to sensor succeeded, non-zero otherwise</dd></dl>
<p>This function probes the I2C bus for the device. If it is found, the sensor firmware is programmed into the device, and the application I2C address is set. Then the sensor is reset and execution starts.</p>
<p>Once started, the sensor device will begin an internal initialization and self-test sequence.</p>
<p>The <em><a class="el" href="ch__driver_8c.html#ac453b83c7c8197be1e5caea164086cf4" title="Wait for an individual sensor to finish start-up procedure.">chdrv_wait_for_lock()</a></em> function may be used to wait for this sequence to complete.</p>
<dl class="section note"><dt>Note</dt><dd>This routine will leave the PROG pin de-asserted when it completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if write to sensor succeeded, non-zero otherwise</dd></dl>
<p>This function probes the I2C bus for the device. If it is found, the sensor firmware is programmed into the device, and the application I2C address is set. Then the sensor is reset and execution starts.</p>
<p>Once started, the sensor device will begin an internal initialization and self-test sequence. The <em><a class="el" href="ch__driver_8c.html#ac453b83c7c8197be1e5caea164086cf4" title="Wait for an individual sensor to finish start-up procedure.">chdrv_wait_for_lock()</a></em> function may be used to wait for this sequence to complete.</p>
<dl class="section note"><dt>Note</dt><dd>This routine will leave the PROG pin de-asserted when it completes. </dd></dl>

</div>
</div>
<a id="a66665863732013c7ea8f0e608e3abaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66665863732013c7ea8f0e608e3abaca">&#9670;&nbsp;</a></span>chdrv_disable_mq_sanitize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_disable_mq_sanitize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the measurement config sanitization step when loading configs. </p>
<p>Not all possible measurement configurations are valid. In particular, there are limits on instruction length and specific control flags that need to be set appropriately. This function disabled the sanitization, which is on by default.</p>
<p>This function is intended to be called from ch_common_init(), before the FW specific initialization function. This allows a specific ASIC firmware to change the setting in its initialization function.</p>
<p>See <a class="el" href="ch__driver_8h.html#a9e6f6b232156ab586a7747731ddf0728" title="Enable the measurement config sanitization step when loading configs.">chdrv_enable_mq_sanitize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev_ptr</td><td>The device pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="ch__driver_8h.html#a9e6f6b232156ab586a7747731ddf0728" title="Enable the measurement config sanitization step when loading configs.">chdrv_enable_mq_sanitize()</a> and <a class="el" href="ch__driver_8h.html#a768a64eb2c8d6dd9a0c04b3f255e83a2" title="Check whether the measurement config sanitization is enabled.">chdrv_is_mq_sanitize_enabled()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a id="a9e6f6b232156ab586a7747731ddf0728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6f6b232156ab586a7747731ddf0728">&#9670;&nbsp;</a></span>chdrv_enable_mq_sanitize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_enable_mq_sanitize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the measurement config sanitization step when loading configs. </p>
<p>Not all possible measurement configurations are valid. In particular, there are limits on instruction length and specific control flags that need to be set appropriately. This function enables the sanitization, which is on by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev_ptr</td><td>The device pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="ch__driver_8h.html#a66665863732013c7ea8f0e608e3abaca" title="Disable the measurement config sanitization step when loading configs.">chdrv_disable_mq_sanitize()</a> and <a class="el" href="ch__driver_8h.html#a768a64eb2c8d6dd9a0c04b3f255e83a2" title="Check whether the measurement config sanitization is enabled.">chdrv_is_mq_sanitize_enabled()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a id="a4117080373fd81402ca3b88d21516bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4117080373fd81402ca3b88d21516bec">&#9670;&nbsp;</a></span>chdrv_event_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_event_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger an event on a sensor and return immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">event</td><td>event type to trigger</td></tr>
  </table>
  </dd>
</dl>
<p>This function will trigger the event specified by <em>event</em> on an ICU sensor. The routine will return immediately, without waiting for any completion notification from the sensor.</p>
<p>See also <em><a class="el" href="ch__driver_8h.html#a839d70099302ddf05751dc5a8ae11167" title="Trigger an event on a sensor and wait for completion.">chdrv_event_trigger_and_wait()</a></em> </p>

</div>
</div>
<a id="a839d70099302ddf05751dc5a8ae11167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839d70099302ddf05751dc5a8ae11167">&#9670;&nbsp;</a></span>chdrv_event_trigger_and_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_event_trigger_and_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger an event on a sensor and wait for completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">event</td><td>event type to trigger</td></tr>
  </table>
  </dd>
</dl>
<p>This function will trigger the event specified by <em>event</em> on an ICU sensor. The routine will wait for the sensor to indicate the event has completed by generating a pulse on the interrupt line.</p>
<p>See also <em><a class="el" href="ch__driver_8h.html#a4117080373fd81402ca3b88d21516bec" title="Trigger an event on a sensor and return immediately.">chdrv_event_trigger()</a></em> </p>

</div>
</div>
<a id="ace484e88914368eaa699680d61e9ed4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace484e88914368eaa699680d61e9ed4f">&#9670;&nbsp;</a></span>chdrv_external_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_external_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rd_wrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an I2C/SPI transaction for an external device to the non-blocking queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors </td></tr>
    <tr><td class="paramname">instance</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">rd_wrb</td><td>read/write indicator: 0 if write operation, 1 if read operation </td></tr>
    <tr><td class="paramname">addr</td><td>I2C address for transfer (for I2C devices only) </td></tr>
    <tr><td class="paramname">nbytes</td><td>number of bytes to read/write </td></tr>
    <tr><td class="paramname">data</td><td>pointer to buffer to receive data or containing data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function queues an I2C/SPI transaction for an "external" device (i.e. not a Chirp sensor). It is used when the I2C/SPI bus is shared between the Chirp sensor(s) and other devices.</p>
<p>The transaction is flagged for special handling when the I/O operation completes. Specifically, the <em><a class="el" href="chirp__bsp_8h.html#a3a3ecf5c737e49a39bbe34a7c9100158" title="Interrupt handler callout for external devices sharing the SPI/I2C bus.">chbsp_external_irq_handler()</a></em> will be called by the driver to allow the board support package (BSP) to perform any necessary operations. </p>

</div>
</div>
<a id="af11d0f71857658acbdd86368705916ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11d0f71857658acbdd86368705916ce">&#9670;&nbsp;</a></span>chdrv_group_detect_and_program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_group_detect_and_program </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect, program, and start all sensors in a group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, non-zero if write(s) failed to any sensor initially detected as present</dd></dl>
<p>This function probes the SPI or I2C bus for each device in the group. For each detected sensor, the firmware is programmed into the device, and in CHx01 sensors the application I2C address is set. Then the sensor is reset and execution starts.</p>
<p>Once started, each device will begin an internal initialization and self-test sequence.</p>
<dl class="section note"><dt>Note</dt><dd>For CHx01 sensors, this routine will leave the PROG pin de-asserted for all devices in the group when it completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, non-zero if write(s) failed to any sensor initially detected as present</dd></dl>
<p>This function probes the I2C bus for each device in the group. For each detected sensor, the sensor firmware is programmed into the device, and the application I2C address is set. Then the sensor is reset and execution starts.</p>
<p>Once started, each sensor device will begin an internal initialization and self-test sequence. The <em><a class="el" href="ch__driver_8c.html#a749c1460a862744d642dd7c79dc768f3" title="Wait for all sensors to finish start-up procedure.">chdrv_group_wait_for_lock()</a></em> function may be used to wait for this sequence to complete on all devices in the group.</p>
<dl class="section note"><dt>Note</dt><dd>This routine will leave the PROG pin de-asserted for all devices in the group when it completes. </dd></dl>

</div>
</div>
<a id="a08697d8ec41c448731e9dd990a98f83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08697d8ec41c448731e9dd990a98f83c">&#9670;&nbsp;</a></span>chdrv_group_hard_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_group_hard_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a hard reset on a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function performs a hardware reset on each device in a group of sensors by asserting each device's RESET_N pin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function performs a hardware reset on each device in a group of sensors. For CH101 and CH201 sensors, each device's RESET_N pin is asserted and then a soft reset is performed.</p>
<p>ICU sensors do not have a hardware reset pin, so only a soft reset is performed. </p>

</div>
</div>
<a id="a30af69acd077caa33fc61cd792c8a4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30af69acd077caa33fc61cd792c8a4e9">&#9670;&nbsp;</a></span>chdrv_group_hw_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_group_hw_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a measurement in hardware triggered mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if <em>grp_ptr</em> pointer is invalid</dd></dl>
<p>This function starts a triggered measurement on each sensor in a group, by briefly asserting the INT line to each device. Each sensor must have already been placed in hardware triggered mode before this function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if <em>grp_ptr</em> pointer is invalid</dd></dl>
<p>This function starts a triggered measurement on each sensor in a group, by briefly asserting the INT line to each device. Each sensor must have already been placed in hardware triggered mode before this function is called. </p>

</div>
</div>
<a id="a0607fc0bdc3c2ac43e1ee568a470893c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0607fc0bdc3c2ac43e1ee568a470893c">&#9670;&nbsp;</a></span>chdrv_group_irq_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_group_irq_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bus_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continue a non-blocking readout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors </td></tr>
    <tr><td class="paramname">bus_index</td><td>index value identifying I2C/SPI bus within group</td></tr>
  </table>
  </dd>
</dl>
<p>Call this function once from your I2C/SPI interrupt handler each time it executes. It will call <em>chdrv_group_complete_callback()</em> when all transactions are complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors </td></tr>
    <tr><td class="paramname">bus_index</td><td>index value identifying I2C/SPI bus within group</td></tr>
  </table>
  </dd>
</dl>
<p>Call this function once from your I2C interrupt handler each time it executes. It will call the user's callback routine (grp_ptr-&gt;io_complete_callback) when all transactions are complete. </p>

</div>
</div>
<a id="aa403f37e04225e36c94aa861008d8daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa403f37e04225e36c94aa861008d8daa">&#9670;&nbsp;</a></span>chdrv_group_measure_pmut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_group_measure_pmut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the ultrasonic transducer frequency &amp; bandwidth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if error</dd></dl>
<p>This function initiates the calibration of the PMUT transducer to determine performance characteristics, including operating frequency and bandwidth. </p>

</div>
</div>
<a id="a8340741f29416ac3574add49552ba12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8340741f29416ac3574add49552ba12c">&#9670;&nbsp;</a></span>chdrv_group_measure_rtc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_group_measure_rtc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibrate the sensor real-time clock against the host microcontroller clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function sends a pulse (timed by the host MCU) on the INT line to each device in the group, then reads back the count of sensor RTC cycles that elapsed during that pulse on each individual device. The result is stored in the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for each device and is subsequently used during range calculations.</p>
<p>The length of the pulse is grp_ptr-&gt;rtc_cal_pulse_ms milliseconds (typically 100ms).</p>
<dl class="section note"><dt>Note</dt><dd>The calibration pulse is sent to all devices in the group at the same time. Therefore all connected devices will see the same reference pulse length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function sends a pulse (timed by the host MCU) on the INT line to each sensor device in the group, then reads back the counts of sensor RTC cycles that elapsed during that pulse on each individual device. The result is stored in the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for each device and is subsequently used during range calculations.</p>
<p>The length of the pulse is <em>dev_ptr-&gt;rtc_cal_pulse_ms</em> milliseconds (typically 100). This value is set during <em><a class="el" href="ch__api_8c.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize a Chirp ultrasonic sensor descriptor structure.">ch_init()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>The calibration pulse is sent to all devices in the group at the same time. Therefore all connected devices will see the same reference pulse length. </dd></dl>

</div>
</div>
<a id="a63b00db198daeb94f05224a07a83dcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b00db198daeb94f05224a07a83dcef">&#9670;&nbsp;</a></span>chdrv_group_measure_rtc_no_pulse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_group_measure_rtc_no_pulse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibrate the sensor real-time clock without using a pulse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used when special RTC calibration using the I/O bus clock signal is used instead of a normal pulse on the INT line. So, this routine only places the sensor in calibration mode and then reads the result when complete.</p>
<p>A special opcode command is written to the normal pre-calibration "trigger" register, followed by a long dummy write transfer. During the dummy transfer, the sensor will perform its RTC calibration based on the I/O bus clock. The result is then read as in a normal calibration, except special handling is required to calculate the RTC frequency based on the result.</p>
<dl class="section note"><dt>Note</dt><dd>This method is only supported in select sensor firmware variants. </dd></dl>

</div>
</div>
<a id="a9847ced274a5565b784ef3598c67e39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9847ced274a5565b784ef3598c67e39f">&#9670;&nbsp;</a></span>chdrv_group_prepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_group_prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize data structures and hardware for sensor interaction and reset sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if hardware initialization is successful, non-zero otherwise</dd></dl>
<p>This function is called internally by <em><a class="el" href="ch__driver_8h.html#a84ebcc31b2f386dd673c1b4161830b67" title="Initialize and start a group of sensors.">chdrv_group_start()</a></em>.</p>
<p>Initialize data structures and hardware for sensor interaction and reset sensors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors </td></tr>
    <tr><td class="paramname">num_ports</td><td>the total number of physical sensor ports available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if hardware initialization is successful, non-zero otherwise</dd></dl>
<p>This function is called internally by <em><a class="el" href="ch__driver_8h.html#a84ebcc31b2f386dd673c1b4161830b67" title="Initialize and start a group of sensors.">chdrv_group_start()</a></em>. </p>

</div>
</div>
<a id="a52cff3a57de90f11a05179a4c7a43d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52cff3a57de90f11a05179a4c7a43d9a">&#9670;&nbsp;</a></span>chdrv_group_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_group_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rd_wrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an I2C/SPI transaction to the non-blocking queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors </td></tr>
    <tr><td class="paramname">instance</td><td>pointer to an individual descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">rd_wrb</td><td>read/write indicator: 0 if write operation, 1 if read operation </td></tr>
    <tr><td class="paramname">type</td><td>transaction type: 0 = std, 1 = prog interface, 2 = external </td></tr>
    <tr><td class="paramname">addr</td><td>I2C address for transfer </td></tr>
    <tr><td class="paramname">nbytes</td><td>number of bytes to read/write </td></tr>
    <tr><td class="paramname">data</td><td>pointer to buffer to receive data or containing data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors </td></tr>
    <tr><td class="paramname">dev_ptr</td><td>pointer to an individual <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">rd_wrb</td><td>read/write indicator: 0 if write operation, 1 if read operation </td></tr>
    <tr><td class="paramname">type</td><td>type of transaction (standard, program interface, or external) </td></tr>
    <tr><td class="paramname">addr</td><td>I2C address </td></tr>
    <tr><td class="paramname">nbytes</td><td>number of bytes to read/write </td></tr>
    <tr><td class="paramname">data_ptr</td><td>pointer to buffer to receive data or containing data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise </dd></dl>

</div>
</div>
<a id="ac2965d93ed511809740890444c0d050c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2965d93ed511809740890444c0d050c">&#9670;&nbsp;</a></span>chdrv_group_soft_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_group_soft_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a soft reset on a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function performs a soft reset on each device in a group of sensors by writing to a special control register.</p>
<p>Perform a soft reset on a group of sensors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function performs a soft reset on each device in a group of sensors by writing to a special control register. </p>

</div>
</div>
<a id="a84ebcc31b2f386dd673c1b4161830b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ebcc31b2f386dd673c1b4161830b67">&#9670;&nbsp;</a></span>chdrv_group_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_group_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize and start a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if device doesn't respond</dd></dl>
<p>This function resets each sensor in programming mode, transfers the firmware image to the sensor's on-chip memory, and starts the sensor. For CH101 and CH201 sensors, the I2C address is changed from the default value.</p>
<p>In a normal startup, a timed pulse is sent on the INT line for real-time clock calibration. This may be over-ridden by specifying that default (factory) values should be used, or by supplying custom clock calibration values. Either of these options may be enabled by calling the <em>ch_set_clock_cal()</em> function before <a class="el" href="ch__api_8c.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a>.</p>
<p>This function assumes firmware-specific initialization has already been performed for each <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor in the sensor group. (See <em><a class="el" href="ch__api_8c.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize a Chirp ultrasonic sensor descriptor structure.">ch_init()</a></em>). </p>

</div>
</div>
<a id="ad875c0fbd76673955c1932ed86e237bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad875c0fbd76673955c1932ed86e237bb">&#9670;&nbsp;</a></span>chdrv_group_start_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_group_start_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a non-blocking sensor readout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function starts a non-blocking I/O operation on the specified group of sensors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function starts a non-blocking I/O operation on the specified group of sensors. </p>

</div>
</div>
<a id="a749c1460a862744d642dd7c79dc768f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749c1460a862744d642dd7c79dc768f3">&#9670;&nbsp;</a></span>chdrv_group_wait_for_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_group_wait_for_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for all sensors to finish start-up procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if startup sequence finished on all detected sensors, non-zero if startup sequence timed out on any sensor(s).</dd></dl>
<p>After each sensor is programmed, it executes an internal start-up and self-test sequence. This function waits for all sensor devices to finish this sequence. For each device, the maximum time to wait is <em>CHDRV_FREQLOCK_TIMEOUT_MS</em> milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if startup sequence finished on all detected sensors, non-zero if startup sequence timed out on any sensor(s).</dd></dl>
<p>After each sensor is programmed, it executes an internal start-up and self-test sequence. This function waits for all sensor devices to finish this sequence. For each device, the maximum time to wait is <em>CHDRV_FREQLOCK_TIMEOUT_MS</em> milliseconds. </p>

</div>
</div>
<a id="a00d365a4847bea8941720fea048d4164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d365a4847bea8941720fea048d4164">&#9670;&nbsp;</a></span>chdrv_hw_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_hw_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a measurement in hardware triggered mode on one sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if <em>dev_ptr</em> pointer is invalid</dd></dl>
<p>This function starts a triggered measurement on a single sensor, by briefly asserting the INT line to the device. The sensor must have already been placed in hardware triggered mode before this function is called.</p>
<dl class="section note"><dt>Note</dt><dd>This function requires implementing the optional <a class="el" href="chirp__bsp_8h.html" title="User-supplied board support package functions to interface Chirp SonicLib to a specific hardware plat...">chirp_bsp.h</a> functions to control the INT pin direction and level for individual sensors (<em><a class="el" href="chirp__bsp_8h.html#a065954f3b9c1192dd12c812ed8643dbb" title="Configure the Chirp sensor INT1 pin as an input for one sensor.">chbsp_set_int1_dir_in()</a></em>, <em><a class="el" href="chirp__bsp_8h.html#afcf819fd97839ad99c70b0b7c6f0c464" title="Configure the Chirp sensor INT1 pin as an output for one sensor.">chbsp_set_int1_dir_out()</a></em>, <em><a class="el" href="chirp__bsp_8h.html#ac2872cc61b8eef99de1cc9a48e4f35d9" title="Set the INT1 pin high for one sensor.">chbsp_int1_set()</a></em>, and <em><a class="el" href="chirp__bsp_8h.html#af3885fb01d51aa432bcc6882e23ee0e5" title="Set the INT1 pin low for one sensor.">chbsp_int1_clear()</a></em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if <em>dev_ptr</em> pointer is invalid</dd></dl>
<p>This function starts a triggered measurement on a single sensor, by briefly asserting the INT line to the device. The sensor must have already been placed in hardware triggered mode before this function is called.</p>
<dl class="section note"><dt>Note</dt><dd>This function requires implementing the optional BSP functions to control the INT pin direction and level for individual sensors (<em><a class="el" href="chirp__bsp_8h.html#a065954f3b9c1192dd12c812ed8643dbb" title="Configure the Chirp sensor INT1 pin as an input for one sensor.">chbsp_set_int1_dir_in()</a></em>, <em><a class="el" href="chirp__bsp_8h.html#afcf819fd97839ad99c70b0b7c6f0c464" title="Configure the Chirp sensor INT1 pin as an output for one sensor.">chbsp_set_int1_dir_out()</a></em>, <em><a class="el" href="chirp__bsp_8h.html#ac2872cc61b8eef99de1cc9a48e4f35d9" title="Set the INT1 pin high for one sensor.">chbsp_int1_set()</a></em>, and <em><a class="el" href="chirp__bsp_8h.html#af3885fb01d51aa432bcc6882e23ee0e5" title="Set the INT1 pin low for one sensor.">chbsp_int1_clear()</a></em>). </dd></dl>

</div>
</div>
<a id="ad9c3a9471210a1db098ccf321d71d350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c3a9471210a1db098ccf321d71d350">&#9670;&nbsp;</a></span>chdrv_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i2c_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>io_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bus_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>part_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the sensor device configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure to be initialized </td></tr>
    <tr><td class="paramname">i2c_addr</td><td>For CHx01 sensors, the I2C address to assign to this device. This will be the "application I2C address" used to access the device after it is initialized. Each sensor on an I2C interface must use a unique application I2C address. For ICU sensors, this field is ignored. </td></tr>
    <tr><td class="paramname">io_index</td><td>index identifying this device. Each sensor in a group must have a unique <em>io_index</em> value. </td></tr>
    <tr><td class="paramname">bus_index</td><td>index identifying the I2C/SPI interface (bus) to use with this device </td></tr>
    <tr><td class="paramname">part_number</td><td>integer part number for sensor (e.g. 101 for CH101 device, or 20201 for ICU-20201))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (always)</dd></dl>
<p>This function initializes the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for the device with the specified values. </p>

</div>
</div>
<a id="a57e0ec9efd96a9470dee37e6df5a6047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e0ec9efd96a9470dee37e6df5a6047">&#9670;&nbsp;</a></span>chdrv_int_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_int_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver callback routine for sensor interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors </td></tr>
    <tr><td class="paramname">dev_num</td><td>interrupting sensor's device number within group</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called from <em><a class="el" href="ch__api_8c.html#a68080a85a27dc680ce55c020f575c5c3" title="Notify SonicLib that a sensor interrupt occurred.">ch_interrupt()</a></em> when an interrupt from the sensor is received. The <em>dev_num</em> parameter indicates which sensor interrupted. </p>

</div>
</div>
<a id="a7f045c98d7f0219f18e0de939fb77d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f045c98d7f0219f18e0de939fb77d00">&#9670;&nbsp;</a></span>chdrv_int_callback_deferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_int_callback_deferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver callback deferred routine for sensor interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors </td></tr>
    <tr><td class="paramname">dev_num</td><td>interrupting sensor's device number within group</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called from <em><a class="el" href="ch__api_8c.html#a68080a85a27dc680ce55c020f575c5c3" title="Notify SonicLib that a sensor interrupt occurred.">ch_interrupt()</a></em> when an interrupt from the sensor is received. Or shall be called in app context if USE_DEFERRED_INTERRUPT_PROCESSING is defined. The <em>dev_num</em> parameter indicates which sensor interrupted.</p>
<p>For sensor data-ready interrupts, this routine will in turn call the application's callback routine which was set using <em><a class="el" href="ch__api_8c.html#af3d4045f3510d82596c8231123e890b9" title="Set callback function for Chirp sensor I/O interrupt.">ch_io_int_callback_set()</a></em>.</p>
<p>See also <em><a class="el" href="ch__api_8c.html#af3d4045f3510d82596c8231123e890b9" title="Set callback function for Chirp sensor I/O interrupt.">ch_io_int_callback_set()</a></em> </p>

</div>
</div>
<a id="a396170bdd891cf5177cd87203580a152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396170bdd891cf5177cd87203580a152">&#9670;&nbsp;</a></span>chdrv_int_group_assert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_int_group_assert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert the interrupt lines for all sensors in a group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function asserts the interrupt lines for all sensors in a group. For ICU sensors, the lines indicated by the current measurement configuration for interrupt pin (INT1 or INT2) will be set to a low (active) level. For CH101/CH201 sensors, the sensors' INT lines will be set to a high level.</p>
<p>This function calls the appropriate routine(s) in the the board support package to manipulate the line levels.</p>
<p>See also <em><a class="el" href="ch__driver_8h.html#afc765a2d807b342663885146ee42ab36" title="De-assert the hardware trigger line for a sensor.">chdrv_trig_deassert()</a></em>, <em><a class="el" href="ch__driver_8h.html#a92499dcecad1de83c11c294f51d019cc" title="Assert the hardware trigger lines for all sensors in a group.">chdrv_trig_group_assert()</a></em> </p>

</div>
</div>
<a id="a3e1d1f445752b38043011e785ae71b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1d1f445752b38043011e785ae71b37">&#9670;&nbsp;</a></span>chdrv_int_group_deassert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_int_group_deassert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-assert the interrupt lines for all sensors in a group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function de-asserts the interrupt lines for all sensors in a group. For ICU sensors, the lines indicated by the current measurement configuration for interrupt pin (INT1 or INT2) will be reset to a high (inactive) level. For CH101/CH201 sensors, the sensors' INT lines will be reset to a low level.</p>
<p>This function calls the appropriate routine(s) in the the board support package to manipulate the line levels.</p>
<p>See also <em><a class="el" href="ch__driver_8h.html#afc765a2d807b342663885146ee42ab36" title="De-assert the hardware trigger line for a sensor.">chdrv_trig_deassert()</a></em>, <em><a class="el" href="ch__driver_8h.html#a92499dcecad1de83c11c294f51d019cc" title="Assert the hardware trigger lines for all sensors in a group.">chdrv_trig_group_assert()</a></em> </p>

</div>
</div>
<a id="a8f9706b1ff5e390d393af514ce983202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9706b1ff5e390d393af514ce983202">&#9670;&nbsp;</a></span>chdrv_int_group_interrupt_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_int_group_interrupt_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable interrupts on the interrupt lines for all sensors in a group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables host micro-controller interrupts from being generated by all interrupt lines for sensors in the specified sensor group.</p>
<p>For ICU sensors, the lines indicated by the current measurement configuration for interrupt pin (INT1 or INT2) will have interrupts disabled. For CH101/CH201 sensors, the single INT lines will have interrupts disabled.</p>
<p>This function calls the appropriate routine(s) in the the board support package to disable interrupts.</p>
<p>See also <em>chdrv_int_interrupt_disable</em>, <em><a class="el" href="ch__driver_8h.html#aac7ee9bd8040e1fdf05002f9f0e37996" title="Enable interrupts on the interrupt lines for all sensors in a group.">chdrv_int_group_interrupt_enable()</a></em> </p>

</div>
</div>
<a id="aac7ee9bd8040e1fdf05002f9f0e37996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7ee9bd8040e1fdf05002f9f0e37996">&#9670;&nbsp;</a></span>chdrv_int_group_interrupt_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_int_group_interrupt_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupts on the interrupt lines for all sensors in a group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables host micro-controller interrupts to be generated by all interrupt lines for sensors in the specified sensor group.</p>
<p>For ICU sensors, the lines indicated by the current measurement configuration for interrupt pin (INT1 or INT2) will have interrupts enabled. For CH101/CH201 sensors, the single INT lines will have interrupts enabled.</p>
<p>This function calls the appropriate routine(s) in the the board support package to enable interrupts.</p>
<p>See also <em>chdrv_int_interrupt_enable</em>, <em><a class="el" href="ch__driver_8h.html#a8f9706b1ff5e390d393af514ce983202" title="Disable interrupts on the interrupt lines for all sensors in a group.">chdrv_int_group_interrupt_disable()</a></em> </p>

</div>
</div>
<a id="a3b42cd5b8a5143bbe70071806d88ed79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b42cd5b8a5143bbe70071806d88ed79">&#9670;&nbsp;</a></span>chdrv_int_group_set_dir_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_int_group_set_dir_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the interrupt lines for all sensors in a group as inputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the interrupt lines for all sensors in a group as input pins. For ICU sensors, the current measurement configuration for interrupt pin (INT1 or INT2) is used. For CH101/CH201 sensors, the single INT line is used.</p>
<p>This function calls the appropriate routine(s) in the the board support package to set the pin direction. </p>

</div>
</div>
<a id="a8d3acb2bef24fed9a2def336958eda23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3acb2bef24fed9a2def336958eda23">&#9670;&nbsp;</a></span>chdrv_int_group_set_dir_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_int_group_set_dir_out </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the interrupt lines for all sensors in a group as outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the interrupt lines for all sensors in a group as output pins. For ICU sensors, the current measurement configuration for interrupt pin (INT1 or INT2) is used. For CH101/CH201 sensors, the single INT line is used.</p>
<p>This function calls the appropriate routine(s) in the the board support package to set the pin direction. </p>

</div>
</div>
<a id="a7fd2a9a3814143d3c4d6791a53e659b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd2a9a3814143d3c4d6791a53e659b9">&#9670;&nbsp;</a></span>chdrv_int_interrupt_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_int_interrupt_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable interrupts on the interrupt line for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables host micro-controller interrupts from being generated by the specified sensor's interrupt line.</p>
<p>For ICU sensors, the line indicated by the current measurement configuration for interrupt pin (INT1 or INT2) will have interrupts disabled. For CH101/CH201 sensors, the single INT line will have interrupts disabled.</p>
<p>This function calls the appropriate routine(s) in the the board support package to disable interrupts.</p>
<p>See also <em><a class="el" href="ch__driver_8h.html#a21aa7ef214382f49f248e22235c7872a" title="Enable interrupts on the interrupt line for a sensor.">chdrv_int_interrupt_enable()</a></em>, <em><a class="el" href="ch__driver_8h.html#a8f9706b1ff5e390d393af514ce983202" title="Disable interrupts on the interrupt lines for all sensors in a group.">chdrv_int_group_interrupt_disable()</a></em> </p>

</div>
</div>
<a id="a21aa7ef214382f49f248e22235c7872a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aa7ef214382f49f248e22235c7872a">&#9670;&nbsp;</a></span>chdrv_int_interrupt_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_int_interrupt_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupts on the interrupt line for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables host micro-controller interrupts to be generated by the specified sensor's interrupt line.</p>
<p>For ICU sensors, the line indicated by the current measurement configuration for interrupt pin (INT1 or INT2) will have interrupts enabled. For CH101/CH201 sensors, the single INT line will have interrupts enabled.</p>
<p>This function calls the appropriate routine(s) in the the board support package to enable interrupts.</p>
<p>See also <em><a class="el" href="ch__driver_8h.html#a7fd2a9a3814143d3c4d6791a53e659b9" title="Disable interrupts on the interrupt line for a sensor.">chdrv_int_interrupt_disable()</a></em>, <em><a class="el" href="ch__driver_8h.html#aac7ee9bd8040e1fdf05002f9f0e37996" title="Enable interrupts on the interrupt lines for all sensors in a group.">chdrv_int_group_interrupt_enable()</a></em> </p>

</div>
</div>
<a id="ae36ec5b06f3e75d0a84b1dcffc8ca2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36ec5b06f3e75d0a84b1dcffc8ca2e3">&#9670;&nbsp;</a></span>chdrv_int_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_int_notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify SonicLib that a sensor interrupt was received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors </td></tr>
    <tr><td class="paramname">dev_num</td><td>interrupting sensor's device number within group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, non-zero otherwise.</dd></dl>
<p>This function should be called from the board support package when an interrupt from the sensor is received. The <em>dev_num</em> parameter indicates which sensor interrupted.</p>
<p>Unlike <em><a class="el" href="ch__driver_8h.html#a57e0ec9efd96a9470dee37e6df5a6047" title="Driver callback routine for sensor interrupt.">chdrv_int_callback()</a></em>, this function does not call the user supplied callback. It is intended to be used when the user would like more control of exactly what happens when an interrupt is received from the sensor.</p>
<p>Other differences from <em><a class="el" href="ch__driver_8h.html#a57e0ec9efd96a9470dee37e6df5a6047" title="Driver callback routine for sensor interrupt.">chdrv_int_callback()</a></em>:</p>
<ul>
<li>This function does not disable interrupt handling. This must be done in user code if needed.</li>
<li>This function does not read any metadata from the sensor, with one exception. During sensor programming, this funciton performs one SPI read in order to cause the ASIC to release the interrupt line.</li>
<li>This function does not update state of the dev_ptr </li>
</ul>

</div>
</div>
<a id="a2ebb9684c74cad8c53ab2ce34fc69872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebb9684c74cad8c53ab2ce34fc69872">&#9670;&nbsp;</a></span>chdrv_int_set_dir_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_int_set_dir_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the interrupt line for a sensor as an input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the specified sensor's interrupt line an an input pin. For ICU sensors, the current measurement configuration for interrupt pin (INT1 or INT2) is used. For CH101/CH201 sensors, the single INT line is used.</p>
<p>This function calls the appropriate routine(s) in the the board support package to set the pin direction. </p>

</div>
</div>
<a id="a768a64eb2c8d6dd9a0c04b3f255e83a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768a64eb2c8d6dd9a0c04b3f255e83a2">&#9670;&nbsp;</a></span>chdrv_is_mq_sanitize_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t chdrv_is_mq_sanitize_enabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the measurement config sanitization is enabled. </p>
<p>See <a class="el" href="ch__driver_8h.html#a9e6f6b232156ab586a7747731ddf0728" title="Enable the measurement config sanitization step when loading configs.">chdrv_enable_mq_sanitize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev_ptr</td><td>The device pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The enabled status of the sanitization.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Sanitization disabled. </td></tr>
    <tr><td class="paramname">1</td><td>Sanitization enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a id="a9741825591693ed0c4884d96f34cee8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9741825591693ed0c4884d96f34cee8e">&#9670;&nbsp;</a></span>chdrv_meas_queue_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_meas_queue_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">measurement_queue_t *&#160;</td>
          <td class="paramname"><em>q_buf_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the measurement queue from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">q_buf_ptr</td><td>pointer to the meas queue to write, NULL = update <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if error</dd></dl>
<p>This function reads the measurement queue structure from the sensor and copies it to the location indiciated by <em>q_buf_ptr</em>.</p>
<p>If <em>q_buf_ptr</em> is NULL, the measurement queue copy in the <em><a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a></em> descriptor will be updated with the values read from the sensor. If <em>q_buf_ptr</em> is not NULL, the measurement queue values read from the device will be copied to the specified location. </p>

</div>
</div>
<a id="aa2cd4dacdd3d867e791b5502f8110a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cd4dacdd3d867e791b5502f8110a45">&#9670;&nbsp;</a></span>chdrv_meas_queue_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_meas_queue_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">measurement_queue_t *&#160;</td>
          <td class="paramname"><em>q_buf_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the measurement queue to a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">q_buf_ptr</td><td>pointer to the meas queue to write, NULL = use <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if error</dd></dl>
<p>This function writes a measurement queue structure to a sensor.</p>
<p>If <em>q_buf_ptr</em> is NULL, this function writes the local copy of the measurement queue structure in <em><a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a></em> to the sensor shared memory. It is typically used after some measurement settings have been modified. If <em>q_buf_ptr</em> is not NULL, the measurement queue values from the specified location will be written to the sensor. The copy in the <em><a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a></em> structure is not modified. </p>

</div>
</div>
<a id="a145c3f53fda70a1b872d1cdd1d877090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145c3f53fda70a1b872d1cdd1d877090">&#9670;&nbsp;</a></span>chdrv_one_way_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t chdrv_one_way_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tof_sf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the sensor register values to a range using the calibration data in the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">tof</td><td>value of TOF register </td></tr>
    <tr><td class="paramname">tof_sf</td><td>value of TOF_SF register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range in millimeters, or <em>CH_NO_TARGET</em> (0xFFFFFFFF) if no object is detected. The range result format is fixed point with 5 binary fractional digits (divide by 32 to convert to mm).</dd></dl>
<p>This function takes the time-of-flight and scale factor values from the sensor, and computes the actual one-way range based on the formulas given in the sensor datasheet.</p>
<p>Convert the sensor register values to a range using the calibration data in the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> struct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">tof</td><td>value of sensor TOF register </td></tr>
    <tr><td class="paramname">tof_sf</td><td>value of sensor TOF_SF register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range in millimeters, or <em>CH_NO_TARGET</em> (0xFFFFFFFF) if no object is detected.</dd></dl>
<p>The range result format is fixed point with 5 binary fractional digits (divide by 32 to convert to mm).</p>
<p>This function takes the time-of-flight and scale factor values from the sensor, and computes the actual one-way range based on the formulas given in the sensor datasheet. </p>

</div>
</div>
<a id="a9638c4040534fca4c03b23128a61caa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9638c4040534fca4c03b23128a61caa6">&#9670;&nbsp;</a></span>chdrv_otpmem_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_otpmem_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">otp_copy_t *&#160;</td>
          <td class="paramname"><em>otp_copy_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy OTP memory contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">otp_copy_ptr</td><td>address of otp_copy_t structure to receive OTP contents</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads the contents of the one-time programmable (OTP) memory in the sensor and copies the values to the structure specified by <em>otp_copy_ptr</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Before this function may be used the first time, the sensor must be instructed to copy the internal OTP values to a shared memory location accessible via SPI. The EVENT_COPY_OTP_TO_RAM event must be issued to the sensor to perform this operation.</dd></dl>
<p>See also <em><a class="el" href="ch__driver_8h.html#a2709af034db554ab779aa3621dedc39b" title="Read OTP memory contents.">chdrv_otpmem_read()</a></em> </p>

</div>
</div>
<a id="a2709af034db554ab779aa3621dedc39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2709af034db554ab779aa3621dedc39b">&#9670;&nbsp;</a></span>chdrv_otpmem_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_otpmem_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read OTP memory contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads and processes the contents of the one-time programmable (OTP) memory in the sensor. The OTP memory contains unique information about the sensor device, such as the sensor lot and serial number, production date and location, and specific part and packaging information.</p>
<p>This function instructs the sensor to copy its internal OTP values to an SPI accessible location and reads the values using <em><a class="el" href="ch__driver_8h.html#a9638c4040534fca4c03b23128a61caa6" title="Copy OTP memory contents.">chdrv_otpmem_copy()</a></em>. It then examines the contents to set various tracking values (sensor type, ID string, etc.).</p>
<p>See also <em><a class="el" href="ch__driver_8h.html#a9638c4040534fca4c03b23128a61caa6" title="Copy OTP memory contents.">chdrv_otpmem_copy()</a></em>, <em><a class="el" href="ch__api_8c.html#a76945903073c49706d025c7679b07059" title="Get the unique Sensor ID String for a sensor.">ch_get_sensor_id()</a></em>, <em><a class="el" href="ch__api_8c.html#a0894c6a31cecc608ab6c457f918abe09" title="Get manufacturing information for a sensor.">ch_get_mfg_info()</a></em> </p>

</div>
</div>
<a id="abe45d0fa08f49bb074d682d61eae3a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe45d0fa08f49bb074d682d61eae3a2c">&#9670;&nbsp;</a></span>chdrv_pretrigger_delay_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_pretrigger_delay_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delay_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the pre-trigger delay for rx-only sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors </td></tr>
    <tr><td class="paramname">delay_us</td><td>time to delay between triggering rx-only and tx/rx nodes, in microseconds</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets a delay interval that will be inserted between triggering rx-only sensors and tx/rx sensors. This delay allows the rx-only sensor(s) to settle from any startup disruption (e.g. PMUT "ringdown") before the ultrasound pulse is generated by the tx node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors </td></tr>
    <tr><td class="paramname">delay_us</td><td>time to delay between triggering rx-only and tx/rx nodes, in microseconds</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets a delay interval that will be inserted between triggering rx-only sensor and tx/rx sensors. This delay allows the rx-only sensor(s) to settle from any startup disruption (e.g. PMUT "ringdown") before the ultrasound pulse is generated by the tx node. </p>

</div>
</div>
<a id="a1f733653cb68d04027d0b584390c3489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f733653cb68d04027d0b584390c3489">&#9670;&nbsp;</a></span>chdrv_prog_i2c_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_prog_i2c_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from a CHx01 device in programming mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">message</td><td>pointer to a buffer where read bytes will be placed </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function reads bytes from the device using the programming I2C address. The PROG line for the device must have been asserted before this function is called.</p>
<p>Read bytes from a CHx01 device in programming mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">message</td><td>pointer to a buffer where read bytes will be placed </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function reads bytes from the device using the programming I2C address. The PROG line for the device must have been asserted before this function is called. </p>

</div>
</div>
<a id="abbcc9cf511218786c38e470f324c8ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcc9cf511218786c38e470f324c8ea1">&#9670;&nbsp;</a></span>chdrv_prog_i2c_read_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_prog_i2c_read_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from a CHx01 device in programming mode, non-blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">message</td><td>pointer to a buffer where read bytes will be placed </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function temporarily changes the device I2C address to the low-level programming interface, and issues a non-blocking read request. The PROG line for the device must have been asserted before this function is called.</p>
<p>Read bytes from a CHx01 device in programming mode, non-blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">message</td><td>pointer to a buffer where read bytes will be placed </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function temporarily changes the device I2C address to the low-level programming interface, and issues a non-blocking read request. The PROG line for the device must have been asserted before this function is called. </p>

</div>
</div>
<a id="af2eb401431b1de7dd57f7943b055ae79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2eb401431b1de7dd57f7943b055ae79">&#9670;&nbsp;</a></span>chdrv_prog_i2c_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_prog_i2c_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes to a CHx01 device in programming mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">message</td><td>pointer to a buffer containing the bytes to write </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function writes bytes to the device using the programming I2C address. The PROG line for the device must have been asserted before this function is called.</p>
<p>Write bytes to a CHx01 device in programming mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">message</td><td>pointer to a buffer containing the bytes to write </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function writes bytes to the device using the programming I2C address. The PROG line for the device must have been asserted before this function is called. </p>

</div>
</div>
<a id="a733216ad3603716b4fe86a3877e4ae48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733216ad3603716b4fe86a3877e4ae48">&#9670;&nbsp;</a></span>chdrv_prog_mem_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_prog_mem_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to CHx01 sensor memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">addr</td><td>sensor programming register start address </td></tr>
    <tr><td class="paramname">message</td><td>pointer to data to transmit </td></tr>
    <tr><td class="paramname">nbytes</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if write to sensor succeeded, non-zero otherwise</dd></dl>
<p>This function writes to sensor memory using the low-level programming interface. The type of write is automatically determined based on data length and target address alignment.</p>
<p>Write to CHx01 sensor memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">addr</td><td>sensor programming register start address </td></tr>
    <tr><td class="paramname">message</td><td>pointer to data to transmit </td></tr>
    <tr><td class="paramname">nbytes</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if write to sensor succeeded, non-zero otherwise</dd></dl>
<p>This function writes to sensor memory using the low-level programming interface. The type of write is automatically determined based on data length and target address alignment. </p>

</div>
</div>
<a id="a405a865671417df936af2c6ba44337c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405a865671417df936af2c6ba44337c3">&#9670;&nbsp;</a></span>chdrv_prog_ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_prog_ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect a connected sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if sensor is found, 0 if no sensor is found</dd></dl>
<p>This function checks for a sensor on the I2C bus by attempting to reset, halt, and read from the device using the programming interface I2C address (0x45).</p>
<p>In order for the device to respond, the PROG pin for the device must be asserted before this function is called. If there are multiple sensors in an application, only one device's PROG pin should be active at any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if sensor is found, 0 if no sensor is found</dd></dl>
<p>This function checks for a sensor sensor on the I2C bus by attempting to reset, halt, and read from the device using the programming interface I2C address (0x45).</p>
<p>In order for the device to respond, the PROG pin for the device must be asserted before this function is called. </p>

</div>
</div>
<a id="a6ceb695e4b6b6979bba4b2d485dd1935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ceb695e4b6b6979bba4b2d485dd1935">&#9670;&nbsp;</a></span>chdrv_prog_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_prog_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to a CHx01 programming register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">reg_addr</td><td>sensor programming register address. </td></tr>
    <tr><td class="paramname">data</td><td>8-bit or 16-bit data to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if write to sensor succeeded, non-zero otherwise</dd></dl>
<p>This function writes a value to a sensor programming register.</p>
<p>Write to a CHx01 programming register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">reg_addr</td><td>sensor programming register address. </td></tr>
    <tr><td class="paramname">data</td><td>8-bit or 16-bit data to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if write to sensor succeeded, non-zero otherwise</dd></dl>
<p>This local function writes a value to a sensor programming register. </p>

</div>
</div>
<a id="a388813ed8eaf01de8e17401f3d565973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388813ed8eaf01de8e17401f3d565973">&#9670;&nbsp;</a></span>chdrv_read_buf_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_read_buf_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the IQ buffer address from the sensor and store in dev_ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise </dd></dl>

</div>
</div>
<a id="aa63ea7f93bc9f4a468b119a97b3b02df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63ea7f93bc9f4a468b119a97b3b02df">&#9670;&nbsp;</a></span>chdrv_read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_read_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read byte from a sensor application register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">mem_addr</td><td>sensor memory/register address </td></tr>
    <tr><td class="paramname">data</td><td>pointer to receive buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">mem_addr</td><td>sensor memory/register address </td></tr>
    <tr><td class="paramname">data_ptr</td><td>pointer to receive buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise </dd></dl>

</div>
</div>
<a id="ada67defc2806336af483ee207d927a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada67defc2806336af483ee207d927a3c">&#9670;&nbsp;</a></span>chdrv_read_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_read_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 16 bits from a sensor application register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">mem_addr</td><td>sensor memory/register address </td></tr>
    <tr><td class="paramname">data</td><td>pointer to receive buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">mem_addr</td><td>sensor memory/register address </td></tr>
    <tr><td class="paramname">data_ptr</td><td>pointer to receive buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise </dd></dl>

</div>
</div>
<a id="a8b38b3e25bdee314ff1692fcb9477775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b38b3e25bdee314ff1692fcb9477775">&#9670;&nbsp;</a></span>chdrv_restart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_restart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function restarts a single sensor, using previously stored initialization values. </p>

</div>
</div>
<a id="a84facb2b2a58d769f1ffd8270c398340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84facb2b2a58d769f1ffd8270c398340">&#9670;&nbsp;</a></span>chdrv_round_trip_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t chdrv_round_trip_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tof_sf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the sensor register values to a round-trip range using the calibration data in the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">tof</td><td>value of TOF register </td></tr>
    <tr><td class="paramname">tof_sf</td><td>value of TOF_SF register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range in millimeters, or <em>CH_NO_TARGET</em> (0xFFFFFFFF) if no object is detected. The range result format is fixed point with 5 binary fractional digits (divide by 32 to convert to mm).</dd></dl>
<p>This function takes the time-of-flight and scale factor values from the sensor, and computes the actual round-trip range based on the formulas given in the sensor datasheet. </p>

</div>
</div>
<a id="ade1a1019ba79ce882b5eb5145ff1e4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1a1019ba79ce882b5eb5145ff1e4f8">&#9670;&nbsp;</a></span>chdrv_run_bist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_run_bist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run built-in self test (BIST) on sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, non-zero if error</dd></dl>
<p>This function initiates the build-in self test (BIST) on a sensor.</p>
<p>Run built-in self test (BIST) on sensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> device descriptor for a sensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28642d48731b4e3671d7ca9ade203655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28642d48731b4e3671d7ca9ade203655">&#9670;&nbsp;</a></span>chdrv_set_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_set_idle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put CHx01 sensor(s) in idle state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function places the sensor processor in a known state by loading an idle loop instruction sequence. This is used only during early initialization of the device. This is NOT the same as putting a running device into "idle mode" (CH_MODE_IDLE) by using the <em><a class="el" href="ch__api_8c.html#af427c34df885a028ee0f7cdddc981001" title="Configure a sensor for the specified operating mode.">ch_set_mode()</a></em> function.</p>
<p>Put CHx01 sensor(s) in idle state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor, used to identify the target I2C bus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero on error</dd></dl>
<p>This function loads a tiny idle loop program to all ASICs on a given i2c bus. This function assumes that all of the devices on the given bus are halted in programming mode (i.e. PROG line is asserted).</p>
<dl class="section note"><dt>Note</dt><dd>This routine writes to all devices simultaneously, so I2C signalling (i.e. ack's) on the bus may be driven by multiple slaves at once. </dd></dl>

</div>
</div>
<a id="ab80b197a070c298b5890fe9aba4263f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80b197a070c298b5890fe9aba4263f2">&#9670;&nbsp;</a></span>chdrv_soft_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_soft_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a soft reset on a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">mem_addr</td><td>sensor memory/register address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function performs a soft reset on an individual sensor by writing to a special control register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function performs a soft reset on an individual sensor by writing to a special control register. </p>

</div>
</div>
<a id="aea6c78fa9f5201f1d075af591b6f46bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6c78fa9f5201f1d075af591b6f46bc">&#9670;&nbsp;</a></span>chdrv_sys_ctrl_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_sys_ctrl_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>reg_value_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the system control register from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">reg_value_ptr</td><td>pointer to location to receive register value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if register read succeeded, non-zero otherwise</dd></dl>
<p>This function reads the system control register from an ICU sensor and returns the value in the location specified by <em>reg_value_ptr</em>. </p>

</div>
</div>
<a id="a96cea354c8635b2966fae3d29b7369be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cea354c8635b2966fae3d29b7369be">&#9670;&nbsp;</a></span>chdrv_sys_ctrl_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chdrv_sys_ctrl_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the system control register in a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">reg_value</td><td>register value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if register write succeeded, non-zero otherwise</dd></dl>
<p>This function writes <em>reg_value</em> to the system control register in an ICU sensor.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if register write succeeded, non-zero otherwise </dd></dl>

</div>
</div>
<a id="a6f8f74c8a25453be98107dfd79f79708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8f74c8a25453be98107dfd79f79708">&#9670;&nbsp;</a></span>chdrv_trig_assert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_trig_assert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert the hardware trigger line for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<p>This function asserts the specified sensor's h/w trigger line to initiate a measurement. For ICU sensors, the line indicated by the current measurement configuration for trigger pin (INT1 or INT2) will be set to a low (active) level. For CH101/CH201 sensors, the single INT line will be set to a high level.</p>
<p>This function calls the appropriate routine(s) in the the board support package to manipulate the line levels.</p>
<p>See also <em>chdrv_group_trig_assert()</em>, <em><a class="el" href="ch__driver_8h.html#afc765a2d807b342663885146ee42ab36" title="De-assert the hardware trigger line for a sensor.">chdrv_trig_deassert()</a></em> </p>

</div>
</div>
<a id="afc765a2d807b342663885146ee42ab36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc765a2d807b342663885146ee42ab36">&#9670;&nbsp;</a></span>chdrv_trig_deassert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_trig_deassert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-assert the hardware trigger line for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<p>This function de-asserts the specified sensor's h/w trigger line used to initiate a measurement. For ICU sensors, the line indicated by the current measurement configuration for trigger pin (INT1 or INT2) will be reset to a high (inactive) level. For CH101/CH201 sensors, the single INT line will be reset to a low level.</p>
<p>This function calls the appropriate routine(s) in the the board support package to manipulate the line levels.</p>
<p>See also <em>chdrv_group_trig_assert()</em>, <em><a class="el" href="ch__driver_8h.html#a6f8f74c8a25453be98107dfd79f79708" title="Assert the hardware trigger line for a sensor.">chdrv_trig_assert()</a></em> </p>

</div>
</div>
<a id="a92499dcecad1de83c11c294f51d019cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92499dcecad1de83c11c294f51d019cc">&#9670;&nbsp;</a></span>chdrv_trig_group_assert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_trig_group_assert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert the hardware trigger lines for all sensors in a group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function asserts the h/w trigger lines for all sensors in a group to initiate a measurement. For ICU sensors, the line indicated by the current measurement configuration for trigger pin (INT1 or INT2) will be set to a low (active) level. For CH101/CH201 sensors, the sensors' INT lines will be set to a high level.</p>
<p>This function calls the appropriate routine(s) in the the board support package to manipulate the line levels.</p>
<p>See also <em><a class="el" href="ch__driver_8h.html#a6f8f74c8a25453be98107dfd79f79708" title="Assert the hardware trigger line for a sensor.">chdrv_trig_assert()</a></em>, <em><a class="el" href="ch__driver_8h.html#abbf1c16036d133563467f06b7b5062e2" title="De-assert the hardware trigger lines for all sensors in a group.">chdrv_trig_group_deassert()</a></em> </p>

</div>
</div>
<a id="abbf1c16036d133563467f06b7b5062e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf1c16036d133563467f06b7b5062e2">&#9670;&nbsp;</a></span>chdrv_trig_group_deassert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_trig_group_deassert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-assert the hardware trigger lines for all sensors in a group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function de-asserts the h/w trigger lines for all sensors in a group. For ICU sensors, the lines indicated by the current measurement configuration for trigger pin (INT1 or INT2) will be reset to a high (inactive) level. For CH101/CH201 sensors, the sensors' INT lines will be reset to a low level.</p>
<p>This function calls the appropriate routine(s) in the the board support package to manipulate the line levels.</p>
<p>See also <em><a class="el" href="ch__driver_8h.html#afc765a2d807b342663885146ee42ab36" title="De-assert the hardware trigger line for a sensor.">chdrv_trig_deassert()</a></em>, <em><a class="el" href="ch__driver_8h.html#a92499dcecad1de83c11c294f51d019cc" title="Assert the hardware trigger lines for all sensors in a group.">chdrv_trig_group_assert()</a></em> </p>

</div>
</div>
<a id="ad7d1cb524f6276eeae7ce46caf489932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d1cb524f6276eeae7ce46caf489932">&#9670;&nbsp;</a></span>chdrv_trig_group_set_dir_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_trig_group_set_dir_out </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the hardware trigger lines for all sensors in a group as outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the h/w trigger lines for all sensors in a group as output pins. For ICU sensors, the current measurement configuration for trigger pin (INT1 or INT2) is used. For CH101/CH201 sensors, the single INT line is used.</p>
<p>This function calls the appropriate routine(s) in the the board support package to set the pin direction. </p>

</div>
</div>
<a id="a6f982f7bee02ab91d1f6d09e2fd8c13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f982f7bee02ab91d1f6d09e2fd8c13c">&#9670;&nbsp;</a></span>chdrv_trig_set_dir_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chdrv_trig_set_dir_out </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the hardware trigger line for a sensor as an output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the specified sensor's h/w trigger line an an output pin. For ICU sensors, the current measurement configuration for trigger pin (INT1 or INT2) is used. For CH101/CH201 sensors, the single INT line is used.</p>
<p>This function calls the appropriate routine(s) in the the board support package to set the pin direction. </p>

</div>
</div>
<a id="ac453b83c7c8197be1e5caea164086cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac453b83c7c8197be1e5caea164086cf4">&#9670;&nbsp;</a></span>chdrv_wait_for_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_wait_for_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for an individual sensor to finish start-up procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>number of milliseconds to wait for sensor to finish start-up before returning failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if startup sequence finished, non-zero if startup sequence timed out or sensor is not connected</dd></dl>
<p>After the sensor is programmed, it executes an internal start-up and self-test sequence. This function waits the specified time in milliseconds for the sensor to finish this sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>number of milliseconds to wait for sensor to finish start-up before returning failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if startup sequence finished, non-zero if startup sequence timed out or sensor is not connected</dd></dl>
<p>After the sensor is programmed, it executes an internal start-up and self-test sequence. This function waits the specified time in milliseconds for the sensor to finish this sequence. </p>

</div>
</div>
<a id="a8f710a85393015065e787f0e28a8392d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f710a85393015065e787f0e28a8392d">&#9670;&nbsp;</a></span>chdrv_write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_write_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write byte to a sensor application register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">reg_addr</td><td>register address </td></tr>
    <tr><td class="paramname">data</td><td>data value to transmit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">mem_addr</td><td>sensor memory/register address </td></tr>
    <tr><td class="paramname">data_value</td><td>data value to transmit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise </dd></dl>

</div>
</div>
<a id="a843af52db125cb64cccca7dd454a8ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843af52db125cb64cccca7dd454a8ec7">&#9670;&nbsp;</a></span>chdrv_write_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chdrv_write_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 16 bits to a sensor application register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure for a sensor </td></tr>
    <tr><td class="paramname">mem_addr</td><td>sensor memory/register address </td></tr>
    <tr><td class="paramname">data</td><td>data value to transmit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor </td></tr>
    <tr><td class="paramname">reg_addr</td><td>sensor register address </td></tr>
    <tr><td class="paramname">data_value</td><td>data value to transmit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
