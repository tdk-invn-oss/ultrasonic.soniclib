<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chirp SonicLib: invn/soniclib/ch_api.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Chirp SonicLib
   &#160;<span id="projectnumber">4.4.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_e2bc8ccdb587e3c3e16dcbd6fd126654.html">invn</a></li><li class="navelem"><a class="el" href="dir_0ccdbf2c279b53b38c827faf1754ce51.html">soniclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ch_api.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Chirp SonicLib public API functions for using the Chirp ultrasonic sensor.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;<a class="el" href="soniclib_8h_source.html">invn/soniclib/soniclib.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="ch__common_8h_source.html">invn/soniclib/details/ch_common.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="ch__driver_8h_source.html">invn/soniclib/details/ch_driver.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="chirp__bsp_8h_source.html">invn/soniclib/chirp_bsp.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="ch__log_8h_source.html">invn/soniclib/ch_log.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="ch__math__utils_8h_source.html">invn/soniclib/details/ch_math_utils.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0705078371bc0ec34bd112b9a8ab1ebe"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a0705078371bc0ec34bd112b9a8ab1ebe">ch_check_program</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a0705078371bc0ec34bd112b9a8ab1ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check sensor firmware program.  <a href="ch__api_8c.html#a0705078371bc0ec34bd112b9a8ab1ebe">More...</a><br /></td></tr>
<tr class="separator:a0705078371bc0ec34bd112b9a8ab1ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a659b8b3969c202074c09bfb54ee9b7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a1a659b8b3969c202074c09bfb54ee9b7">ch_check_reset_state</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a8579cbcd7ce6352dcb003317568123c9">ch_sensor_reset_state_t</a> *reset_state_ptr)</td></tr>
<tr class="memdesc:a1a659b8b3969c202074c09bfb54ee9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if sensor reset has occurred.  <a href="ch__api_8c.html#a1a659b8b3969c202074c09bfb54ee9b7">More...</a><br /></td></tr>
<tr class="separator:a1a659b8b3969c202074c09bfb54ee9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb8ea1621ef563bf279d7fedd1f16ef"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a9bb8ea1621ef563bf279d7fedd1f16ef">ch_cycles_to_samples</a> (uint32_t num_cycles, <a class="el" href="soniclib_8h.html#a86140657375a7e7c24ecf430da97c189">ch_odr_t</a> odr)</td></tr>
<tr class="memdesc:a9bb8ea1621ef563bf279d7fedd1f16ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert sensor cycles to samples.  <a href="ch__api_8c.html#a9bb8ea1621ef563bf279d7fedd1f16ef">More...</a><br /></td></tr>
<tr class="separator:a9bb8ea1621ef563bf279d7fedd1f16ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde0dc4f438051bd4fcfd19aad8b3f9c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#acde0dc4f438051bd4fcfd19aad8b3f9c">ch_cycles_to_usec</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint32_t num_cycles)</td></tr>
<tr class="memdesc:acde0dc4f438051bd4fcfd19aad8b3f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert sensor cycles to microseconds.  <a href="ch__api_8c.html#acde0dc4f438051bd4fcfd19aad8b3f9c">More...</a><br /></td></tr>
<tr class="separator:acde0dc4f438051bd4fcfd19aad8b3f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c0409b1443384afe601b8098aec6ef"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a87c0409b1443384afe601b8098aec6ef">ch_enable_double_buffer</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t enable)</td></tr>
<tr class="memdesc:a87c0409b1443384afe601b8098aec6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the double buffering mode.  <a href="ch__api_8c.html#a87c0409b1443384afe601b8098aec6ef">More...</a><br /></td></tr>
<tr class="separator:a87c0409b1443384afe601b8098aec6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc64b2a0305210e1394331a6b2dd734"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a0bc64b2a0305210e1394331a6b2dd734">ch_enable_metadata_in_iq0</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t enable)</td></tr>
<tr class="memdesc:a0bc64b2a0305210e1394331a6b2dd734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable placing metadata in the first IQ sample.  <a href="ch__api_8c.html#a0bc64b2a0305210e1394331a6b2dd734">More...</a><br /></td></tr>
<tr class="separator:a0bc64b2a0305210e1394331a6b2dd734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe624d21c6e4c116469570a5b46f70f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a3fe624d21c6e4c116469570a5b46f70f">ch_freerun_time_hop_disable</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a3fe624d21c6e4c116469570a5b46f70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable time-hopping on measure period freerunning mode.  <a href="ch__api_8c.html#a3fe624d21c6e4c116469570a5b46f70f">More...</a><br /></td></tr>
<tr class="separator:a3fe624d21c6e4c116469570a5b46f70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1698edd099e87aaa2787cda5f12e373f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a1698edd099e87aaa2787cda5f12e373f">ch_freerun_time_hop_enable</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a1698edd099e87aaa2787cda5f12e373f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable time-hopping on measure period freerunning mode.  <a href="ch__api_8c.html#a1698edd099e87aaa2787cda5f12e373f">More...</a><br /></td></tr>
<tr class="separator:a1698edd099e87aaa2787cda5f12e373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05e1055eb673ae1c6e03d8d72046039"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ac05e1055eb673ae1c6e03d8d72046039">ch_get_algo_config</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, void *algo_cfg_ptr)</td></tr>
<tr class="memdesc:ac05e1055eb673ae1c6e03d8d72046039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the measurement algorithm configuration data from a sensor.  <a href="ch__api_8c.html#ac05e1055eb673ae1c6e03d8d72046039">More...</a><br /></td></tr>
<tr class="separator:ac05e1055eb673ae1c6e03d8d72046039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8e425d463961d442133253235c5a41"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a1e8e425d463961d442133253235c5a41">ch_get_algo_info</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structicu__algo__info.html">ICU_ALGO_SHASTA_INFO</a> *algo_info_ptr)</td></tr>
<tr class="memdesc:a1e8e425d463961d442133253235c5a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the measurement algorithm information data from a sensor.  <a href="ch__api_8c.html#a1e8e425d463961d442133253235c5a41">More...</a><br /></td></tr>
<tr class="separator:a1e8e425d463961d442133253235c5a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e276c66c4a835c1146135580d7d5c7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a40e276c66c4a835c1146135580d7d5c7">ch_get_algo_output</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, void *algo_out_ptr)</td></tr>
<tr class="memdesc:a40e276c66c4a835c1146135580d7d5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the measurement algorithm output data from a sensor.  <a href="ch__api_8c.html#a40e276c66c4a835c1146135580d7d5c7">More...</a><br /></td></tr>
<tr class="separator:a40e276c66c4a835c1146135580d7d5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe62802f4bc1c41bc96d903e3aa323c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#abfe62802f4bc1c41bc96d903e3aa323c">ch_get_algo_state</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, void *algo_state_ptr)</td></tr>
<tr class="memdesc:abfe62802f4bc1c41bc96d903e3aa323c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the measurement algorithm state data from a sensor.  <a href="ch__api_8c.html#abfe62802f4bc1c41bc96d903e3aa323c">More...</a><br /></td></tr>
<tr class="separator:abfe62802f4bc1c41bc96d903e3aa323c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45d31a610fa2b44fd72d0eb726f7ad0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ae45d31a610fa2b44fd72d0eb726f7ad0">ch_get_amp_thresh_data</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__amp__thresh__t.html">ch_amp_thresh_t</a> *buf_ptr, uint16_t start_sample, uint16_t num_samples, <a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a> mode)</td></tr>
<tr class="memdesc:ae45d31a610fa2b44fd72d0eb726f7ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amplitude measurement and threshold data from a sensor.  <a href="ch__api_8c.html#ae45d31a610fa2b44fd72d0eb726f7ad0">More...</a><br /></td></tr>
<tr class="separator:ae45d31a610fa2b44fd72d0eb726f7ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ef517f154bb269d31fdf3f4e0cc7a2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aa2ef517f154bb269d31fdf3f4e0cc7a2">ch_get_amplitude</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:aa2ef517f154bb269d31fdf3f4e0cc7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the measured amplitude from a sensor.  <a href="ch__api_8c.html#aa2ef517f154bb269d31fdf3f4e0cc7a2">More...</a><br /></td></tr>
<tr class="separator:aa2ef517f154bb269d31fdf3f4e0cc7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd6ee85a061f71da4e98aab683fef5b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aecd6ee85a061f71da4e98aab683fef5b">ch_get_amplitude_avg</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:aecd6ee85a061f71da4e98aab683fef5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the averaged measured amplitude over the sample window.  <a href="ch__api_8c.html#aecd6ee85a061f71da4e98aab683fef5b">More...</a><br /></td></tr>
<tr class="separator:aecd6ee85a061f71da4e98aab683fef5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f162a8dfb083614d26fc141561c0bba"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a7f162a8dfb083614d26fc141561c0bba">ch_get_amplitude_data</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t *amp_buf_ptr, uint16_t start_sample, uint16_t num_samples, <a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a> mode)</td></tr>
<tr class="memdesc:a7f162a8dfb083614d26fc141561c0bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw amplitude measurement data from a sensor.  <a href="ch__api_8c.html#a7f162a8dfb083614d26fc141561c0bba">More...</a><br /></td></tr>
<tr class="separator:a7f162a8dfb083614d26fc141561c0bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6216f922775cbf3c571734e5287d50"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a4d6216f922775cbf3c571734e5287d50">ch_get_bandwidth</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a4d6216f922775cbf3c571734e5287d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bandwidth of a sensor.  <a href="ch__api_8c.html#a4d6216f922775cbf3c571734e5287d50">More...</a><br /></td></tr>
<tr class="separator:a4d6216f922775cbf3c571734e5287d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f7dd209fa4b04a5366147ab4ff67b2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a37f7dd209fa4b04a5366147ab4ff67b2">ch_get_bus</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a37f7dd209fa4b04a5366147ab4ff67b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active SPI/I2C bus for a sensor.  <a href="ch__api_8c.html#a37f7dd209fa4b04a5366147ab4ff67b2">More...</a><br /></td></tr>
<tr class="separator:a37f7dd209fa4b04a5366147ab4ff67b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fd271636e1b3aa3137cd812bd6b19c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a28fd271636e1b3aa3137cd812bd6b19c">ch_get_cal_result</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__cal__result__t.html">ch_cal_result_t</a> *cal_ptr)</td></tr>
<tr class="memdesc:a28fd271636e1b3aa3137cd812bd6b19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the calibration result.  <a href="ch__api_8c.html#a28fd271636e1b3aa3137cd812bd6b19c">More...</a><br /></td></tr>
<tr class="separator:a28fd271636e1b3aa3137cd812bd6b19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2047b5e506b99131585bcfb4ce37b4ac"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a2047b5e506b99131585bcfb4ce37b4ac">ch_get_config</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__config__t.html">ch_config_t</a> *config_ptr)</td></tr>
<tr class="memdesc:a2047b5e506b99131585bcfb4ce37b4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current configuration settings for a sensor.  <a href="ch__api_8c.html#a2047b5e506b99131585bcfb4ce37b4ac">More...</a><br /></td></tr>
<tr class="separator:a2047b5e506b99131585bcfb4ce37b4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7747e4f758aa7d957d3e69a94ced2363"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a7747e4f758aa7d957d3e69a94ced2363">ch_get_cpu_frequency</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a7747e4f758aa7d957d3e69a94ced2363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sensor CPU frequency, in Hz.  <a href="ch__api_8c.html#a7747e4f758aa7d957d3e69a94ced2363">More...</a><br /></td></tr>
<tr class="separator:a7747e4f758aa7d957d3e69a94ced2363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf8233ee597b2795c3e478e70f3aefd"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aacf8233ee597b2795c3e478e70f3aefd">ch_get_data_ready_delay</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:aacf8233ee597b2795c3e478e70f3aefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data ready interrupt delay interval.  <a href="ch__api_8c.html#aacf8233ee597b2795c3e478e70f3aefd">More...</a><br /></td></tr>
<tr class="separator:aacf8233ee597b2795c3e478e70f3aefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775e8fcdd9f1c1fa3dd90d87024101ab"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a775e8fcdd9f1c1fa3dd90d87024101ab">ch_get_dev_num</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a775e8fcdd9f1c1fa3dd90d87024101ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device number (I/O index values) for a sensor.  <a href="ch__api_8c.html#a775e8fcdd9f1c1fa3dd90d87024101ab">More...</a><br /></td></tr>
<tr class="separator:a775e8fcdd9f1c1fa3dd90d87024101ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703c36ef2e38b7f9274c8e05a5109d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a703c36ef2e38b7f9274c8e05a5109d72">ch_get_dev_ptr</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t dev_num)</td></tr>
<tr class="memdesc:a703c36ef2e38b7f9274c8e05a5109d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device descriptor pointer for a sensor.  <a href="ch__api_8c.html#a703c36ef2e38b7f9274c8e05a5109d72">More...</a><br /></td></tr>
<tr class="separator:a703c36ef2e38b7f9274c8e05a5109d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5c83e0d155e17ab8ac74951f44ea02"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a2f5c83e0d155e17ab8ac74951f44ea02">ch_get_freerun_interval</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a2f5c83e0d155e17ab8ac74951f44ea02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal sensing timing interval for a sensor, in milliseconds.  <a href="ch__api_8c.html#a2f5c83e0d155e17ab8ac74951f44ea02">More...</a><br /></td></tr>
<tr class="separator:a2f5c83e0d155e17ab8ac74951f44ea02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6ab6e5862a95c8610a176bf3e88554"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aaa6ab6e5862a95c8610a176bf3e88554">ch_get_freerun_interval_ticks</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:aaa6ab6e5862a95c8610a176bf3e88554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal sensing timing interval for a sensor, in RTC clock ticks.  <a href="ch__api_8c.html#aaa6ab6e5862a95c8610a176bf3e88554">More...</a><br /></td></tr>
<tr class="separator:aaa6ab6e5862a95c8610a176bf3e88554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c77bb8b753ccc41de9b11f316e9c7e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a94c77bb8b753ccc41de9b11f316e9c7e">ch_get_freerun_interval_us</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a94c77bb8b753ccc41de9b11f316e9c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal sensing timing interval for a sensor, in microseconds.  <a href="ch__api_8c.html#a94c77bb8b753ccc41de9b11f316e9c7e">More...</a><br /></td></tr>
<tr class="separator:a94c77bb8b753ccc41de9b11f316e9c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae60d24c0b1d0fb5f06e2449c0fa149"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a7ae60d24c0b1d0fb5f06e2449c0fa149">ch_get_frequency</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a7ae60d24c0b1d0fb5f06e2449c0fa149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the operating frequency of a sensor.  <a href="ch__api_8c.html#a7ae60d24c0b1d0fb5f06e2449c0fa149">More...</a><br /></td></tr>
<tr class="separator:a7ae60d24c0b1d0fb5f06e2449c0fa149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a2126fda5645c1be134c2187cac61f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ac4a2126fda5645c1be134c2187cac61f">ch_get_fw_version_string</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ac4a2126fda5645c1be134c2187cac61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the firmware version description string for a sensor.  <a href="ch__api_8c.html#ac4a2126fda5645c1be134c2187cac61f">More...</a><br /></td></tr>
<tr class="separator:ac4a2126fda5645c1be134c2187cac61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5496937b5fae4e2c04ff2fa23ed9fbf"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ab5496937b5fae4e2c04ff2fa23ed9fbf">ch_get_i2c_address</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ab5496937b5fae4e2c04ff2fa23ed9fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active I2C address for a sensor.  <a href="ch__api_8c.html#ab5496937b5fae4e2c04ff2fa23ed9fbf">More...</a><br /></td></tr>
<tr class="separator:ab5496937b5fae4e2c04ff2fa23ed9fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3b587cdcbe5917de925f5b8fa47888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="soniclib_8h.html#a3406ad6d96900bf23674fc44468caf5d">ch_interrupt_drive_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a0b3b587cdcbe5917de925f5b8fa47888">ch_get_interrupt_drive</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a0b3b587cdcbe5917de925f5b8fa47888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pulse interrupt drive setting.  <a href="ch__api_8c.html#a0b3b587cdcbe5917de925f5b8fa47888">More...</a><br /></td></tr>
<tr class="separator:a0b3b587cdcbe5917de925f5b8fa47888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3692aeb8fee72b3cc2825547261b1777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="soniclib_8h.html#a4962ca7e356fbfa6e40863fe5abf519c">ch_interrupt_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a3692aeb8fee72b3cc2825547261b1777">ch_get_interrupt_mode</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a3692aeb8fee72b3cc2825547261b1777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pulse interrupt mode setting.  <a href="ch__api_8c.html#a3692aeb8fee72b3cc2825547261b1777">More...</a><br /></td></tr>
<tr class="separator:a3692aeb8fee72b3cc2825547261b1777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde1c47209421107f576b7e01b6fa5e8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#acde1c47209421107f576b7e01b6fa5e8">ch_get_iq_data</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a> *buf_ptr, uint16_t start_sample, uint16_t num_samples, <a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a> mode)</td></tr>
<tr class="memdesc:acde1c47209421107f576b7e01b6fa5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw I/Q measurement data from a sensor.  <a href="ch__api_8c.html#acde1c47209421107f576b7e01b6fa5e8">More...</a><br /></td></tr>
<tr class="separator:acde1c47209421107f576b7e01b6fa5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b6bb2df00b9feb43955902c55835f7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a96b6bb2df00b9feb43955902c55835f7">ch_get_max_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a96b6bb2df00b9feb43955902c55835f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum range setting in mm for a sensor.  <a href="ch__api_8c.html#a96b6bb2df00b9feb43955902c55835f7">More...</a><br /></td></tr>
<tr class="separator:a96b6bb2df00b9feb43955902c55835f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb50e63f45eee386a19cd9ef12c8de6"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a7eb50e63f45eee386a19cd9ef12c8de6">ch_get_max_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a7eb50e63f45eee386a19cd9ef12c8de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum possible sample count per measurement.  <a href="ch__api_8c.html#a7eb50e63f45eee386a19cd9ef12c8de6">More...</a><br /></td></tr>
<tr class="separator:a7eb50e63f45eee386a19cd9ef12c8de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0894c6a31cecc608ab6c457f918abe09"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a0894c6a31cecc608ab6c457f918abe09">ch_get_mfg_info</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__mfg__info__t.html">ch_mfg_info_t</a> *info_ptr)</td></tr>
<tr class="memdesc:a0894c6a31cecc608ab6c457f918abe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get manufacturing information for a sensor.  <a href="ch__api_8c.html#a0894c6a31cecc608ab6c457f918abe09">More...</a><br /></td></tr>
<tr class="separator:a0894c6a31cecc608ab6c457f918abe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd52987d0cfca5d0dec4f962ce15995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">ch_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#acbd52987d0cfca5d0dec4f962ce15995">ch_get_mode</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:acbd52987d0cfca5d0dec4f962ce15995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current operating mode for a sensor.  <a href="ch__api_8c.html#acbd52987d0cfca5d0dec4f962ce15995">More...</a><br /></td></tr>
<tr class="separator:acbd52987d0cfca5d0dec4f962ce15995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd0582578cba1dff9d781a4ce516e84"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a2fd0582578cba1dff9d781a4ce516e84">ch_get_next_buf_addr</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a2fd0582578cba1dff9d781a4ce516e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of the IQ buffer that will be written by the next measurement.  <a href="ch__api_8c.html#a2fd0582578cba1dff9d781a4ce516e84">More...</a><br /></td></tr>
<tr class="separator:a2fd0582578cba1dff9d781a4ce516e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2806d7b51748c5dcd870d7c3c21b222a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a2806d7b51748c5dcd870d7c3c21b222a">ch_get_num_output_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a2806d7b51748c5dcd870d7c3c21b222a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid output samples in last measurement.  <a href="ch__api_8c.html#a2806d7b51748c5dcd870d7c3c21b222a">More...</a><br /></td></tr>
<tr class="separator:a2806d7b51748c5dcd870d7c3c21b222a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a95de2412e067451248211003e1240"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ae0a95de2412e067451248211003e1240">ch_get_num_ports</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:ae0a95de2412e067451248211003e1240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of sensor ports (possible sensors) in a sensor group.  <a href="ch__api_8c.html#ae0a95de2412e067451248211003e1240">More...</a><br /></td></tr>
<tr class="separator:ae0a95de2412e067451248211003e1240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cba94e769a33dfd290555efb412dda"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a53cba94e769a33dfd290555efb412dda">ch_get_num_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a53cba94e769a33dfd290555efb412dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of samples per measurement cycle.  <a href="ch__api_8c.html#a53cba94e769a33dfd290555efb412dda">More...</a><br /></td></tr>
<tr class="separator:a53cba94e769a33dfd290555efb412dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57e731b7b145a37aa7685a2fbe320c9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ad57e731b7b145a37aa7685a2fbe320c9">ch_get_part_number</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ad57e731b7b145a37aa7685a2fbe320c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part number for a sensor.  <a href="ch__api_8c.html#ad57e731b7b145a37aa7685a2fbe320c9">More...</a><br /></td></tr>
<tr class="separator:ad57e731b7b145a37aa7685a2fbe320c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80da2e1dc19b0f3a40c775b818ead954"><td class="memItemLeft" align="right" valign="top"><a class="el" href="soniclib_8h.html#aca9006600c4c232750578f7ed6c0416e">ch_pmut_clk_cfg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a80da2e1dc19b0f3a40c775b818ead954">ch_get_pmut_clock</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a80da2e1dc19b0f3a40c775b818ead954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ultrasound transducer clock configuration.  <a href="ch__api_8c.html#a80da2e1dc19b0f3a40c775b818ead954">More...</a><br /></td></tr>
<tr class="separator:a80da2e1dc19b0f3a40c775b818ead954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbb4847d39cc9418373b6d1ac8dadc6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a5cbb4847d39cc9418373b6d1ac8dadc6">ch_get_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a1b137d77afad79d536e322eacdfebd0c">ch_range_t</a> range_type)</td></tr>
<tr class="memdesc:a5cbb4847d39cc9418373b6d1ac8dadc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the measured range from a sensor.  <a href="ch__api_8c.html#a5cbb4847d39cc9418373b6d1ac8dadc6">More...</a><br /></td></tr>
<tr class="separator:a5cbb4847d39cc9418373b6d1ac8dadc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1629cdf88732e9e3d4bfbe422900220"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#af1629cdf88732e9e3d4bfbe422900220">ch_get_rtc_cal_pulselength</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:af1629cdf88732e9e3d4bfbe422900220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real-time clock calibration pulse length.  <a href="ch__api_8c.html#af1629cdf88732e9e3d4bfbe422900220">More...</a><br /></td></tr>
<tr class="separator:af1629cdf88732e9e3d4bfbe422900220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa365c564c65b5aa97ca9dca28711807b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aa365c564c65b5aa97ca9dca28711807b">ch_get_rtc_cal_result</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:aa365c564c65b5aa97ca9dca28711807b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real-time clock calibration value.  <a href="ch__api_8c.html#aa365c564c65b5aa97ca9dca28711807b">More...</a><br /></td></tr>
<tr class="separator:aa365c564c65b5aa97ca9dca28711807b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3157748b36bfb84930fd16ab06570eb7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a3157748b36bfb84930fd16ab06570eb7">ch_get_rtc_frequency</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a3157748b36bfb84930fd16ab06570eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sensor real-time clock (RTC) frequency, in Hz.  <a href="ch__api_8c.html#a3157748b36bfb84930fd16ab06570eb7">More...</a><br /></td></tr>
<tr class="separator:a3157748b36bfb84930fd16ab06570eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1379e10c0c9af1f916ca08092916227b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a1379e10c0c9af1f916ca08092916227b">ch_get_rx_low_gain</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a1379e10c0c9af1f916ca08092916227b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the receive low-gain sample count.  <a href="ch__api_8c.html#a1379e10c0c9af1f916ca08092916227b">More...</a><br /></td></tr>
<tr class="separator:a1379e10c0c9af1f916ca08092916227b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295d2393cc610d13bfa63987de35c303"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a295d2393cc610d13bfa63987de35c303">ch_get_rx_pretrigger</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a295d2393cc610d13bfa63987de35c303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get receive-only sensor pre-triggering setting.  <a href="ch__api_8c.html#a295d2393cc610d13bfa63987de35c303">More...</a><br /></td></tr>
<tr class="separator:a295d2393cc610d13bfa63987de35c303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973ae35d4ac7064704da5bcf2d05f6ef"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a973ae35d4ac7064704da5bcf2d05f6ef">ch_get_sample_interval</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a973ae35d4ac7064704da5bcf2d05f6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal sensing timing interval for a sensor (deprecated).  <a href="ch__api_8c.html#a973ae35d4ac7064704da5bcf2d05f6ef">More...</a><br /></td></tr>
<tr class="separator:a973ae35d4ac7064704da5bcf2d05f6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c552c6a09c2400766ee329efcaeaa1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a56c552c6a09c2400766ee329efcaeaa1">ch_get_sample_window</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t *start_sample_ptr, uint16_t *num_samples_ptr)</td></tr>
<tr class="memdesc:a56c552c6a09c2400766ee329efcaeaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sample window for amplitude averaging.  <a href="ch__api_8c.html#a56c552c6a09c2400766ee329efcaeaa1">More...</a><br /></td></tr>
<tr class="separator:a56c552c6a09c2400766ee329efcaeaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88053b2f8918538fc3c2c8681e4269b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ab88053b2f8918538fc3c2c8681e4269b">ch_get_scale_factor</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ab88053b2f8918538fc3c2c8681e4269b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amplitude scale factor of a sensor.  <a href="ch__api_8c.html#ab88053b2f8918538fc3c2c8681e4269b">More...</a><br /></td></tr>
<tr class="separator:ab88053b2f8918538fc3c2c8681e4269b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76945903073c49706d025c7679b07059"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a76945903073c49706d025c7679b07059">ch_get_sensor_id</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a76945903073c49706d025c7679b07059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique Sensor ID String for a sensor.  <a href="ch__api_8c.html#a76945903073c49706d025c7679b07059">More...</a><br /></td></tr>
<tr class="separator:a76945903073c49706d025c7679b07059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf08ef3543bda6135f4f5663283241cf"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#abf08ef3543bda6135f4f5663283241cf">ch_get_target_int_counter</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t *meas_hist_ptr, uint8_t *thresh_count_ptr, uint8_t *reset_ptr)</td></tr>
<tr class="memdesc:abf08ef3543bda6135f4f5663283241cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target interrupt counter filter settings.  <a href="ch__api_8c.html#abf08ef3543bda6135f4f5663283241cf">More...</a><br /></td></tr>
<tr class="separator:abf08ef3543bda6135f4f5663283241cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc2253cbd8774013965ab82eadba27c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="soniclib_8h.html#ac2d701c38ecfaa08151839826667df20">ch_tgt_int_filter_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#abdc2253cbd8774013965ab82eadba27c">ch_get_target_interrupt</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:abdc2253cbd8774013965ab82eadba27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target interrupt filtering mode setting.  <a href="ch__api_8c.html#abdc2253cbd8774013965ab82eadba27c">More...</a><br /></td></tr>
<tr class="separator:abdc2253cbd8774013965ab82eadba27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74355ffe5e8887d74e9cdf5b3bd48a6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="soniclib_8h.html#aa18105c6986688c2700df504020bc2f2">ch_trigger_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a74355ffe5e8887d74e9cdf5b3bd48a6f">ch_get_trigger_type</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a74355ffe5e8887d74e9cdf5b3bd48a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the trigger type for a sensor.  <a href="ch__api_8c.html#a74355ffe5e8887d74e9cdf5b3bd48a6f">More...</a><br /></td></tr>
<tr class="separator:a74355ffe5e8887d74e9cdf5b3bd48a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a46285cbf72cb4d1c163f6575edf2f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a29a46285cbf72cb4d1c163f6575edf2f">ch_get_tx_length</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a29a46285cbf72cb4d1c163f6575edf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ultrasound transmit pulse length.  <a href="ch__api_8c.html#a29a46285cbf72cb4d1c163f6575edf2f">More...</a><br /></td></tr>
<tr class="separator:a29a46285cbf72cb4d1c163f6575edf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4371e12741e68a16c7d17a72c55fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a8a4371e12741e68a16c7d17a72c55fe9">ch_get_version</a> (<a class="el" href="structch__version__t.html">ch_version_t</a> *version_ptr)</td></tr>
<tr class="memdesc:a8a4371e12741e68a16c7d17a72c55fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SonicLib version number.  <a href="ch__api_8c.html#a8a4371e12741e68a16c7d17a72c55fe9">More...</a><br /></td></tr>
<tr class="separator:a8a4371e12741e68a16c7d17a72c55fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445492118ad79cd042bacbe6f16006f1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a445492118ad79cd042bacbe6f16006f1">ch_group_get_frequency</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a445492118ad79cd042bacbe6f16006f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the operating frequency for a group of sensors.  <a href="ch__api_8c.html#a445492118ad79cd042bacbe6f16006f1">More...</a><br /></td></tr>
<tr class="separator:a445492118ad79cd042bacbe6f16006f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80e105e4c2bcee89f2f606d35015050"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#af80e105e4c2bcee89f2f606d35015050">ch_group_get_pmut_clock_freq</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:af80e105e4c2bcee89f2f606d35015050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transducer clock input frequency for a group of sensors.  <a href="ch__api_8c.html#af80e105e4c2bcee89f2f606d35015050">More...</a><br /></td></tr>
<tr class="separator:af80e105e4c2bcee89f2f606d35015050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedc8fdec2ebbecb1b89c6856f63bd60"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aaedc8fdec2ebbecb1b89c6856f63bd60">ch_group_init</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t num_devices, uint8_t num_buses, uint16_t rtc_cal_pulse_ms)</td></tr>
<tr class="memdesc:aaedc8fdec2ebbecb1b89c6856f63bd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the group descriptor for a group of sensors.  <a href="ch__api_8c.html#aaedc8fdec2ebbecb1b89c6856f63bd60">More...</a><br /></td></tr>
<tr class="separator:aaedc8fdec2ebbecb1b89c6856f63bd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c386c49a6c8ad4bb506c4d00e3bcf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a63c386c49a6c8ad4bb506c4d00e3bcf5">ch_group_reset</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, <a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113">ch_reset_t</a> reset_type)</td></tr>
<tr class="memdesc:a63c386c49a6c8ad4bb506c4d00e3bcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a group of sensors.  <a href="ch__api_8c.html#a63c386c49a6c8ad4bb506c4d00e3bcf5">More...</a><br /></td></tr>
<tr class="separator:a63c386c49a6c8ad4bb506c4d00e3bcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69790de1c39a18e73c4b42d4670e80a8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a69790de1c39a18e73c4b42d4670e80a8">ch_group_restart</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a69790de1c39a18e73c4b42d4670e80a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart a group of sensors.  <a href="ch__api_8c.html#a69790de1c39a18e73c4b42d4670e80a8">More...</a><br /></td></tr>
<tr class="separator:a69790de1c39a18e73c4b42d4670e80a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c373443ede97b6665a9919b23074328"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a5c373443ede97b6665a9919b23074328">ch_group_set_frequency</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint32_t request_op_freq_hz)</td></tr>
<tr class="memdesc:a5c373443ede97b6665a9919b23074328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the operating frequency for a group of sensors.  <a href="ch__api_8c.html#a5c373443ede97b6665a9919b23074328">More...</a><br /></td></tr>
<tr class="separator:a5c373443ede97b6665a9919b23074328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5702e109dfbbd351a32df3df36c6e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ac5702e109dfbbd351a32df3df36c6e1b">ch_group_set_pmut_clock_freq</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint32_t pmut_clock_freq)</td></tr>
<tr class="memdesc:ac5702e109dfbbd351a32df3df36c6e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the transducer clock input frequency for a group of sensors.  <a href="ch__api_8c.html#ac5702e109dfbbd351a32df3df36c6e1b">More...</a><br /></td></tr>
<tr class="separator:ac5702e109dfbbd351a32df3df36c6e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1acc5372d38d7abd7028a5504e5634"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a3d1acc5372d38d7abd7028a5504e5634">ch_group_start</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a3d1acc5372d38d7abd7028a5504e5634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program and start a group of sensors.  <a href="ch__api_8c.html#a3d1acc5372d38d7abd7028a5504e5634">More...</a><br /></td></tr>
<tr class="separator:a3d1acc5372d38d7abd7028a5504e5634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e917eea19df611680dc97e2401db3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aa4e917eea19df611680dc97e2401db3a">ch_group_trigger</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:aa4e917eea19df611680dc97e2401db3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger a measurement on a group of sensors.  <a href="ch__api_8c.html#aa4e917eea19df611680dc97e2401db3a">More...</a><br /></td></tr>
<tr class="separator:aa4e917eea19df611680dc97e2401db3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb33f776f4a2d55c885023798402c2a5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#afb33f776f4a2d55c885023798402c2a5">ch_init</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t dev_num, <a class="el" href="soniclib_8h.html#a6c5f9dbeb75e38d6e3b81540a35b7fe0">ch_fw_init_func_t</a> fw_init_func)</td></tr>
<tr class="memdesc:afb33f776f4a2d55c885023798402c2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Chirp ultrasonic sensor descriptor structure.  <a href="ch__api_8c.html#afb33f776f4a2d55c885023798402c2a5">More...</a><br /></td></tr>
<tr class="separator:afb33f776f4a2d55c885023798402c2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad725040c45603cc81f47ccb4ab104efc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ad725040c45603cc81f47ccb4ab104efc">ch_init_algo</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ad725040c45603cc81f47ccb4ab104efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the measurement algorithm on a sensor.  <a href="ch__api_8c.html#ad725040c45603cc81f47ccb4ab104efc">More...</a><br /></td></tr>
<tr class="separator:ad725040c45603cc81f47ccb4ab104efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68080a85a27dc680ce55c020f575c5c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a68080a85a27dc680ce55c020f575c5c3">ch_interrupt</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t dev_num)</td></tr>
<tr class="memdesc:a68080a85a27dc680ce55c020f575c5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify SonicLib that a sensor interrupt occurred.  <a href="ch__api_8c.html#a68080a85a27dc680ce55c020f575c5c3">More...</a><br /></td></tr>
<tr class="separator:a68080a85a27dc680ce55c020f575c5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40302a26ef7dd9868f5c28bcfc15cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ae40302a26ef7dd9868f5c28bcfc15cea">ch_io_complete_callback_set</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, <a class="el" href="soniclib_8h.html#a98e3bc51c237abf8b03ce396db3f7caf">ch_io_complete_callback_t</a> callback_func_ptr)</td></tr>
<tr class="memdesc:ae40302a26ef7dd9868f5c28bcfc15cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for Chirp sensor I/O operation complete.  <a href="ch__api_8c.html#ae40302a26ef7dd9868f5c28bcfc15cea">More...</a><br /></td></tr>
<tr class="separator:ae40302a26ef7dd9868f5c28bcfc15cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d4045f3510d82596c8231123e890b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#af3d4045f3510d82596c8231123e890b9">ch_io_int_callback_set</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, <a class="el" href="soniclib_8h.html#a752bd8d2cf0340ffc3707a25b2a88227">ch_io_int_callback_t</a> callback_func_ptr)</td></tr>
<tr class="memdesc:af3d4045f3510d82596c8231123e890b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for Chirp sensor I/O interrupt.  <a href="ch__api_8c.html#af3d4045f3510d82596c8231123e890b9">More...</a><br /></td></tr>
<tr class="separator:af3d4045f3510d82596c8231123e890b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b5931001ef934347a12daa46d700a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a32b5931001ef934347a12daa46d700a7">ch_io_notify</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t i2c_bus_index)</td></tr>
<tr class="memdesc:a32b5931001ef934347a12daa46d700a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continue a non-blocking readout.  <a href="ch__api_8c.html#a32b5931001ef934347a12daa46d700a7">More...</a><br /></td></tr>
<tr class="separator:a32b5931001ef934347a12daa46d700a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b5f63c32c49bf634a00fc6594e57bc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#af7b5f63c32c49bf634a00fc6594e57bc">ch_io_start_nb</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:af7b5f63c32c49bf634a00fc6594e57bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a non-blocking sensor readout.  <a href="ch__api_8c.html#af7b5f63c32c49bf634a00fc6594e57bc">More...</a><br /></td></tr>
<tr class="separator:af7b5f63c32c49bf634a00fc6594e57bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78bd32dde57faf8200f39786151040c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ac78bd32dde57faf8200f39786151040c">ch_iq_to_amplitude</a> (<a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a> *iq_sample)</td></tr>
<tr class="memdesc:ac78bd32dde57faf8200f39786151040c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate amplitude from sample I/Q values.  <a href="ch__api_8c.html#ac78bd32dde57faf8200f39786151040c">More...</a><br /></td></tr>
<tr class="separator:ac78bd32dde57faf8200f39786151040c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b106baa702f500a55e64787bace2bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a89b106baa702f500a55e64787bace2bb">ch_log_append</a> (uint8_t log_id, <a class="el" href="soniclib_8h.html#a9b0598bc1d023573411e2831f3d28108">ch_log_fmt_t</a> format, uint64_t timestamp_usec, <a class="el" href="structch__log__data__t.html">ch_log_data_t</a> *log_data_ptr)</td></tr>
<tr class="memdesc:a89b106baa702f500a55e64787bace2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append received sensor data to log.  <a href="ch__api_8c.html#a89b106baa702f500a55e64787bace2bb">More...</a><br /></td></tr>
<tr class="separator:a89b106baa702f500a55e64787bace2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a33406081a2392fd38f36cd65e8b8cb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a4a33406081a2392fd38f36cd65e8b8cb">ch_log_init</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, <a class="el" href="soniclib_8h.html#a9b0598bc1d023573411e2831f3d28108">ch_log_fmt_t</a> format, <a class="el" href="structch__log__cfg__t.html">ch_log_cfg_t</a> *config_ptr)</td></tr>
<tr class="memdesc:a4a33406081a2392fd38f36cd65e8b8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a log in the specified log format.  <a href="ch__api_8c.html#a4a33406081a2392fd38f36cd65e8b8cb">More...</a><br /></td></tr>
<tr class="separator:a4a33406081a2392fd38f36cd65e8b8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5372b50fccbc80b38dab4722dfaed9fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a5372b50fccbc80b38dab4722dfaed9fc">ch_meas_activate</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:a5372b50fccbc80b38dab4722dfaed9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a defined measurement.  <a href="ch__api_8c.html#a5372b50fccbc80b38dab4722dfaed9fc">More...</a><br /></td></tr>
<tr class="separator:a5372b50fccbc80b38dab4722dfaed9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063940d1f4d8613c4c0abaa421a17b0c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a063940d1f4d8613c4c0abaa421a17b0c">ch_meas_add_segment</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, <a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *seg_ptr)</td></tr>
<tr class="memdesc:a063940d1f4d8613c4c0abaa421a17b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a segment to a measurement.  <a href="ch__api_8c.html#a063940d1f4d8613c4c0abaa421a17b0c">More...</a><br /></td></tr>
<tr class="separator:a063940d1f4d8613c4c0abaa421a17b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414bed6efd64e03e74c13dabf97aa7f1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a414bed6efd64e03e74c13dabf97aa7f1">ch_meas_add_segment_count</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint16_t num_cycles, uint8_t int_enable)</td></tr>
<tr class="memdesc:a414bed6efd64e03e74c13dabf97aa7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a count (delay) segment to a measurement.  <a href="ch__api_8c.html#a414bed6efd64e03e74c13dabf97aa7f1">More...</a><br /></td></tr>
<tr class="separator:a414bed6efd64e03e74c13dabf97aa7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf06fb5c8f5fcf8947e71b49957e0ee"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#adbf06fb5c8f5fcf8947e71b49957e0ee">ch_meas_add_segment_rx</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint16_t length, uint8_t gain, uint8_t atten, uint8_t int_enable)</td></tr>
<tr class="memdesc:adbf06fb5c8f5fcf8947e71b49957e0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a receive segment to a measurement.  <a href="ch__api_8c.html#adbf06fb5c8f5fcf8947e71b49957e0ee">More...</a><br /></td></tr>
<tr class="separator:adbf06fb5c8f5fcf8947e71b49957e0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8214b6c4e8592686ae3bb9daa0833012"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a8214b6c4e8592686ae3bb9daa0833012">ch_meas_add_segment_tx</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint16_t num_cycles, uint8_t pulse_width, uint8_t phase, uint8_t int_enable)</td></tr>
<tr class="memdesc:a8214b6c4e8592686ae3bb9daa0833012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a transmit segment to a measurement.  <a href="ch__api_8c.html#a8214b6c4e8592686ae3bb9daa0833012">More...</a><br /></td></tr>
<tr class="separator:a8214b6c4e8592686ae3bb9daa0833012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d2278773b6676145e9d86bb1cdf769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aa3d2278773b6676145e9d86bb1cdf769">ch_meas_get_info</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, <a class="el" href="structch__meas__info__t.html">ch_meas_info_t</a> *info_ptr)</td></tr>
<tr class="memdesc:aa3d2278773b6676145e9d86bb1cdf769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get configuration information for a measurement.  <a href="ch__api_8c.html#aa3d2278773b6676145e9d86bb1cdf769">More...</a><br /></td></tr>
<tr class="separator:aa3d2278773b6676145e9d86bb1cdf769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c76a6684d06acdd7ff60de902ef9cf0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a5c76a6684d06acdd7ff60de902ef9cf0">ch_meas_get_interval</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:a5c76a6684d06acdd7ff60de902ef9cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the repeat interval for a measurement, in milliseconds.  <a href="ch__api_8c.html#a5c76a6684d06acdd7ff60de902ef9cf0">More...</a><br /></td></tr>
<tr class="separator:a5c76a6684d06acdd7ff60de902ef9cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2402d08e2043ec130dbbb090b1c67596"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a2402d08e2043ec130dbbb090b1c67596">ch_meas_get_interval_ticks</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:a2402d08e2043ec130dbbb090b1c67596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the repeat interval for a measurement, in sensor RTC clock ticks.  <a href="ch__api_8c.html#a2402d08e2043ec130dbbb090b1c67596">More...</a><br /></td></tr>
<tr class="separator:a2402d08e2043ec130dbbb090b1c67596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6062925563a899604cc8665398fa635"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aa6062925563a899604cc8665398fa635">ch_meas_get_interval_us</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:aa6062925563a899604cc8665398fa635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the repeat interval for a measurement, in microseconds.  <a href="ch__api_8c.html#aa6062925563a899604cc8665398fa635">More...</a><br /></td></tr>
<tr class="separator:aa6062925563a899604cc8665398fa635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae9547bfdb9eda44b7f3f44c42d815e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="soniclib_8h.html#a5143295fdd1fdd439dad873fb9e04948">ch_output_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#abae9547bfdb9eda44b7f3f44c42d815e">ch_meas_get_iq_output</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:abae9547bfdb9eda44b7f3f44c42d815e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the I/Q data output format for a measurement.  <a href="ch__api_8c.html#abae9547bfdb9eda44b7f3f44c42d815e">More...</a><br /></td></tr>
<tr class="separator:abae9547bfdb9eda44b7f3f44c42d815e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea79708279e4f56734234dd07ae23f4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a2ea79708279e4f56734234dd07ae23f4">ch_meas_get_last_num</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a2ea79708279e4f56734234dd07ae23f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of last completed measurement.  <a href="ch__api_8c.html#a2ea79708279e4f56734234dd07ae23f4">More...</a><br /></td></tr>
<tr class="separator:a2ea79708279e4f56734234dd07ae23f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7763faeec4c696c10410544cb01365"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#acd7763faeec4c696c10410544cb01365">ch_meas_get_max_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:acd7763faeec4c696c10410544cb01365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum range setting in mm for a specific measurement.  <a href="ch__api_8c.html#acd7763faeec4c696c10410544cb01365">More...</a><br /></td></tr>
<tr class="separator:acd7763faeec4c696c10410544cb01365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf5688451893bddde1d3623dd34f48d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a9bf5688451893bddde1d3623dd34f48d">ch_meas_get_num_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:a9bf5688451893bddde1d3623dd34f48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of samples per measurement cycle for a specific measurement.  <a href="ch__api_8c.html#a9bf5688451893bddde1d3623dd34f48d">More...</a><br /></td></tr>
<tr class="separator:a9bf5688451893bddde1d3623dd34f48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc69e96679d03384c1cf912ebf66c614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="soniclib_8h.html#a86140657375a7e7c24ecf430da97c189">ch_odr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#abc69e96679d03384c1cf912ebf66c614">ch_meas_get_odr</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:abc69e96679d03384c1cf912ebf66c614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output data rate for a measurement.  <a href="ch__api_8c.html#abc69e96679d03384c1cf912ebf66c614">More...</a><br /></td></tr>
<tr class="separator:abc69e96679d03384c1cf912ebf66c614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591525a8a8a249db1a0e26504391c8bb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a591525a8a8a249db1a0e26504391c8bb">ch_meas_get_queue</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, measurement_queue_t *meas_queue_ptr)</td></tr>
<tr class="memdesc:a591525a8a8a249db1a0e26504391c8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get measurement queue values for a sensor.  <a href="ch__api_8c.html#a591525a8a8a249db1a0e26504391c8bb">More...</a><br /></td></tr>
<tr class="separator:a591525a8a8a249db1a0e26504391c8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3800e5639a3dae4272db79573180641d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a3800e5639a3dae4272db79573180641d">ch_meas_get_queue_info</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__meas__queue__info__t.html">ch_meas_queue_info_t</a> *info_ptr)</td></tr>
<tr class="memdesc:a3800e5639a3dae4272db79573180641d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get configuration information for the sensor measurement queue.  <a href="ch__api_8c.html#a3800e5639a3dae4272db79573180641d">More...</a><br /></td></tr>
<tr class="separator:a3800e5639a3dae4272db79573180641d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081ad1d7648bac0ed82f3ff93d7f0321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a081ad1d7648bac0ed82f3ff93d7f0321">ch_meas_get_seg_info</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint8_t seg_num, <a class="el" href="structch__meas__seg__info__t.html">ch_meas_seg_info_t</a> *info_ptr)</td></tr>
<tr class="memdesc:a081ad1d7648bac0ed82f3ff93d7f0321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get configuration information for a measurement segment.  <a href="ch__api_8c.html#a081ad1d7648bac0ed82f3ff93d7f0321">More...</a><br /></td></tr>
<tr class="separator:a081ad1d7648bac0ed82f3ff93d7f0321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90245534189e3893901e90e63fc9e26c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="soniclib_8h.html#a00b8943dd0033cdbdd6e4da6334f283b">ch_meas_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a90245534189e3893901e90e63fc9e26c">ch_meas_get_status</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:a90245534189e3893901e90e63fc9e26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get measurement status.  <a href="ch__api_8c.html#a90245534189e3893901e90e63fc9e26c">More...</a><br /></td></tr>
<tr class="separator:a90245534189e3893901e90e63fc9e26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719bb8d611224839c6d9404d339bc9e8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a719bb8d611224839c6d9404d339bc9e8">ch_meas_import</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, measurement_queue_t *meas_queue_ptr, void *algo_cfg_ptr)</td></tr>
<tr class="memdesc:a719bb8d611224839c6d9404d339bc9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import an externally defined measurement configuration.  <a href="ch__api_8c.html#a719bb8d611224839c6d9404d339bc9e8">More...</a><br /></td></tr>
<tr class="separator:a719bb8d611224839c6d9404d339bc9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfa2a99ca4868b9cd6d363a7f14270e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a0dfa2a99ca4868b9cd6d363a7f14270e">ch_meas_init</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, const <a class="el" href="structch__meas__config__t.html">ch_meas_config_t</a> *meas_config_ptr, const void *thresh_ptr)</td></tr>
<tr class="memdesc:a0dfa2a99ca4868b9cd6d363a7f14270e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a measurement.  <a href="ch__api_8c.html#a0dfa2a99ca4868b9cd6d363a7f14270e">More...</a><br /></td></tr>
<tr class="separator:a0dfa2a99ca4868b9cd6d363a7f14270e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5abc7618cd984d09270ec7c2599e76"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a5c5abc7618cd984d09270ec7c2599e76">ch_meas_init_queue</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a5c5abc7618cd984d09270ec7c2599e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the sensor measurement queue.  <a href="ch__api_8c.html#a5c5abc7618cd984d09270ec7c2599e76">More...</a><br /></td></tr>
<tr class="separator:a5c5abc7618cd984d09270ec7c2599e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cbeef0db6da0bdafa19165151b4c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ac1cbeef0db6da0bdafa19165151b4c40">ch_meas_init_segment_count</a> (<a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *seg_ptr, uint16_t num_cycles, uint8_t int_enable)</td></tr>
<tr class="memdesc:ac1cbeef0db6da0bdafa19165151b4c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a count (delay) measurement segment.  <a href="ch__api_8c.html#ac1cbeef0db6da0bdafa19165151b4c40">More...</a><br /></td></tr>
<tr class="separator:ac1cbeef0db6da0bdafa19165151b4c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f42f21b5a63f0717c6b032d77a54507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a8f42f21b5a63f0717c6b032d77a54507">ch_meas_init_segment_rx</a> (<a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *seg_ptr, uint16_t num_samples, <a class="el" href="soniclib_8h.html#a86140657375a7e7c24ecf430da97c189">ch_odr_t</a> odr, uint8_t gain, uint8_t atten, uint8_t int_enable)</td></tr>
<tr class="memdesc:a8f42f21b5a63f0717c6b032d77a54507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a receive measurement segment.  <a href="ch__api_8c.html#a8f42f21b5a63f0717c6b032d77a54507">More...</a><br /></td></tr>
<tr class="separator:a8f42f21b5a63f0717c6b032d77a54507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde2d67659346569ec81c5e7f51d7647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#adde2d67659346569ec81c5e7f51d7647">ch_meas_init_segment_tx</a> (<a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *seg_ptr, uint16_t num_cycles, uint8_t pulse_width, uint8_t phase, uint8_t int_enable)</td></tr>
<tr class="memdesc:adde2d67659346569ec81c5e7f51d7647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a transmit measurement segment.  <a href="ch__api_8c.html#adde2d67659346569ec81c5e7f51d7647">More...</a><br /></td></tr>
<tr class="separator:adde2d67659346569ec81c5e7f51d7647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c95d14cdd3f9656e2f4e9b9a805c4b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ab2c95d14cdd3f9656e2f4e9b9a805c4b">ch_meas_insert_instruction</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, const <a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *inst_ptr, uint8_t index_to_insert)</td></tr>
<tr class="memdesc:ab2c95d14cdd3f9656e2f4e9b9a805c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an instruction(segment) to a measurement.  <a href="ch__api_8c.html#ab2c95d14cdd3f9656e2f4e9b9a805c4b">More...</a><br /></td></tr>
<tr class="separator:ab2c95d14cdd3f9656e2f4e9b9a805c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e8410407cea43d44abada1eb739f42"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a15e8410407cea43d44abada1eb739f42">ch_meas_insert_segment</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, const <a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *inst_ptr, uint8_t index_to_insert)</td></tr>
<tr class="memdesc:a15e8410407cea43d44abada1eb739f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an instruction(segment) to a measurement.  <a href="ch__api_8c.html#a15e8410407cea43d44abada1eb739f42">More...</a><br /></td></tr>
<tr class="separator:a15e8410407cea43d44abada1eb739f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4203c97c07e47db67bf2e1c1eb16b054"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a4203c97c07e47db67bf2e1c1eb16b054">ch_meas_mm_to_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint16_t num_mm)</td></tr>
<tr class="memdesc:a4203c97c07e47db67bf2e1c1eb16b054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert millimeters to sample count for a specific measurement.  <a href="ch__api_8c.html#a4203c97c07e47db67bf2e1c1eb16b054">More...</a><br /></td></tr>
<tr class="separator:a4203c97c07e47db67bf2e1c1eb16b054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d21dc9fdd39ade2eef9c269ba027272"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a6d21dc9fdd39ade2eef9c269ba027272">ch_meas_optimize</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, measurement_queue_t *meas_queue_ptr, void *algo_cfg_ptr)</td></tr>
<tr class="memdesc:a6d21dc9fdd39ade2eef9c269ba027272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize ultrasound measurement sequences for a sensor.  <a href="ch__api_8c.html#a6d21dc9fdd39ade2eef9c269ba027272">More...</a><br /></td></tr>
<tr class="separator:a6d21dc9fdd39ade2eef9c269ba027272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8224fdbf97c25d75219f9fee87ab9a98"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a8224fdbf97c25d75219f9fee87ab9a98">ch_meas_remove_instruction</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint8_t index_to_remove)</td></tr>
<tr class="memdesc:a8224fdbf97c25d75219f9fee87ab9a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an instruction(segment) in a measurement.  <a href="ch__api_8c.html#a8224fdbf97c25d75219f9fee87ab9a98">More...</a><br /></td></tr>
<tr class="separator:a8224fdbf97c25d75219f9fee87ab9a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee0747d4c1668e07ef242f4c17dbdbf"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a0ee0747d4c1668e07ef242f4c17dbdbf">ch_meas_remove_segment</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint8_t index_to_remove)</td></tr>
<tr class="memdesc:a0ee0747d4c1668e07ef242f4c17dbdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an instruction(segment) in a measurement.  <a href="ch__api_8c.html#a0ee0747d4c1668e07ef242f4c17dbdbf">More...</a><br /></td></tr>
<tr class="separator:a0ee0747d4c1668e07ef242f4c17dbdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2b49af5ae78b7b277666ff7c4f0937"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a8d2b49af5ae78b7b277666ff7c4f0937">ch_meas_reset</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:a8d2b49af5ae78b7b277666ff7c4f0937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a measurement.  <a href="ch__api_8c.html#a8d2b49af5ae78b7b277666ff7c4f0937">More...</a><br /></td></tr>
<tr class="separator:a8d2b49af5ae78b7b277666ff7c4f0937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70baf4591a0f4031f566ca7fcb73b0cd"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a70baf4591a0f4031f566ca7fcb73b0cd">ch_meas_samples_to_mm</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint16_t num_samples)</td></tr>
<tr class="memdesc:a70baf4591a0f4031f566ca7fcb73b0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert sample count to millimeters for a specific measurement.  <a href="ch__api_8c.html#a70baf4591a0f4031f566ca7fcb73b0cd">More...</a><br /></td></tr>
<tr class="separator:a70baf4591a0f4031f566ca7fcb73b0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398f9f8bf2f5a20531e7c8ab1852fd"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a52398f9f8bf2f5a20531e7c8ab1852fd">ch_meas_set_interval</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint16_t interval_ms)</td></tr>
<tr class="memdesc:a52398f9f8bf2f5a20531e7c8ab1852fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the repeat interval for a measurement, in milliseconds.  <a href="ch__api_8c.html#a52398f9f8bf2f5a20531e7c8ab1852fd">More...</a><br /></td></tr>
<tr class="separator:a52398f9f8bf2f5a20531e7c8ab1852fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d3915b3152ca1fda21ddddefb95fec"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a88d3915b3152ca1fda21ddddefb95fec">ch_meas_set_interval_ticks</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint32_t rtc_ticks)</td></tr>
<tr class="memdesc:a88d3915b3152ca1fda21ddddefb95fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the repeat interval for a measurement, in sensor RTC clock ticks.  <a href="ch__api_8c.html#a88d3915b3152ca1fda21ddddefb95fec">More...</a><br /></td></tr>
<tr class="separator:a88d3915b3152ca1fda21ddddefb95fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4001469a3a233c39cead6f6624d436eb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a4001469a3a233c39cead6f6624d436eb">ch_meas_set_interval_us</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint32_t interval_us)</td></tr>
<tr class="memdesc:a4001469a3a233c39cead6f6624d436eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the repeat interval for a measurement, in microseconds.  <a href="ch__api_8c.html#a4001469a3a233c39cead6f6624d436eb">More...</a><br /></td></tr>
<tr class="separator:a4001469a3a233c39cead6f6624d436eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb6e60f175bbb08c87787c0ac680865"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a3fb6e60f175bbb08c87787c0ac680865">ch_meas_set_iq_output</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, <a class="el" href="soniclib_8h.html#a5143295fdd1fdd439dad873fb9e04948">ch_output_type_t</a> output_format)</td></tr>
<tr class="memdesc:a3fb6e60f175bbb08c87787c0ac680865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the I/Q data output format for a measurement.  <a href="ch__api_8c.html#a3fb6e60f175bbb08c87787c0ac680865">More...</a><br /></td></tr>
<tr class="separator:a3fb6e60f175bbb08c87787c0ac680865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc7192978564ab0f477ee2132870fea"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#acfc7192978564ab0f477ee2132870fea">ch_meas_set_max_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint16_t max_range_mm)</td></tr>
<tr class="memdesc:acfc7192978564ab0f477ee2132870fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum range in mm for a specific measurement.  <a href="ch__api_8c.html#acfc7192978564ab0f477ee2132870fea">More...</a><br /></td></tr>
<tr class="separator:acfc7192978564ab0f477ee2132870fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d24256fc81eaadb687786ee41bec7c9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a7d24256fc81eaadb687786ee41bec7c9">ch_meas_set_num_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, uint16_t num_samples)</td></tr>
<tr class="memdesc:a7d24256fc81eaadb687786ee41bec7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sensor sample count for a specific measurement.  <a href="ch__api_8c.html#a7d24256fc81eaadb687786ee41bec7c9">More...</a><br /></td></tr>
<tr class="separator:a7d24256fc81eaadb687786ee41bec7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5748ec903986b27b78f4a52b8c9e23"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#adc5748ec903986b27b78f4a52b8c9e23">ch_meas_set_odr</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num, <a class="el" href="soniclib_8h.html#a86140657375a7e7c24ecf430da97c189">ch_odr_t</a> odr)</td></tr>
<tr class="memdesc:adc5748ec903986b27b78f4a52b8c9e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output data rate for a measurement.  <a href="ch__api_8c.html#adc5748ec903986b27b78f4a52b8c9e23">More...</a><br /></td></tr>
<tr class="separator:adc5748ec903986b27b78f4a52b8c9e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc64afbffb1f34e6881528e31bce9286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#afc64afbffb1f34e6881528e31bce9286">ch_meas_standby</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:afc64afbffb1f34e6881528e31bce9286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a measurement in standby mode.  <a href="ch__api_8c.html#afc64afbffb1f34e6881528e31bce9286">More...</a><br /></td></tr>
<tr class="separator:afc64afbffb1f34e6881528e31bce9286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20576be17d3be2e6c3293c753c94c434"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a20576be17d3be2e6c3293c753c94c434">ch_meas_switch</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a20576be17d3be2e6c3293c753c94c434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch active and standby measurement definitions.  <a href="ch__api_8c.html#a20576be17d3be2e6c3293c753c94c434">More...</a><br /></td></tr>
<tr class="separator:a20576be17d3be2e6c3293c753c94c434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8421a242bc38e92a27e96814c64c1c95"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a8421a242bc38e92a27e96814c64c1c95">ch_meas_time_hop_disable</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:a8421a242bc38e92a27e96814c64c1c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable time-hopping on measure period freerunning mode.  <a href="ch__api_8c.html#a8421a242bc38e92a27e96814c64c1c95">More...</a><br /></td></tr>
<tr class="separator:a8421a242bc38e92a27e96814c64c1c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b5b2e869a15194c08ae15f0e20cb14"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aa2b5b2e869a15194c08ae15f0e20cb14">ch_meas_time_hop_enable</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_num)</td></tr>
<tr class="memdesc:aa2b5b2e869a15194c08ae15f0e20cb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable time-hopping on measure period freerunning mode.  <a href="ch__api_8c.html#aa2b5b2e869a15194c08ae15f0e20cb14">More...</a><br /></td></tr>
<tr class="separator:aa2b5b2e869a15194c08ae15f0e20cb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9450f4a5d409c8e1474d4ae078fbe4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a8f9450f4a5d409c8e1474d4ae078fbe4">ch_meas_write_config</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a8f9450f4a5d409c8e1474d4ae078fbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write measurement configuration to sensor.  <a href="ch__api_8c.html#a8f9450f4a5d409c8e1474d4ae078fbe4">More...</a><br /></td></tr>
<tr class="separator:a8f9450f4a5d409c8e1474d4ae078fbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77a85293f155a6f5c045a15a7154ad1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aa77a85293f155a6f5c045a15a7154ad1">ch_measure_pmut_frequency</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:aa77a85293f155a6f5c045a15a7154ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure PMUT frequency on an ICU device.  <a href="ch__api_8c.html#aa77a85293f155a6f5c045a15a7154ad1">More...</a><br /></td></tr>
<tr class="separator:aa77a85293f155a6f5c045a15a7154ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89c9e6ef3d8a200f741e81dca0e324c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ae89c9e6ef3d8a200f741e81dca0e324c">ch_minimal_int_handler</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t dev_num)</td></tr>
<tr class="memdesc:ae89c9e6ef3d8a200f741e81dca0e324c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify SonicLib that a sensor interrupt was received.  <a href="ch__api_8c.html#ae89c9e6ef3d8a200f741e81dca0e324c">More...</a><br /></td></tr>
<tr class="separator:ae89c9e6ef3d8a200f741e81dca0e324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa256c720961a6d327c515da60d8071c2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aa256c720961a6d327c515da60d8071c2">ch_mm_to_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_mm)</td></tr>
<tr class="memdesc:aa256c720961a6d327c515da60d8071c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert millimeters to sample count for a sensor.  <a href="ch__api_8c.html#aa256c720961a6d327c515da60d8071c2">More...</a><br /></td></tr>
<tr class="separator:aa256c720961a6d327c515da60d8071c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38861d5f023ea837a9ee15bdca5fa114"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a38861d5f023ea837a9ee15bdca5fa114">ch_reset</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113">ch_reset_t</a> reset_type)</td></tr>
<tr class="memdesc:a38861d5f023ea837a9ee15bdca5fa114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a sensor.  <a href="ch__api_8c.html#a38861d5f023ea837a9ee15bdca5fa114">More...</a><br /></td></tr>
<tr class="separator:a38861d5f023ea837a9ee15bdca5fa114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25e3902b1313e4de920e703564bffb5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#af25e3902b1313e4de920e703564bffb5">ch_restart</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:af25e3902b1313e4de920e703564bffb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart a sensor.  <a href="ch__api_8c.html#af25e3902b1313e4de920e703564bffb5">More...</a><br /></td></tr>
<tr class="separator:af25e3902b1313e4de920e703564bffb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf5b05b264ae9dce5a4b9f752dceb24"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a3bf5b05b264ae9dce5a4b9f752dceb24">ch_samples_to_cycles</a> (uint16_t num_samples, <a class="el" href="soniclib_8h.html#a86140657375a7e7c24ecf430da97c189">ch_odr_t</a> odr)</td></tr>
<tr class="memdesc:a3bf5b05b264ae9dce5a4b9f752dceb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert samples to sensor cycles.  <a href="ch__api_8c.html#a3bf5b05b264ae9dce5a4b9f752dceb24">More...</a><br /></td></tr>
<tr class="separator:a3bf5b05b264ae9dce5a4b9f752dceb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290f3e5de2ee174e37ff4522df51d376"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a290f3e5de2ee174e37ff4522df51d376">ch_samples_to_mm</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_samples)</td></tr>
<tr class="memdesc:a290f3e5de2ee174e37ff4522df51d376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert sample count to millimeters for a sensor.  <a href="ch__api_8c.html#a290f3e5de2ee174e37ff4522df51d376">More...</a><br /></td></tr>
<tr class="separator:a290f3e5de2ee174e37ff4522df51d376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea97825e46bd60eeb79cd5a155f80d0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a1ea97825e46bd60eeb79cd5a155f80d0">ch_sensor_is_connected</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a1ea97825e46bd60eeb79cd5a155f80d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if a sensor is connected.  <a href="ch__api_8c.html#a1ea97825e46bd60eeb79cd5a155f80d0">More...</a><br /></td></tr>
<tr class="separator:a1ea97825e46bd60eeb79cd5a155f80d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0946a2fe093c2eb4c8de5d4d7535c159"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a0946a2fe093c2eb4c8de5d4d7535c159">ch_set_algo_config</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, const void *algo_cfg_ptr)</td></tr>
<tr class="memdesc:a0946a2fe093c2eb4c8de5d4d7535c159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the measurement algorithm configuration data to a sensor.  <a href="ch__api_8c.html#a0946a2fe093c2eb4c8de5d4d7535c159">More...</a><br /></td></tr>
<tr class="separator:a0946a2fe093c2eb4c8de5d4d7535c159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d01cb587379697f451459a2e4204d0c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a0d01cb587379697f451459a2e4204d0c">ch_set_cal_result</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__cal__result__t.html">ch_cal_result_t</a> *cal_ptr)</td></tr>
<tr class="memdesc:a0d01cb587379697f451459a2e4204d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the calibration result.  <a href="ch__api_8c.html#a0d01cb587379697f451459a2e4204d0c">More...</a><br /></td></tr>
<tr class="separator:a0d01cb587379697f451459a2e4204d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210dcd310e0c16c343f11c2e3c53984f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a210dcd310e0c16c343f11c2e3c53984f">ch_set_config</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__config__t.html">ch_config_t</a> *config_ptr)</td></tr>
<tr class="memdesc:a210dcd310e0c16c343f11c2e3c53984f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple configuration settings for a sensor.  <a href="ch__api_8c.html#a210dcd310e0c16c343f11c2e3c53984f">More...</a><br /></td></tr>
<tr class="separator:a210dcd310e0c16c343f11c2e3c53984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1ee2f0dd09e40fbf286bb1da8b00b8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aab1ee2f0dd09e40fbf286bb1da8b00b8">ch_set_data_output</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__output__t.html">ch_output_t</a> *output_ptr)</td></tr>
<tr class="memdesc:aab1ee2f0dd09e40fbf286bb1da8b00b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data output format and rate.  <a href="ch__api_8c.html#aab1ee2f0dd09e40fbf286bb1da8b00b8">More...</a><br /></td></tr>
<tr class="separator:aab1ee2f0dd09e40fbf286bb1da8b00b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd13d9b1ba62dca747988e1b4abc1e0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a0fd13d9b1ba62dca747988e1b4abc1e0">ch_set_data_ready_delay</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t delay_ms)</td></tr>
<tr class="memdesc:a0fd13d9b1ba62dca747988e1b4abc1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data ready interrupt delay interval.  <a href="ch__api_8c.html#a0fd13d9b1ba62dca747988e1b4abc1e0">More...</a><br /></td></tr>
<tr class="separator:a0fd13d9b1ba62dca747988e1b4abc1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa29a954eea0f9c7d1f4172390aa02b8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#afa29a954eea0f9c7d1f4172390aa02b8">ch_set_freerun_interval</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t sense_interval_ms)</td></tr>
<tr class="memdesc:afa29a954eea0f9c7d1f4172390aa02b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal sensing interval for freerunning mode, in milliseconds.  <a href="ch__api_8c.html#afa29a954eea0f9c7d1f4172390aa02b8">More...</a><br /></td></tr>
<tr class="separator:afa29a954eea0f9c7d1f4172390aa02b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa250f16c28b6ff8aa11b66ffc69c1a0c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aa250f16c28b6ff8aa11b66ffc69c1a0c">ch_set_freerun_interval_ticks</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint32_t sense_interval_ticks)</td></tr>
<tr class="memdesc:aa250f16c28b6ff8aa11b66ffc69c1a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal sensing interval for freerunning mode, in RTC clock ticks.  <a href="ch__api_8c.html#aa250f16c28b6ff8aa11b66ffc69c1a0c">More...</a><br /></td></tr>
<tr class="separator:aa250f16c28b6ff8aa11b66ffc69c1a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c0d862213e31f2f8f6fc16775aa01e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ae3c0d862213e31f2f8f6fc16775aa01e">ch_set_freerun_interval_us</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint32_t sense_interval_us)</td></tr>
<tr class="memdesc:ae3c0d862213e31f2f8f6fc16775aa01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal sensing interval for freerunning mode, in microseconds.  <a href="ch__api_8c.html#ae3c0d862213e31f2f8f6fc16775aa01e">More...</a><br /></td></tr>
<tr class="separator:ae3c0d862213e31f2f8f6fc16775aa01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6b0cc10159a9a9bb4dd74f38384d3a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a5c6b0cc10159a9a9bb4dd74f38384d3a">ch_set_frequency</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint32_t request_op_freq_hz)</td></tr>
<tr class="memdesc:a5c6b0cc10159a9a9bb4dd74f38384d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the operating frequency of a sensor.  <a href="ch__api_8c.html#a5c6b0cc10159a9a9bb4dd74f38384d3a">More...</a><br /></td></tr>
<tr class="separator:a5c6b0cc10159a9a9bb4dd74f38384d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06071a7f3eeb6376fcf9ab4a2da9a2e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ab06071a7f3eeb6376fcf9ab4a2da9a2e">ch_set_init_firmware</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a6c5f9dbeb75e38d6e3b81540a35b7fe0">ch_fw_init_func_t</a> fw_init_func)</td></tr>
<tr class="memdesc:ab06071a7f3eeb6376fcf9ab4a2da9a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the init firmware to use for a sensor.  <a href="ch__api_8c.html#ab06071a7f3eeb6376fcf9ab4a2da9a2e">More...</a><br /></td></tr>
<tr class="separator:ab06071a7f3eeb6376fcf9ab4a2da9a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddffdfb6704d3598c34f7ba93094bbd"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a1ddffdfb6704d3598c34f7ba93094bbd">ch_set_interrupt_drive</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a3406ad6d96900bf23674fc44468caf5d">ch_interrupt_drive_t</a> drive)</td></tr>
<tr class="memdesc:a1ddffdfb6704d3598c34f7ba93094bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt drive (open drain or push pull)  <a href="ch__api_8c.html#a1ddffdfb6704d3598c34f7ba93094bbd">More...</a><br /></td></tr>
<tr class="separator:a1ddffdfb6704d3598c34f7ba93094bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1611f339f145d08e71ed5405d72e1bc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ab1611f339f145d08e71ed5405d72e1bc">ch_set_interrupt_mode</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a4962ca7e356fbfa6e40863fe5abf519c">ch_interrupt_mode_t</a> mode)</td></tr>
<tr class="memdesc:ab1611f339f145d08e71ed5405d72e1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt mode (pulsed or latching)  <a href="ch__api_8c.html#ab1611f339f145d08e71ed5405d72e1bc">More...</a><br /></td></tr>
<tr class="separator:ab1611f339f145d08e71ed5405d72e1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a264ebc25b13778176e83c0c910997"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a41a264ebc25b13778176e83c0c910997">ch_set_max_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t max_range)</td></tr>
<tr class="memdesc:a41a264ebc25b13778176e83c0c910997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum range for a sensor.  <a href="ch__api_8c.html#a41a264ebc25b13778176e83c0c910997">More...</a><br /></td></tr>
<tr class="separator:a41a264ebc25b13778176e83c0c910997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af427c34df885a028ee0f7cdddc981001"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#af427c34df885a028ee0f7cdddc981001">ch_set_mode</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">ch_mode_t</a> mode)</td></tr>
<tr class="memdesc:af427c34df885a028ee0f7cdddc981001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a sensor for the specified operating mode.  <a href="ch__api_8c.html#af427c34df885a028ee0f7cdddc981001">More...</a><br /></td></tr>
<tr class="separator:af427c34df885a028ee0f7cdddc981001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a92fdea71bf1aff4b05891a933a5e84"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a8a92fdea71bf1aff4b05891a933a5e84">ch_set_num_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_samples)</td></tr>
<tr class="memdesc:a8a92fdea71bf1aff4b05891a933a5e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sensor sample count directly.  <a href="ch__api_8c.html#a8a92fdea71bf1aff4b05891a933a5e84">More...</a><br /></td></tr>
<tr class="separator:a8a92fdea71bf1aff4b05891a933a5e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50819630a6c6dc83303090054413866d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a50819630a6c6dc83303090054413866d">ch_set_pmut_clock</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#aca9006600c4c232750578f7ed6c0416e">ch_pmut_clk_cfg_t</a> clock_cfg)</td></tr>
<tr class="memdesc:a50819630a6c6dc83303090054413866d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure ultrasound transducer clock.  <a href="ch__api_8c.html#a50819630a6c6dc83303090054413866d">More...</a><br /></td></tr>
<tr class="separator:a50819630a6c6dc83303090054413866d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0552ddb44341f86d96a9c5b4d9a1ca"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a5e0552ddb44341f86d96a9c5b4d9a1ca">ch_set_rtc</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a95396c4034eb6e41fffcfa7d9dbcd830">ch_rtc_src_t</a> rtc_source, uint16_t rtc_freq)</td></tr>
<tr class="memdesc:a5e0552ddb44341f86d96a9c5b4d9a1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the sensor real-time clock (RTC).  <a href="ch__api_8c.html#a5e0552ddb44341f86d96a9c5b4d9a1ca">More...</a><br /></td></tr>
<tr class="separator:a5e0552ddb44341f86d96a9c5b4d9a1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0abd6a2546fb40cb8fc9b832a6d63b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aba0abd6a2546fb40cb8fc9b832a6d63b">ch_set_rx_low_gain</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_samples)</td></tr>
<tr class="memdesc:aba0abd6a2546fb40cb8fc9b832a6d63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the receive low-gain sample count.  <a href="ch__api_8c.html#aba0abd6a2546fb40cb8fc9b832a6d63b">More...</a><br /></td></tr>
<tr class="separator:aba0abd6a2546fb40cb8fc9b832a6d63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0bbd8d9e2d5e1064fa8eb9ace180f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aee0bbd8d9e2d5e1064fa8eb9ace180f7">ch_set_rx_pretrigger</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t enable)</td></tr>
<tr class="memdesc:aee0bbd8d9e2d5e1064fa8eb9ace180f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable receive-only sensor pre-triggering.  <a href="ch__api_8c.html#aee0bbd8d9e2d5e1064fa8eb9ace180f7">More...</a><br /></td></tr>
<tr class="separator:aee0bbd8d9e2d5e1064fa8eb9ace180f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e112bfba8024d98de650b8f2184f9b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ae8e112bfba8024d98de650b8f2184f9b">ch_set_sample_interval</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t sample_interval)</td></tr>
<tr class="memdesc:ae8e112bfba8024d98de650b8f2184f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal sensing interval (deprecated).  <a href="ch__api_8c.html#ae8e112bfba8024d98de650b8f2184f9b">More...</a><br /></td></tr>
<tr class="separator:ae8e112bfba8024d98de650b8f2184f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183c63e3d6794848986656895b918d10"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a183c63e3d6794848986656895b918d10">ch_set_sample_window</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t start_sample, uint16_t num_samples)</td></tr>
<tr class="memdesc:a183c63e3d6794848986656895b918d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sample window for amplitude averaging.  <a href="ch__api_8c.html#a183c63e3d6794848986656895b918d10">More...</a><br /></td></tr>
<tr class="separator:a183c63e3d6794848986656895b918d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21906ecff45b2f188d8cf6b4b7b2e596"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a21906ecff45b2f188d8cf6b4b7b2e596">ch_set_target_int_counter</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t meas_hist, uint8_t thresh_count, uint8_t reset)</td></tr>
<tr class="memdesc:a21906ecff45b2f188d8cf6b4b7b2e596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target interrupt counter filter.  <a href="ch__api_8c.html#a21906ecff45b2f188d8cf6b4b7b2e596">More...</a><br /></td></tr>
<tr class="separator:a21906ecff45b2f188d8cf6b4b7b2e596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab462c77e75fd5b959eb3d49e918d49e8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ab462c77e75fd5b959eb3d49e918d49e8">ch_set_target_interrupt</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#ac2d701c38ecfaa08151839826667df20">ch_tgt_int_filter_t</a> tgt_int_filter)</td></tr>
<tr class="memdesc:ab462c77e75fd5b959eb3d49e918d49e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target interrupt filtering mode.  <a href="ch__api_8c.html#ab462c77e75fd5b959eb3d49e918d49e8">More...</a><br /></td></tr>
<tr class="separator:ab462c77e75fd5b959eb3d49e918d49e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035896185096ae0cc1e4c54db205d38c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a035896185096ae0cc1e4c54db205d38c">ch_set_trigger_type</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#aa18105c6986688c2700df504020bc2f2">ch_trigger_type_t</a> trig_type)</td></tr>
<tr class="memdesc:a035896185096ae0cc1e4c54db205d38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the trigger type for a sensor.  <a href="ch__api_8c.html#a035896185096ae0cc1e4c54db205d38c">More...</a><br /></td></tr>
<tr class="separator:a035896185096ae0cc1e4c54db205d38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ef44ae8846913a1caf11212bdef116"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#af6ef44ae8846913a1caf11212bdef116">ch_set_tx_length</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t tx_length)</td></tr>
<tr class="memdesc:af6ef44ae8846913a1caf11212bdef116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the ultrasound transmit pulse length.  <a href="ch__api_8c.html#af6ef44ae8846913a1caf11212bdef116">More...</a><br /></td></tr>
<tr class="separator:af6ef44ae8846913a1caf11212bdef116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505a6478f9e04cc440e3e3a05a565da9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a505a6478f9e04cc440e3e3a05a565da9">ch_ticks_to_usec</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_ticks)</td></tr>
<tr class="memdesc:a505a6478f9e04cc440e3e3a05a565da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert sensor RTC clock ticks to microseconds.  <a href="ch__api_8c.html#a505a6478f9e04cc440e3e3a05a565da9">More...</a><br /></td></tr>
<tr class="separator:a505a6478f9e04cc440e3e3a05a565da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5083e622e8cc3852a4193f6d8dce9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ade5083e622e8cc3852a4193f6d8dce9c">ch_trigger</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ade5083e622e8cc3852a4193f6d8dce9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger a measurement on one sensor.  <a href="ch__api_8c.html#ade5083e622e8cc3852a4193f6d8dce9c">More...</a><br /></td></tr>
<tr class="separator:ade5083e622e8cc3852a4193f6d8dce9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b585794c893ffa579775e060df36915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a2b585794c893ffa579775e060df36915">ch_trigger_soft</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a2b585794c893ffa579775e060df36915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger a measurement using software (SPI) interface.  <a href="ch__api_8c.html#a2b585794c893ffa579775e060df36915">More...</a><br /></td></tr>
<tr class="separator:a2b585794c893ffa579775e060df36915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace58b8e6d9e75d368ddcb69c99db2f3f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#ace58b8e6d9e75d368ddcb69c99db2f3f">ch_update_metadata_from_iq0</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a> *iq_data)</td></tr>
<tr class="memdesc:ace58b8e6d9e75d368ddcb69c99db2f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the metadata from the first IQ sample and update the device pointer.  <a href="ch__api_8c.html#ace58b8e6d9e75d368ddcb69c99db2f3f">More...</a><br /></td></tr>
<tr class="separator:ace58b8e6d9e75d368ddcb69c99db2f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8b3ddcc0010bf7bd1f7acc1fba4232"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a5d8b3ddcc0010bf7bd1f7acc1fba4232">ch_usec_to_cycles</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint32_t num_usec)</td></tr>
<tr class="memdesc:a5d8b3ddcc0010bf7bd1f7acc1fba4232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert microseconds to sensor cycles.  <a href="ch__api_8c.html#a5d8b3ddcc0010bf7bd1f7acc1fba4232">More...</a><br /></td></tr>
<tr class="separator:a5d8b3ddcc0010bf7bd1f7acc1fba4232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b94b407af323faa524787e399347594"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a6b94b407af323faa524787e399347594">ch_usec_to_ticks</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint32_t num_usec)</td></tr>
<tr class="memdesc:a6b94b407af323faa524787e399347594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert microseconds to sensor RTC clock ticks.  <a href="ch__api_8c.html#a6b94b407af323faa524787e399347594">More...</a><br /></td></tr>
<tr class="separator:a6b94b407af323faa524787e399347594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaaeecabbda3d134a582405cc2ec812"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#aabaaeecabbda3d134a582405cc2ec812">ch_watchdog_disable</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:aabaaeecabbda3d134a582405cc2ec812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable watchdog timer in sensor.  <a href="ch__api_8c.html#aabaaeecabbda3d134a582405cc2ec812">More...</a><br /></td></tr>
<tr class="separator:aabaaeecabbda3d134a582405cc2ec812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6703bf9649051f66c8c8acff42db746d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ch__api_8c.html#a6703bf9649051f66c8c8acff42db746d">ch_watchdog_enable</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a6703bf9649051f66c8c8acff42db746d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable watchdog timer in sensor.  <a href="ch__api_8c.html#a6703bf9649051f66c8c8acff42db746d">More...</a><br /></td></tr>
<tr class="separator:a6703bf9649051f66c8c8acff42db746d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Chirp SonicLib public API functions for using the Chirp ultrasonic sensor. </p>
<p>The user should not need to edit this file. This file relies on hardware interface functions declared in ch_bsp.h and supplied in the board support package (BSP) for the specific hardware platform being used. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a0705078371bc0ec34bd112b9a8ab1ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0705078371bc0ec34bd112b9a8ab1ebe">&#9670;&nbsp;</a></span>ch_check_program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_check_program </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check sensor firmware program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function confirms that the contents of the sensor's program memory match the firmware that was loaded into it, as specified during the <em><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize the device descriptor for a sensor.">ch_init()</a></em> call. The memory contents are read back from the sensor and are compared with the original byte values used to program the device.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if firmware matches the original program, or 1 if mismatch (error) </dd></dl>

</div>
</div>
<a id="a1a659b8b3969c202074c09bfb54ee9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a659b8b3969c202074c09bfb54ee9b7">&#9670;&nbsp;</a></span>ch_check_reset_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_check_reset_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a8579cbcd7ce6352dcb003317568123c9">ch_sensor_reset_state_t</a> *&#160;</td>
          <td class="paramname"><em>reset_state_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if sensor reset has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">reset_state_ptr</td><td>pointer to variable that will be updated with the ch_sensor_reset_state_t value. 0 = No Reset, 1 = Reset has occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero otherwise</dd></dl>
<p>This function calls the driver function to check if the sensor has reset.</p>
<p>This API can be called periodically in a measurement loop to check if the sensor was arbitrarily reset. If this reset event is detected during normal sensor operation the sensor has to be completely re-initialized similar to a power-on condition. </p>

</div>
</div>
<a id="a9bb8ea1621ef563bf279d7fedd1f16ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb8ea1621ef563bf279d7fedd1f16ef">&#9670;&nbsp;</a></span>ch_cycles_to_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_cycles_to_samples </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a86140657375a7e7c24ecf430da97c189">ch_odr_t</a>&#160;</td>
          <td class="paramname"><em>odr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert sensor cycles to samples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_cycles</td><td>number of cycles </td></tr>
    <tr><td class="paramname">odr</td><td>output data rate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sample periods.</dd></dl>
<p>This function takes a count of internal sensor cycles and converts it to the corresponding number of sample periods. The cycles are the same units used to specify measurement segment lengths.</p>
<p>The <em>odr</em> parameter is the current output data rate setting for the sensor. The ODR affects the timing between samples, and therefore the number of internal cycles per sample.</p>
<p>See also <em>ch_samples_to_cycles</em>, <em>ch_meas_get_odr</em>. </p>

</div>
</div>
<a id="acde0dc4f438051bd4fcfd19aad8b3f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde0dc4f438051bd4fcfd19aad8b3f9c">&#9670;&nbsp;</a></span>ch_cycles_to_usec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_cycles_to_usec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert sensor cycles to microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">num_cycles</td><td>number of cycles</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of microseconds.</dd></dl>
<p>This function takes a number of internal sensor cycles and converts it to the corresponding period of time specified in microseconds.</p>
<p>For ICU (Shasta architecture) sensors, <em>num_cycles</em> are in units of PMUT State Machine Clock (SMCLK) cycles. The SMCLK rate is 16 times the ultrasonic transducer acoustic operating frequency. These are the same units used to specify measurement transmit and count segment lengths.</p>
<p>For CH101 and CH201 (Whitney architecture) sensors, <em>num_cycles</em> are ultrasonic transducer cycles, so are 1/16 the corresponding ICU sensor value.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a5d8b3ddcc0010bf7bd1f7acc1fba4232" title="Convert microseconds to sensor cycles.">ch_usec_to_cycles()</a></em>. </p>

</div>
</div>
<a id="a87c0409b1443384afe601b8098aec6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c0409b1443384afe601b8098aec6ef">&#9670;&nbsp;</a></span>ch_enable_double_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_enable_double_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the double buffering mode. </p>
<p>IMPORTANT: This function is currently only supported with gpt and init firmware.</p>
<p>The ICU-X0201 sensors can be put into a double buffering mode which does the following:</p>
<ul>
<li>Splits the IQ buffer in two</li>
<li>Swaps which half of the buffer is written after every measurement</li>
</ul>
<p>This enables a measurement to be triggered before the readout of the previous measurement is finished (or even started). The disadvantage is that the maximum number of supported samples is reduced by a factor of 2.</p>
<p>You must not exceed the maximum number of supported samples, which can be found as ch_get_max_samples(...)/2. SonicLib will not check this!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>The device pointer </td></tr>
    <tr><td class="paramname">enable</td><td>Set to 1 to enable the double buffer mode or 0 to disable it</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success and non-zero otherwise </dd></dl>

</div>
</div>
<a id="a0bc64b2a0305210e1394331a6b2dd734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc64b2a0305210e1394331a6b2dd734">&#9670;&nbsp;</a></span>ch_enable_metadata_in_iq0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_enable_metadata_in_iq0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable placing metadata in the first IQ sample. </p>
<p>IMPORTANT: This function is currently only supported with gpt and init firmware.</p>
<p>The ICU-X0201 can be configured to place metadata in the first IQ sample, which is otherwise always read out as 0. If enabled, this will place the IQ buffer address as well as the last measurement index in the first IQ sample.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>The device pointer </td></tr>
    <tr><td class="paramname">enable</td><td>Set to 1 to enable metadata in IQ sample 0 or 0 to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success and non-zero otherwise </dd></dl>

</div>
</div>
<a id="a3fe624d21c6e4c116469570a5b46f70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe624d21c6e4c116469570a5b46f70f">&#9670;&nbsp;</a></span>ch_freerun_time_hop_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_freerun_time_hop_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable time-hopping on measure period freerunning mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful.</dd></dl>
<p>This function disable the time-hopping for a sensor operating in freerunning mode (<em>CH_MODE_FREERUN</em>).</p>
<dl class="section note"><dt>Note</dt><dd>This function has no effect for a sensor operating in one of the triggered modes</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a1698edd099e87aaa2787cda5f12e373f" title="Enable time-hopping on measure period freerunning mode.">ch_freerun_time_hop_enable()</a></em>, <em><a class="el" href="soniclib_8h.html#aaa6ab6e5862a95c8610a176bf3e88554" title="Get the internal sensing timing interval for a sensor, in RTC clock ticks.">ch_get_freerun_interval_ticks()</a></em>, <em><a class="el" href="soniclib_8h.html#a8d3ad9e2c87572430228205103a28927" title="Set the internal sensing interval for freerunning mode, in milliseconds.">ch_set_freerun_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#a3312f5018fc80ed86d32205efd643e48" title="Set the internal sensing interval for freerunning mode, in microseconds.">ch_set_freerun_interval_us()</a></em>, <em><a class="el" href="soniclib_8h.html#af210149982301db673e5ad03095d8b06" title="Set the internal sensing interval for freerunning mode, in RTC clock ticks.">ch_set_freerun_interval_ticks()</a></em>. </p>

</div>
</div>
<a id="a1698edd099e87aaa2787cda5f12e373f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1698edd099e87aaa2787cda5f12e373f">&#9670;&nbsp;</a></span>ch_freerun_time_hop_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_freerun_time_hop_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable time-hopping on measure period freerunning mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful.</dd></dl>
<p>This function enables the time-hopping for a sensor operating in freerunning mode (<em>CH_MODE_FREERUN</em>). The sensor will use its internal real-time clock (RTC) to wake and perform a measurement every <em>measure</em> interval plus a random delay to avoid coexistence with other sensors. Mean measure period is however equals to <em>measure</em> interval.</p>
<dl class="section note"><dt>Note</dt><dd>This function has no effect for a sensor operating in one of the triggered modes.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a3fe624d21c6e4c116469570a5b46f70f" title="Disable time-hopping on measure period freerunning mode.">ch_freerun_time_hop_disable()</a></em>, <em><a class="el" href="soniclib_8h.html#aaa6ab6e5862a95c8610a176bf3e88554" title="Get the internal sensing timing interval for a sensor, in RTC clock ticks.">ch_get_freerun_interval_ticks()</a></em>, <em><a class="el" href="soniclib_8h.html#a8d3ad9e2c87572430228205103a28927" title="Set the internal sensing interval for freerunning mode, in milliseconds.">ch_set_freerun_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#a3312f5018fc80ed86d32205efd643e48" title="Set the internal sensing interval for freerunning mode, in microseconds.">ch_set_freerun_interval_us()</a></em>, <em><a class="el" href="soniclib_8h.html#af210149982301db673e5ad03095d8b06" title="Set the internal sensing interval for freerunning mode, in RTC clock ticks.">ch_set_freerun_interval_ticks()</a></em>. </p>

</div>
</div>
<a id="ac05e1055eb673ae1c6e03d8d72046039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05e1055eb673ae1c6e03d8d72046039">&#9670;&nbsp;</a></span>ch_get_algo_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_algo_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>algo_cfg_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the measurement algorithm configuration data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">algo_cfg_ptr</td><td>pointer to a buffer to receive configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function reads the configuration data from an algorithm running on the ICU sensor. This interface is independent of the specific algorithm or configuration format.</p>
<p>Normally, this routine will only be used by special applications or libraries which interact with specific sensor firmware. It is not used directly in a typical application. </p>

</div>
</div>
<a id="a1e8e425d463961d442133253235c5a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8e425d463961d442133253235c5a41">&#9670;&nbsp;</a></span>ch_get_algo_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_algo_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicu__algo__info.html">ICU_ALGO_SHASTA_INFO</a> *&#160;</td>
          <td class="paramname"><em>algo_info_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the measurement algorithm information data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">algo_info_ptr</td><td>pointer to a ICU_ALGO_SHASTA_INFO structure to receive info</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function reads the information data from an algorithm running on the ICU sensor. This interface is independent of the specific algorithm that is being used.</p>
<p>Normally, this routine will only be used by special applications or libraries which interact with specific sensor firmware. It is not used directly in a typical application. </p>

</div>
</div>
<a id="a40e276c66c4a835c1146135580d7d5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e276c66c4a835c1146135580d7d5c7">&#9670;&nbsp;</a></span>ch_get_algo_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_algo_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>algo_out_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the measurement algorithm output data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">algo_out_ptr</td><td>pointer to a buffer to receive output data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function reads the output data from an algorithm running on the ICU sensor. This interface is independent of the specific algorithm or output format.</p>
<p>Normally, this routine will only be used by special applications or libraries which interact with specific sensor firmware. It is not used directly in a typical application. </p>

</div>
</div>
<a id="abfe62802f4bc1c41bc96d903e3aa323c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe62802f4bc1c41bc96d903e3aa323c">&#9670;&nbsp;</a></span>ch_get_algo_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_algo_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>algo_state_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the measurement algorithm state data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">algo_state_ptr</td><td>pointer to a buffer to receive state data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function reads the state data from an algorithm running on the ICU sensor. This interface is independent of the specific algorithm or state format.</p>
<p>Normally, this routine will only be used by special applications or libraries which interact with specific sensor firmware. It is not used directly in a typical application. </p>

</div>
</div>
<a id="ae45d31a610fa2b44fd72d0eb726f7ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45d31a610fa2b44fd72d0eb726f7ad0">&#9670;&nbsp;</a></span>ch_get_amp_thresh_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_amp_thresh_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__amp__thresh__t.html">ch_amp_thresh_t</a> *&#160;</td>
          <td class="paramname"><em>buf_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the amplitude measurement and threshold data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">buf_ptr</td><td>pointer to data buffer where amplitude and threshold data will be written </td></tr>
    <tr><td class="paramname">start_sample</td><td>starting sample number within measurement data (0 = start of data) </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples to read from sensor </td></tr>
    <tr><td class="paramname">mode</td><td>whether read should block (<em>CH_IO_MODE_BLOCK</em> (0) = blocking, <em>CH_IO_MODE_NONBLOCK</em> (1) = non-blocking)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>This function obtains specially formatted sample data from the sensor, in which both the amplitude and the detection threshold are reported for each sample in a measurement.</p>
<p>This function is similar to <em><a class="el" href="soniclib_8h.html#af95998b37600ae7ef3a2300c10519fdf" title="Get the raw amplitude measurement data from a sensor.">ch_get_amplitude_data()</a></em>, except that the data values each contains a 16-bit unsigned threshold value in addition to the 16-bit unsigned sample amplitude. The threshold value is the required amplitude at that sample offset to detect a target object, as set by <a class="el" href="ch__rangefinder_8c.html#a7e948bfbdc2cbca2f04bc97459541e5f" title="Set detection thresholds.">ch_set_thresholds()</a>. This output format may be useful in tuning and debugging the detection threshold values.</p>
<p>Each output sample consists of a <a class="el" href="structch__amp__thresh__t.html" title="Sensor combined amplitude + detection threshold sample value.">ch_amp_thresh_t</a> structure, containing one unsigned 16-bit integer value threshold value followed by one unsigned 16-bit amplitude value.</p>
<p>See <em><a class="el" href="soniclib_8h.html#af95998b37600ae7ef3a2300c10519fdf" title="Get the raw amplitude measurement data from a sensor.">ch_get_amplitude_data()</a></em> for more information on reading amplitude values. </p>

</div>
</div>
<a id="aa2ef517f154bb269d31fdf3f4e0cc7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ef517f154bb269d31fdf3f4e0cc7a2">&#9670;&nbsp;</a></span>ch_get_amplitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_amplitude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the measured amplitude from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amplitude value for most recent successful range reading</dd></dl>
<p>This function returns the amplitude value for the most recent successful range measurement by the sensor. The amplitude is representative of the incoming sound pressure. The value is expressed in internal sensor counts and is not calibrated to any standard units.</p>
<p>The amplitude value is not updated if a measurement cycle resulted in <em>CH_NO_TARGET</em>, as returned by <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor.">ch_get_range()</a></em>. </p>

</div>
</div>
<a id="aecd6ee85a061f71da4e98aab683fef5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd6ee85a061f71da4e98aab683fef5b">&#9670;&nbsp;</a></span>ch_get_amplitude_avg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_amplitude_avg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the averaged measured amplitude over the sample window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Average amplitude value for samples in current sample window</dd></dl>
<p>This function returns the average amplitude value for the most recent measurement cycle across the samples within the current sample window. The sample window is a subset of the overall sensor data, and is specified by the <em><a class="el" href="soniclib_8h.html#a183c63e3d6794848986656895b918d10" title="Set the sample window for amplitude averaging.">ch_set_sample_window()</a></em> function.</p>
<p>The amplitude is representative of the incoming sound pressure. The value is expressed in internal sensor counts and is not calibrated to any standard units.</p>
<dl class="section note"><dt>Note</dt><dd>Sample window averaging is only available when using special sensor firmware packages from Chirp. It is generally not available in General Purpose Rangefinding (GPR) firmware. </dd></dl>

</div>
</div>
<a id="a7f162a8dfb083614d26fc141561c0bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f162a8dfb083614d26fc141561c0bba">&#9670;&nbsp;</a></span>ch_get_amplitude_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_amplitude_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>buf_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the raw amplitude measurement data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">buf_ptr</td><td>pointer to data buffer where amplitude data will be written </td></tr>
    <tr><td class="paramname">start_sample</td><td>starting sample number within measurement data (0 = start of data) </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples to read from sensor </td></tr>
    <tr><td class="paramname">mode</td><td>whether read should block (<em>CH_IO_MODE_BLOCK</em> (0) = blocking, <em>CH_IO_MODE_NONBLOCK</em> (1) = non-blocking)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>The raw amplitude data are updated on every measurement cycle, even if no target was detected (i.e. even if <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor.">ch_get_range()</a></em> returns <em>CH_NO_TARGET</em>). (Note that this is different than the regular amplitude value, as returned by <em><a class="el" href="soniclib_8h.html#aa2ef517f154bb269d31fdf3f4e0cc7a2" title="Get the measured amplitude from a sensor.">ch_get_amplitude()</a></em>, which is <em>not</em> updated unless a target is detected.)</p>
<p>Each sample amplitude consists of one unsigned 16-bit integer value.</p>
<p>Amplitude values in the sensor are expressed only in internal ADC counts (least-significant bits, or LSBs) and are not calibrated to any standard units.</p>
<p>The number of samples available in each amplitude trace is determined by the maximum range setting for the device. If it is set to less than the maximum possible range, not all samples will contain valid data. To determine the number of active samples within the trace, use <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em>.</p>
<ul>
<li>To read all valid amplitude data, set <em>start_sample</em> to zero (0), and set <em>num_samples</em> to the value returned by <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em>.</li>
</ul>
<p>To determine what sample number corresponds to a physical distance, use <em><a class="el" href="soniclib_8h.html#aa256c720961a6d327c515da60d8071c2" title="Convert millimeters to sample count for a sensor.">ch_mm_to_samples()</a></em>.</p>
<p>To allow more flexibility in your application, the amplitude data readout from the device may be done in a non-blocking mode, by setting <em>mode</em> to <em>CH_IO_MODE_NONBLOCK</em> (1). In non-blocking mode, the I/O operation takes place using DMA access in the background. This function will return immediately, and a notification will later be issued when the amplitude has been read. To use the <em>non_block</em> option, the board support package (BSP) you are using must provide the <em><a class="el" href="chirp__bsp_8h.html#a620cdc037bcd92bde953270a8cb15fc6" title="Read bytes from an I2C slave, non-blocking.">chbsp_i2c_read_nb()</a></em> and <em>chbsp_i2c_read_mem_nb()</em> functions. To use non-blocking reads of the amplitude data, you must specify a callback routine that will be called when the amplitude read completes. See <em><a class="el" href="soniclib_8h.html#ae40302a26ef7dd9868f5c28bcfc15cea" title="Register non-blocking I/O complete callback routine for a group of sensors.">ch_io_complete_callback_set()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Non-blocking amplitude reads are only supported when using certain Chirp sensor firmware types which support direct readout of the amplitude data. Other firmware types read I/Q data and calculate the amplitudes as part of this function, and will require use of blocking mode (CH_IO_MODE_BLOCK). If non-blocking mode is specified when using sensor f/w that does not support it, this function will return an error.</dd></dl>
<p>Non-blocking reads are managed together for a group of sensors. To perform a non-blocking read:</p>
<ol type="1">
<li>Register a callback function using <em><a class="el" href="soniclib_8h.html#ae40302a26ef7dd9868f5c28bcfc15cea" title="Register non-blocking I/O complete callback routine for a group of sensors.">ch_io_complete_callback_set()</a></em>.</li>
<li>Define and initialize a handler for the DMA interrupts generated.</li>
<li>Synchronize with all sensors whose amplitude data should be read by waiting for all to indicate data ready.</li>
<li>Set up a non-blocking read on each sensor, using <em><a class="el" href="soniclib_8h.html#af95998b37600ae7ef3a2300c10519fdf" title="Get the raw amplitude measurement data from a sensor.">ch_get_amplitude_data()</a></em> with <em>mode</em> = <em>CH_IO_MODE_NONBLOCK</em> (1).</li>
<li>Start the non-blocking reads on all sensors in the group, using <em><a class="el" href="soniclib_8h.html#af7b5f63c32c49bf634a00fc6594e57bc" title="Start non-blocking I/O operation(s) for a group of sensors.">ch_io_start_nb()</a></em>.</li>
<li>Your callback function (set in step #1 above) will be called as each individual sensor's read completes. Your callback function should initiate any further processing of the I/Q data, possibly by setting a flag that will be checked from within the application's main execution loop. The callback function will likely be called at interrupt level, so the amount of processing within it should be kept to a minimum.</li>
</ol>
<p>For a CH101 sensor, up to 150 samples are taken during each measurement cycle; for a CH201 sensor, up to 450 samples are taken. So, a complete CH101 amplitude trace will contain up to 300 bytes of data (150 samples x 2 bytes per sample), and a CH201 amplitude trace may contain up to 900 bytes. The buffer specified by <em>buf_ptr</em> must be large enough to hold this amount of data.</p>
<p>When the amplitude data is read from the sensor, the additional time required to transfer the amplitude data over the SPI/I2C bus must be taken into account when planning how often the sensor can be read (sample interval).</p>
<dl class="section note"><dt>Note</dt><dd>It is important that any data I/O operations to or from the sensor, including reading the amplitude data, complete before a new measurement cycle is triggered, or the new measurement may be affected.</dd>
<dd>
This function only obtains the data from the most recently completed measurement cycle. It does not actually trigger a measurement. </dd></dl>

</div>
</div>
<a id="a4d6216f922775cbf3c571734e5287d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6216f922775cbf3c571734e5287d50">&#9670;&nbsp;</a></span>ch_get_bandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_bandwidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bandwidth of a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the operating frequency of the sensor. This is the primary frequency of the ultrasonic pulse that is emitted by the device when transmitting.</p>
<dl class="section return"><dt>Returns</dt><dd>Sensor bandwidth, in Hz, or 0 if error or bandwidth measurement is not available</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The bandwidth measurement is only available when using special sensor firmware packages from Chirp. It is generally not available in General Purpose Rangefinding (GPR) firmware. </dd></dl>

</div>
</div>
<a id="a37f7dd209fa4b04a5366147ab4ff67b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f7dd209fa4b04a5366147ab4ff67b2">&#9670;&nbsp;</a></span>ch_get_bus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_bus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the active SPI/I2C bus for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI/I2C bus index</dd></dl>
<p>This function returns the SPI/I2C bus index for a sensor device. This function may be used by board support package routines to determine the proper SPI/I2C bus to use for a specified sensor. </p>

</div>
</div>
<a id="a28fd271636e1b3aa3137cd812bd6b19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fd271636e1b3aa3137cd812bd6b19c">&#9670;&nbsp;</a></span>ch_get_cal_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_cal_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__cal__result__t.html">ch_cal_result_t</a> *&#160;</td>
          <td class="paramname"><em>cal_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the calibration result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">cal_ptr</td><td>pointer to <a class="el" href="structch__cal__result__t.html" title="Calibration result structure.">ch_cal_result_t</a> structure to receive calibration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function obtains the current calibration result from the sensor and returns them in a <a class="el" href="structch__cal__result__t.html" title="Calibration result structure.">ch_cal_result_t</a> structure specified by <em>cal_ptr</em>. The <a class="el" href="structch__cal__result__t.html" title="Calibration result structure.">ch_cal_result_t</a> structure contains DCO period and reverse drive cycles.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a0d01cb587379697f451459a2e4204d0c" title="Set the calibration result.">ch_set_cal_result()</a></em>. </p>

</div>
</div>
<a id="a2047b5e506b99131585bcfb4ce37b4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2047b5e506b99131585bcfb4ce37b4ac">&#9670;&nbsp;</a></span>ch_get_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__config__t.html">ch_config_t</a> *&#160;</td>
          <td class="paramname"><em>config_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current configuration settings for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">config_ptr</td><td>pointer to a <a class="el" href="structch__config__t.html" title="Combined configuration structure.">ch_config_t</a> structure to receive configuration values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>This function obtains the current configuration settings from the sensor and returns them in a <a class="el" href="structch__config__t.html" title="Combined configuration structure.">ch_config_t</a> structure, whose address is specified by <em>config_ptr</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The individual configuration values returned in the <a class="el" href="structch__config__t.html" title="Combined configuration structure.">ch_config_t</a> structure may also be obtained by using dedicated single-value functions. See <em><a class="el" href="soniclib_8h.html#acbd52987d0cfca5d0dec4f962ce15995" title="Get the current operating mode for a sensor.">ch_get_mode()</a></em>, <em><a class="el" href="soniclib_8h.html#a96b6bb2df00b9feb43955902c55835f7" title="Get the maximum range setting in mm for a sensor.">ch_get_max_range()</a></em>, <em><a class="el" href="soniclib_8h.html#a2f5c83e0d155e17ab8ac74951f44ea02" title="Get the internal sensing timing interval for a sensor, in milliseconds.">ch_get_freerun_interval()</a></em>, <em><a class="el" href="ch__rangefinder_8c.html#a48883557bd21adef2ea2621e4de824af" title="Get static target rejection range setting.">ch_get_static_range()</a></em>, and <em><a class="el" href="ch__rangefinder_8c.html#a9ea0971363f3a1c9fdc7e8f040489edd" title="Get detection thresholds.">ch_get_thresholds()</a></em>. </dd></dl>

</div>
</div>
<a id="a7747e4f758aa7d957d3e69a94ced2363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7747e4f758aa7d957d3e69a94ced2363">&#9670;&nbsp;</a></span>ch_get_cpu_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_get_cpu_frequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sensor CPU frequency, in Hz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sensor CPU frequency, in Hz</dd></dl>
<p>This function returns the processor speed, in Hz, for the micro-controller in the ultrasound sensor. </p>

</div>
</div>
<a id="aacf8233ee597b2795c3e478e70f3aefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf8233ee597b2795c3e478e70f3aefd">&#9670;&nbsp;</a></span>ch_get_data_ready_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_data_ready_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get data ready interrupt delay interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time, in milliseconds, that sensor will delay after measurement</dd></dl>
<p>This function returns the time, in milliseconds, that the sensor will wait between the completion of a measurement cycle and generating a data ready interrupt. The delay may be slightly greater than the value specified during <em><a class="el" href="soniclib_8h.html#a0fd13d9b1ba62dca747988e1b4abc1e0" title="Set data ready interrupt delay interval.">ch_set_data_ready_delay()</a></em>, due to the granularity of the sensor's wake cycle timer.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="a775e8fcdd9f1c1fa3dd90d87024101ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775e8fcdd9f1c1fa3dd90d87024101ab">&#9670;&nbsp;</a></span>ch_get_dev_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_dev_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device number (I/O index values) for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device number</dd></dl>
<p>This function returns the device number (I/O index) of the sensor within its sensor group. Normally, this also corresponds to the sensor's port number on the board, and is used for indexing arrays of pin definitions etc. within the board support package routines. </p>

</div>
</div>
<a id="a703c36ef2e38b7f9274c8e05a5109d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703c36ef2e38b7f9274c8e05a5109d72">&#9670;&nbsp;</a></span>ch_get_dev_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structch__dev__t.html">ch_dev_t</a>* ch_get_dev_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device descriptor pointer for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor for this group of sensors </td></tr>
    <tr><td class="paramname">dev_num</td><td>device number within sensor group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</dd></dl>
<p>This function returns the address of the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> device descriptor for a certain sensor in a sensor group. The sensor is identified within the group by the <em>dev_num</em> device number. </p>

</div>
</div>
<a id="a2f5c83e0d155e17ab8ac74951f44ea02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5c83e0d155e17ab8ac74951f44ea02">&#9670;&nbsp;</a></span>ch_get_freerun_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_freerun_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the internal sensing timing interval for a sensor, in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interval between samples (in ms), or 0 if device is not in free-running mode</dd></dl>
<p>This function returns the interval between measurements, in milliseconds, for a sensor operating in free-running mode. If the sensor is in a different operating mode (e.g. a triggered mode), zero is returned.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a94c77bb8b753ccc41de9b11f316e9c7e" title="Get the internal sensing timing interval for a sensor, in microseconds.">ch_get_freerun_interval_us()</a></em>, <em><a class="el" href="soniclib_8h.html#aaa6ab6e5862a95c8610a176bf3e88554" title="Get the internal sensing timing interval for a sensor, in RTC clock ticks.">ch_get_freerun_interval_ticks()</a></em>. </p>

</div>
</div>
<a id="aaa6ab6e5862a95c8610a176bf3e88554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6ab6e5862a95c8610a176bf3e88554">&#9670;&nbsp;</a></span>ch_get_freerun_interval_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_freerun_interval_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the internal sensing timing interval for a sensor, in RTC clock ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interval between measurements (in sensor RTC clock periods), or 0 if device is not in free-running mode</dd></dl>
<p>This function returns the interval between measurements, in sensor RTC clock periods, for a sensor operating in free-running mode. If the sensor is in a different operating mode (e.g. a triggered mode), zero is returned.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a94c77bb8b753ccc41de9b11f316e9c7e" title="Get the internal sensing timing interval for a sensor, in microseconds.">ch_get_freerun_interval_us()</a></em>, <em><a class="el" href="soniclib_8h.html#aaa6ab6e5862a95c8610a176bf3e88554" title="Get the internal sensing timing interval for a sensor, in RTC clock ticks.">ch_get_freerun_interval_ticks()</a></em>. </p>

</div>
</div>
<a id="a94c77bb8b753ccc41de9b11f316e9c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c77bb8b753ccc41de9b11f316e9c7e">&#9670;&nbsp;</a></span>ch_get_freerun_interval_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_get_freerun_interval_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the internal sensing timing interval for a sensor, in microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interval between samples (in ms), or 0 if device is not in free-running mode</dd></dl>
<p>This function returns the interval between measurements, in milliseconds, for a sensor operating in free-running mode. If the sensor is in a different operating mode (e.g. a triggered mode), zero is returned.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a94c77bb8b753ccc41de9b11f316e9c7e" title="Get the internal sensing timing interval for a sensor, in microseconds.">ch_get_freerun_interval_us()</a></em>, <em><a class="el" href="soniclib_8h.html#aaa6ab6e5862a95c8610a176bf3e88554" title="Get the internal sensing timing interval for a sensor, in RTC clock ticks.">ch_get_freerun_interval_ticks()</a></em>. </p>

</div>
</div>
<a id="a7ae60d24c0b1d0fb5f06e2449c0fa149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae60d24c0b1d0fb5f06e2449c0fa149">&#9670;&nbsp;</a></span>ch_get_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_get_frequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the operating frequency of a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the acoustic operating frequency of the sensor. This is the primary frequency of the ultrasonic pulse that is emitted by the device when transmitting.</p>
<p>Normally, the returned operating frequency value is the natural resonant frequency for the sensor. However, if the frequency has been changed by using <em><a class="el" href="soniclib_8h.html#a5c6b0cc10159a9a9bb4dd74f38384d3a" title="Set the operating frequency of a sensor.">ch_set_frequency()</a></em> or <em><a class="el" href="soniclib_8h.html#a5c373443ede97b6665a9919b23074328" title="Set the operating frequency for a group of sensors.">ch_group_set_frequency()</a></em>, the returned value will be the adjusted operating frequency.</p>
<dl class="section return"><dt>Returns</dt><dd>Acoustic operating frequency, in Hz </dd></dl>

</div>
</div>
<a id="ac4a2126fda5645c1be134c2187cac61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a2126fda5645c1be134c2187cac61f">&#9670;&nbsp;</a></span>ch_get_fw_version_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ch_get_fw_version_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the firmware version description string for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to character string describing sensor firmware version</dd></dl>
<p>This function returns a pointer to a string that describes the sensor firmware being used on the device. </p>

</div>
</div>
<a id="ab5496937b5fae4e2c04ff2fa23ed9fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5496937b5fae4e2c04ff2fa23ed9fbf">&#9670;&nbsp;</a></span>ch_get_i2c_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_i2c_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the active I2C address for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I2C address, or 0 if error</dd></dl>
<p>This function returns the currently active I2C address for a CHx01 sensor device. This function may be used by board support package routines to determine the proper I2C address to use for a specified sensor.</p>
<p>Zero is returned if this function is called for ICU sensors, which use a SPI bus interface. </p>

</div>
</div>
<a id="a0b3b587cdcbe5917de925f5b8fa47888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3b587cdcbe5917de925f5b8fa47888">&#9670;&nbsp;</a></span>ch_get_interrupt_drive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="soniclib_8h.html#a3406ad6d96900bf23674fc44468caf5d">ch_interrupt_drive_t</a> ch_get_interrupt_drive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pulse interrupt drive setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CH_INTERRUPT_DRIVE_OPEN_DRAIN if interrupt uses open drain drive, CH_INTERRUPT_DRIVE_PUSH_PULL if push pull drive</dd></dl>
<p>This function returns the current setting for interrupt drive (open drain or push pull).</p>
<dl class="section note"><dt>Note</dt><dd>CH101 and CH201 sensors always use active-high, pull low interrupt drive for normal sensor interrupts, so this routine will always return CH_INTERRUPT_DRIVE_OPEN_DRAIN. </dd></dl>

</div>
</div>
<a id="a3692aeb8fee72b3cc2825547261b1777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3692aeb8fee72b3cc2825547261b1777">&#9670;&nbsp;</a></span>ch_get_interrupt_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="soniclib_8h.html#a4962ca7e356fbfa6e40863fe5abf519c">ch_interrupt_mode_t</a> ch_get_interrupt_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pulse interrupt mode setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CH_INTERRUPT_MODE_PULSE if interrupt uses pulse mode, CH_INTERRUPT_MODE_LATCH if latching mode</dd></dl>
<p>This function returns the current setting for interrupt mode (pulsed or latching).</p>
<dl class="section note"><dt>Note</dt><dd>CH101 and CH201 sensors always use pulse interrupt mode for normal sensor interrupts, so this routine will always return CH_INTERRUPT_MODE_PULSE. </dd></dl>

</div>
</div>
<a id="acde1c47209421107f576b7e01b6fa5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde1c47209421107f576b7e01b6fa5e8">&#9670;&nbsp;</a></span>ch_get_iq_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_iq_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a> *&#160;</td>
          <td class="paramname"><em>buf_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the raw I/Q measurement data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">buf_ptr</td><td>pointer to data buffer where I/Q data will be written </td></tr>
    <tr><td class="paramname">start_sample</td><td>starting sample number within measurement data (0 = start of data) </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples to read from sensor </td></tr>
    <tr><td class="paramname">mode</td><td>whether I/Q read should block (<em>CH_IO_MODE_BLOCK</em> (0) = blocking, <em>CH_IO_MODE_NONBLOCK</em> (1) = non-blocking)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>This function reads the raw I/Q measurement data from the sensor. The I/Q data set includes a discrete pair of values for each of the samples that make up a full measurement cycle. Each individual sample is reported as a pair of values, I and Q, in a quadrature format. The I/Q values may be used to calculate the relative amplitude of the measured ultrasound signal.</p>
<p>The contents of the I/Q trace are updated on every measurement cycle, even if no target was detected (i.e. even if <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor.">ch_get_range()</a></em> returns <em>CH_NO_TARGET</em>). (Note that this is different than the regular amplitude value, as returned by <em><a class="el" href="soniclib_8h.html#aa2ef517f154bb269d31fdf3f4e0cc7a2" title="Get the measured amplitude from a sensor.">ch_get_amplitude()</a></em>, which is <em>not</em> updated unless a target is detected.)</p>
<p>Each sample I/Q pair consists of two signed 16-bit integers and is described by the <em><a class="el" href="structch__iq__sample__t.html" title="Sensor I/Q data value.">ch_iq_sample_t</a></em> structure. To convert any given pair of I/Q values to the amplitude value for that sample, square both I and Q, and take the square root of the sum: </p><p class="formulaDsp">
\[Amp_n = \sqrt{(I_n)^2 + (Q_n)^2}\]
</p>
<p> Amplitude values in the sensor are expressed only in internal ADC counts (least-significant bits, or LSBs) and are not calibrated to any standard units.</p>
<p>The number of samples used in each I/Q trace is determined by the maximum range setting for the device. If it is set to less than the maximum possible range, not all samples will contain valid data. To determine the number of active samples within the trace, use <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em>.</p>
<ul>
<li>To read all valid I/Q data, set <em>start_sample</em> to zero (0), and set <em>num_samples</em> to the value returned by <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em>.</li>
</ul>
<p>To determine what sample number corresponds to a physical distance, use <em><a class="el" href="soniclib_8h.html#aa256c720961a6d327c515da60d8071c2" title="Convert millimeters to sample count for a sensor.">ch_mm_to_samples()</a></em>.</p>
<p>To allow more flexibility in your application, the I/Q data readout from the device may be done in a non-blocking mode, by setting <em>mode</em> to <em>CH_IO_MODE_NONBLOCK</em> (1). In non-blocking mode, the I/O operation takes place using DMA access in the background. This function will return immediately, and a notification will later be issued when the I/Q has been read. To use the <em>non_block</em> option, the board support package (BSP) you are using must provide the <em><a class="el" href="chirp__bsp_8h.html#a620cdc037bcd92bde953270a8cb15fc6" title="Read bytes from an I2C slave, non-blocking.">chbsp_i2c_read_nb()</a></em> and <em>chbsp_i2c_read_mem_nb()</em> functions. To use non-blocking reads of the I/Q data, you must specify a callback routine that will be called when the I/Q read completes. See <em><a class="el" href="soniclib_8h.html#ae40302a26ef7dd9868f5c28bcfc15cea" title="Register non-blocking I/O complete callback routine for a group of sensors.">ch_io_complete_callback_set()</a></em>.</p>
<p>Non-blocking reads are managed together for a group of sensors. To perform a non-blocking read:</p>
<ol type="1">
<li>Register a callback function using <em><a class="el" href="soniclib_8h.html#ae40302a26ef7dd9868f5c28bcfc15cea" title="Register non-blocking I/O complete callback routine for a group of sensors.">ch_io_complete_callback_set()</a></em>.</li>
<li>Define and initialize a handler for the DMA interrupts generated.</li>
<li>Synchronize with all sensors whose I/Q data should be read by waiting for all to indicate data ready.</li>
<li>Set up a non-blocking read on each sensor, using <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor.">ch_get_iq_data()</a></em> with <em>mode</em> = <em>CH_IO_MODE_NONBLOCK</em> (1).</li>
<li>Start the non-blocking reads on all sensors in the group, using <em><a class="el" href="soniclib_8h.html#af7b5f63c32c49bf634a00fc6594e57bc" title="Start non-blocking I/O operation(s) for a group of sensors.">ch_io_start_nb()</a></em>.</li>
<li>Your callback function (set in step #1 above) will be called as each individual sensor's read completes. Your callback function should initiate any further processing of the I/Q data, possibly by setting a flag that will be checked from within the application's main execution loop. The callback function will likely be called at interrupt level, so the amount of processing within it should be kept to a minimum.</li>
</ol>
<p>For a CH101 sensor, up to 150 samples are taken during each measurement cycle; for a CH201 sensor, up to 450 samples are taken. So, a complete CH101 I/Q trace will contain up to 600 bytes of data (150 samples x 4 bytes per sample), and a CH201 I/Q trace may contain up to 1800 bytes. The buffer specified by <em>buf_ptr</em> must be large enough to hold this amount of data.</p>
<p>When the I/Q data is read from the sensor, the additional time required to transfer the I/Q data over the SPI/I2C bus must be taken into account when planning how often the sensor can be read (sample interval).</p>
<dl class="section note"><dt>Note</dt><dd>It is important that any data I/O operations to or from the sensor, including reading the I/Q data, complete before a new measurement cycle is triggered, or the new measurement may be affected.</dd>
<dd>
This function only obtains the data from the most recently completed measurement cycle. It does not actually trigger a measurement. </dd></dl>

</div>
</div>
<a id="a96b6bb2df00b9feb43955902c55835f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b6bb2df00b9feb43955902c55835f7">&#9670;&nbsp;</a></span>ch_get_max_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_max_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum range setting in mm for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum range setting, in millimeters</dd></dl>
<p>This function returns the current maximum detection range setting for the sensor, in millimeters.</p>
<p>For ICU sensors, this function always returns the values for the default measurement definition. To specify which measurement to query, use the <em><a class="el" href="soniclib_8h.html#acd7763faeec4c696c10410544cb01365" title="Get the maximum range setting in mm for a specific measurement.">ch_meas_get_max_range()</a></em> function.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em>, <em><a class="el" href="soniclib_8h.html#a2047b5e506b99131585bcfb4ce37b4ac" title="Get current configuration settings for a sensor.">ch_get_config()</a></em>. </p>

</div>
</div>
<a id="a7eb50e63f45eee386a19cd9ef12c8de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb50e63f45eee386a19cd9ef12c8de6">&#9670;&nbsp;</a></span>ch_get_max_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_max_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum possible sample count per measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum sample count for this device and firmware</dd></dl>
<p>This function returns the maximum number of samples that can be included in a measurement. This maximum sample count will vary depending on the sensor device (CH201 devices will have higher sample counts than CH101 devices) and by the specific sensor firmware that is being used.</p>
<p>To get the number of these possible samples that are currently active (based on the maximum range setting), use <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em>. </p>

</div>
</div>
<a id="a0894c6a31cecc608ab6c457f918abe09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0894c6a31cecc608ab6c457f918abe09">&#9670;&nbsp;</a></span>ch_get_mfg_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_mfg_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__mfg__info__t.html">ch_mfg_info_t</a> *&#160;</td>
          <td class="paramname"><em>info_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get manufacturing information for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">info_ptr</td><td>pointer to <a class="el" href="structch__mfg__info__t.html" title="Sensor manufacturing info.">ch_mfg_info_t</a> structure to be updated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets fields in a <em><a class="el" href="structch__mfg__info__t.html" title="Sensor manufacturing info.">ch_mfg_info_t</a></em> structure with manufacturing information for the specific sensor device. These fields include:</p><ul>
<li>mfg_site - manufacturing location where sensor was made</li>
<li>mfg_year - year when sensor was made</li>
<li>mfg_week - work-week number within the year when sensor was made</li>
<li>product_code - numeric identifier for the sensor product type</li>
<li>package_code - numeric identifier for the sensor package type</li>
<li>module_code - numeric identifier for the sensor module type</li>
<li>mems_code - numeric identifier for the MEMS ultrasonic transducer type</li>
</ul>
<p>See also <em><a class="el" href="soniclib_8h.html#a76945903073c49706d025c7679b07059" title="Get the unique Sensor ID String for a sensor.">ch_get_sensor_id()</a></em>, <em><a class="el" href="soniclib_8h.html#ad57e731b7b145a37aa7685a2fbe320c9" title="Get part number for a sensor.">ch_get_part_number()</a></em>. </p>

</div>
</div>
<a id="acbd52987d0cfca5d0dec4f962ce15995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd52987d0cfca5d0dec4f962ce15995">&#9670;&nbsp;</a></span>ch_get_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">ch_mode_t</a> ch_get_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current operating mode for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sensor operating mode</dd></dl>
<p>This function returns the current operating mode for the sensor, one of:</p><ul>
<li><em>CH_MODE_IDLE</em> - low power idle mode, no measurements take place</li>
<li><em>CH_MODE_FREERUN</em> - free-running mode, sensor uses internal clock to wake and measure</li>
<li><em>CH_MODE_TRIGGERED_TX_RX</em> - hardware-triggered, sensor both transmits and receives</li>
<li><em>CH_MODE_TRIGGERED_RX_ONLY</em> - hardware triggered, sensor only receives </li>
</ul>

</div>
</div>
<a id="a2fd0582578cba1dff9d781a4ce516e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd0582578cba1dff9d781a4ce516e84">&#9670;&nbsp;</a></span>ch_get_next_buf_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_next_buf_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address of the IQ buffer that will be written by the next measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function returns the address of the buffer that will be written by the next measurement. This is useful in the double buffer mode.</p>
<p>See also <a class="el" href="soniclib_8h.html#ace58b8e6d9e75d368ddcb69c99db2f3f" title="Extract the metadata from the first IQ sample and update the device pointer.">ch_update_metadata_from_iq0()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is only available for ICU sensors. </dd></dl>

</div>
</div>
<a id="a2806d7b51748c5dcd870d7c3c21b222a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2806d7b51748c5dcd870d7c3c21b222a">&#9670;&nbsp;</a></span>ch_get_num_output_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_num_output_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of valid output samples in last measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of output samples in last measurement</dd></dl>
<p>This function returns the number of valid samples in the most recently completed measurement, as reported by the sensor. The sensor will be queried dynamically over the I/O bus interface.</p>
<p>In general, this number will match the configured sample count for the last measurement, which can be obtained using <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em>. That function is recommended for typical use, because it requires no additional I/O to the sensor.</p>
<dl class="section note"><dt>Note</dt><dd>For CH101 and CH201 sensors, this function will always return the configured sample count, not a dynamic value from the sensor (i.e. it is identical to <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em>).</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em>, <em><a class="el" href="soniclib_8h.html#a9bf5688451893bddde1d3623dd34f48d" title="Get the number of samples per measurement cycle for a specific measurement.">ch_meas_get_num_samples()</a></em>. </p>

</div>
</div>
<a id="ae0a95de2412e067451248211003e1240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a95de2412e067451248211003e1240">&#9670;&nbsp;</a></span>ch_get_num_ports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_num_ports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of sensor ports (possible sensors) in a sensor group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor for this group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of ports (possible sensors) in the sensor group</dd></dl>
<p>This function returns the maximum number of possible sensors within a sensor group. Typically, the number of sensors is limited by the physical connections on the board being used, so the number of sensor ports on the board is returned by this function. </p>

</div>
</div>
<a id="a53cba94e769a33dfd290555efb412dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cba94e769a33dfd290555efb412dda">&#9670;&nbsp;</a></span>ch_get_num_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_num_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of samples per measurement cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of samples per measurement cycle</dd></dl>
<p>This function returns the configured number of samples which the Chirp sensor will obtain during each measurement cycle. The number of samples directly corresponds to the range at which the sensor can detect, so this value is determined by the current maximum range setting for the sensor.</p>
<p>For ICU sensors, this function always returns the configured value for the last completed measurement. To specify which measurement to indicate, use the <em><a class="el" href="soniclib_8h.html#a9bf5688451893bddde1d3623dd34f48d" title="Get the number of samples per measurement cycle for a specific measurement.">ch_meas_get_num_samples()</a></em> function.</p>
<p>ICU sensors can report the number of output samples directly. To obtain the number of samples in the last measurement as reported by the sensor itself, use <em><a class="el" href="soniclib_8h.html#a2806d7b51748c5dcd870d7c3c21b222a" title="Get the number of valid output samples in last measurement.">ch_get_num_output_samples()</a></em>. Normally, this will be the same as the configured value reported by this routine.</p>
<p>See also <em>ch_set_num_samples</em>, <em>ch_meas_get_num_samples</em>, <em><a class="el" href="soniclib_8h.html#a96b6bb2df00b9feb43955902c55835f7" title="Get the maximum range setting in mm for a sensor.">ch_get_max_range()</a></em>. </p>

</div>
</div>
<a id="ad57e731b7b145a37aa7685a2fbe320c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57e731b7b145a37aa7685a2fbe320c9">&#9670;&nbsp;</a></span>ch_get_part_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_part_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get part number for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer part number</dd></dl>
<p>This function returns the TDK/Chirp part number for the specified device. The part number is a simple integer value, for example 101 for a CH101 sensor, or 20201 for an ICU20201 sensor. </p>

</div>
</div>
<a id="a80da2e1dc19b0f3a40c775b818ead954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80da2e1dc19b0f3a40c775b818ead954">&#9670;&nbsp;</a></span>ch_get_pmut_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="soniclib_8h.html#aca9006600c4c232750578f7ed6c0416e">ch_pmut_clk_cfg_t</a> ch_get_pmut_clock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ultrasound transducer clock configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function returns the current configuration setting for the PMUT clock.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a50819630a6c6dc83303090054413866d" title="Configure ultrasound transducer clock.">ch_set_pmut_clock()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>On CH101 and CH201 sensors, this function always returns CH_PMUT_CLK_DEFAULT. </dd></dl>

</div>
</div>
<a id="a5cbb4847d39cc9418373b6d1ac8dadc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbb4847d39cc9418373b6d1ac8dadc6">&#9670;&nbsp;</a></span>ch_get_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_get_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a1b137d77afad79d536e322eacdfebd0c">ch_range_t</a>&#160;</td>
          <td class="paramname"><em>range_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the measured range from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">range_type</td><td>the range type to be reported (e.g. one-way vs. round-trip)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Range in millimeters times 32, or <em>CH_NO_TARGET</em> (0xFFFFFFFF) if no target was detected, or 0 if error</dd></dl>
<p>This function reads the measurement result registers from the sensor and then computes the actual range. It should be called after the sensor has indicated that a measurement cycle is complete by generating a signal on the INT line. (Typically, this will be set up by an interrupt handler associated with that input line.)</p>
<p>The <em>range_type</em> parameter indicates whether the measurement is based on the one-way or round-trip distance to/from a target, or the direct distance between two sensors operating in pitch-catch mode. The possible values are:</p><ul>
<li><em>CH_RANGE_ECHO_ONE_WAY</em> - gets full pulse/echo round-trip distance, then divides by 2</li>
<li><em>CH_RANGE_ECHO_ROUND_TRIP</em> - full pulse/echo round-trip distance</li>
<li><em>CH_RANGE_DIRECT</em> - for receiving sensor in pitch-catch mode (one-way)</li>
</ul>
<p>This function returns the measured range as a 32-bit integer. For maximum precision, the range value is returned in a fixed-point format with 5 fractional bits. So, the return value is the number of millimeters times 32. Divide the value by 32 (shift right 5 bits) to get whole mm, or use floating point (i.e. divide by 32.0f) to preserve the full sub-millimeter precision.</p>
<p>If the sensor did not successfully find the range of a target during the most recent measurement, the returned range value will be <em>CH_NO_TARGET</em>. If an error occurs when getting or calculating the range, zero (0) will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>This function only reports the results from the most recently completed measurement cycle. It does not actually trigger a measurement.</dd>
<dd>
The <em>range_type</em> parameter only controls how this function interprets the results from the measurement cycle. It does not change the sensor mode. </dd></dl>

</div>
</div>
<a id="af1629cdf88732e9e3d4bfbe422900220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1629cdf88732e9e3d4bfbe422900220">&#9670;&nbsp;</a></span>ch_get_rtc_cal_pulselength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_rtc_cal_pulselength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the real-time clock calibration pulse length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTC pulse length, in ms</dd></dl>
<p>This function returns the length (duration), in milliseconds, of the the real-time clock (RTC) calibration pulse used for the sensor. The pulse is applied to the sensor's INT line during <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em> to calibrate the sensor's internal clock. The pulse length is specified by the board support package during the <em><a class="el" href="soniclib_8h.html#aaedc8fdec2ebbecb1b89c6856f63bd60" title="Initialize the group descriptor for a group of sensors.">ch_group_init()</a></em> function.</p>
<p>The RTC calibration pulse length is used internally in calculations that convert between time and distance. </p>

</div>
</div>
<a id="aa365c564c65b5aa97ca9dca28711807b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa365c564c65b5aa97ca9dca28711807b">&#9670;&nbsp;</a></span>ch_get_rtc_cal_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_rtc_cal_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the real-time clock calibration value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTC calibration value</dd></dl>
<p>This function returns the real-time clock (RTC) calibration value read from the sensor during <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em>. The RTC calibration value is calculated by the sensor during the RTC calibration pulse, and it is used internally in calculations that convert between time and distance. </p>

</div>
</div>
<a id="a3157748b36bfb84930fd16ab06570eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3157748b36bfb84930fd16ab06570eb7">&#9670;&nbsp;</a></span>ch_get_rtc_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_rtc_frequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sensor real-time clock (RTC) frequency, in Hz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sensor RTC frequency, in Hz</dd></dl>
<p>This function returns the real-time clock (RTC) frequency, in Hz, for the micro-controller in the ultrasound sensor. </p>

</div>
</div>
<a id="a1379e10c0c9af1f916ca08092916227b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1379e10c0c9af1f916ca08092916227b">&#9670;&nbsp;</a></span>ch_get_rx_low_gain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_rx_low_gain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the receive low-gain sample count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of samples that have low gain at beginning of measurement</dd></dl>
<p>This function gets the receive (rx) low-gain range from the sensor. The low-gain range is a count of samples at the beginning of a measurement that will have lower gain applied during the ultrasound receive operation.</p>
<p>The returned low-gain range is either the default value for the sensor firmware, or a value previously set by <em><a class="el" href="soniclib_8h.html#aba0abd6a2546fb40cb8fc9b832a6d63b" title="Set the receive low-gain sample count.">ch_set_rx_low_gain()</a></em>.</p>
<p>To convert the returned sample count to a physical distance, use <em><a class="el" href="soniclib_8h.html#a290f3e5de2ee174e37ff4522df51d376" title="Convert sample count to millimeters for a sensor.">ch_samples_to_mm()</a></em>.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#aba0abd6a2546fb40cb8fc9b832a6d63b" title="Set the receive low-gain sample count.">ch_set_rx_low_gain()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only available in CH201 sensor firmware. </dd></dl>

</div>
</div>
<a id="a295d2393cc610d13bfa63987de35c303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295d2393cc610d13bfa63987de35c303">&#9670;&nbsp;</a></span>ch_get_rx_pretrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_rx_pretrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get receive-only sensor pre-triggering setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> group descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current state (enabled or disabled) of pre-triggering receive-only sensors.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#aee0bbd8d9e2d5e1064fa8eb9ace180f7" title="Enable/disable receive-only sensor pre-triggering.">ch_set_rx_pretrigger()</a></em>.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if receive pre-triggering is enabled, 0 if disabled </dd></dl>

</div>
</div>
<a id="a973ae35d4ac7064704da5bcf2d05f6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973ae35d4ac7064704da5bcf2d05f6ef">&#9670;&nbsp;</a></span>ch_get_sample_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_sample_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the internal sensing timing interval for a sensor (deprecated). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interval between samples (in ms), or 0 if device is not in free-running mode</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is DEPRECATED and is provided only for backwards compatiblity. New applications should use the equivalent <em><a class="el" href="soniclib_8h.html#a2f5c83e0d155e17ab8ac74951f44ea02" title="Get the internal sensing timing interval for a sensor, in milliseconds.">ch_get_freerun_interval()</a></em> function.</dd></dl>
<p>This function returns the interval between measurements, in milliseconds, for a sensor operating in free-running mode. If the sensor is in a different operating mode (e.g. a triggered mode), zero is returned. </p>

</div>
</div>
<a id="a56c552c6a09c2400766ee329efcaeaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c552c6a09c2400766ee329efcaeaa1">&#9670;&nbsp;</a></span>ch_get_sample_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_sample_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>start_sample_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>num_samples_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sample window for amplitude averaging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">start_sample_ptr</td><td>pointer to variable to be updated with sample number of first sample </td></tr>
    <tr><td class="paramname">num_samples_ptr</td><td>pointer to variable to be updated with number of samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero if error</dd></dl>
<p>This function obtains the current range of samples that are included in the sample window used for amplitude averaging. <em>start_sample_ptr</em> is a pointer to a variable that will be updated with the number of the first sample in the sample window. <em>num_samples_ptr</em> is a pointer to a variable that will be updated with the the total number of samples in the sample window.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#aecd6ee85a061f71da4e98aab683fef5b" title="Get the averaged measured amplitude over the sample window.">ch_get_amplitude_avg()</a></em>, <em><a class="el" href="soniclib_8h.html#a183c63e3d6794848986656895b918d10" title="Set the sample window for amplitude averaging.">ch_set_sample_window()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Internal sample window averaging is available when using special sensor firmware packages from Chirp. In General Purpose Rangefinding (GPR) firmware, a software only implementation is used. </dd></dl>

</div>
</div>
<a id="ab88053b2f8918538fc3c2c8681e4269b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88053b2f8918538fc3c2c8681e4269b">&#9670;&nbsp;</a></span>ch_get_scale_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_scale_factor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the amplitude scale factor of a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the amplitude scale factor of the sensor. The scale factor is an internal value generated during the initialization of the device.</p>
<dl class="section return"><dt>Returns</dt><dd>Scale factor value, or 0 if error or not available</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The scale factor value is only available when using special sensor firmware packages from Chirp. </dd></dl>

</div>
</div>
<a id="a76945903073c49706d025c7679b07059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76945903073c49706d025c7679b07059">&#9670;&nbsp;</a></span>ch_get_sensor_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ch_get_sensor_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique Sensor ID String for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to character string containing unique sensor ID</dd></dl>
<p>This function returns a pointer to a string that contains a unique identifier for the sensor device. The ID string consists of 7 ascii alpha-numeric characters, terminated by a null byte (so total size is 8 bytes). <em>CH_SENSOR_ID_LENGTH</em>, is defined as the length of the string, including the null terminator.</p>
<p>The first three bytes in the ID string specify the Production Lot. The remaining four bytes specify the alphanumeric Serial Number within that production lot.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a0894c6a31cecc608ab6c457f918abe09" title="Get manufacturing information for a sensor.">ch_get_mfg_info()</a></em>, <em>ch_get_fw_version_string</em>. </p>

</div>
</div>
<a id="abf08ef3543bda6135f4f5663283241cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf08ef3543bda6135f4f5663283241cf">&#9670;&nbsp;</a></span>ch_get_target_int_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_target_int_counter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>meas_hist_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>thresh_count_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>reset_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the target interrupt counter filter settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_hist_ptr</td><td>pointer to location to receive count of measurements in filter history </td></tr>
    <tr><td class="paramname">thresh_count_ptr</td><td>pointer to location to receive number of target detections req'd </td></tr>
    <tr><td class="paramname">reset_ptr</td><td>pointer to location to receive target counter reset setting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function obtains the current target counter filter settings used to control sensor interrupts. This filter is enabled by calling the <em><a class="el" href="soniclib_8h.html#ab462c77e75fd5b959eb3d49e918d49e8" title="Configure target interrupt filtering mode.">ch_set_target_interrupt()</a></em> (or <em><a class="el" href="soniclib_8h.html#a210dcd310e0c16c343f11c2e3c53984f" title="Set multiple configuration settings for a sensor.">ch_set_config()</a></em>) function and specifying <em>CH_TGT_INT_FILTER_COUNTER</em> as the filter type.</p>
<p>The location specified by <em>meas_hist_ptr</em> will be set to the number of previous measurements that are included in the history for filtering. The current measurement is combined with these previous measurements, so a total of <em>meas_hist</em> + 1 measurements are used. The location specified by <em>thresh_count_ptr</em> will be set to the threshold number of those measurements that must positively detect a target for an interrupt to be generated. The location specified by <em>reset_ptr</em> will be set to 1 if the sensor resets the counter filter after an interrupt is generated, 0 otherwise (default).</p>
<p>The maximum value for both <em>meas_hist</em> and <em>thresh_count</em> is 15.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a21906ecff45b2f188d8cf6b4b7b2e596" title="Configure the target interrupt counter filter.">ch_set_target_int_counter()</a></em>, <em><a class="el" href="soniclib_8h.html#ab462c77e75fd5b959eb3d49e918d49e8" title="Configure target interrupt filtering mode.">ch_set_target_interrupt()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Target counter filtering is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="abdc2253cbd8774013965ab82eadba27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc2253cbd8774013965ab82eadba27c">&#9670;&nbsp;</a></span>ch_get_target_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="soniclib_8h.html#ac2d701c38ecfaa08151839826667df20">ch_tgt_int_filter_t</a> ch_get_target_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the target interrupt filtering mode setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Target interrupt filter mode</dd></dl>
<p>This function returns the current setting for target interrupt filtering mode. The mode is one of:</p><ul>
<li>CH_TGT_INT_FILTER_OFF - No filtering. The sensor will interrupt after each measurement, even if no target is detected.</li>
<li>CH_TGT_INT_FILTER_ANY - Target filtering. The sensor will interrupt after each measurement in which a target is successfully detected. No interrupt is generated if no target is found.</li>
<li>CH_TGT_INT_FILTER_COUNTER - Target filtering with a threshold value. The sensor will interrupt if a specified number of measurements detect a target within a certain number of consecutive results.</li>
</ul>
<p>See also <em><a class="el" href="soniclib_8h.html#ab462c77e75fd5b959eb3d49e918d49e8" title="Configure target interrupt filtering mode.">ch_set_target_interrupt()</a></em>, <em><a class="el" href="soniclib_8h.html#abf08ef3543bda6135f4f5663283241cf" title="Get the target interrupt counter filter settings.">ch_get_target_int_counter()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Target detection interrupt mode is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="a74355ffe5e8887d74e9cdf5b3bd48a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74355ffe5e8887d74e9cdf5b3bd48a6f">&#9670;&nbsp;</a></span>ch_get_trigger_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="soniclib_8h.html#aa18105c6986688c2700df504020bc2f2">ch_trigger_type_t</a> ch_get_trigger_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the trigger type for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>trigger type, either CH_TRIGGER_TYPE_HW or CH_TRIGGER_TYPE_SW</dd></dl>
<p>This function gets the current trigger type to be used to initiate a measurement on a sensor when in triggered mode.</p>
<p>By default, sensors are triggered using a hardware signal on the INT line, and this function will return CH_TRIGGER_TYPE_HW.</p>
<p>Alternatively, software triggering may be used, using a special SPI command to the sensor. In this case, this function will return CH_TRIGGER_TYPE_SW.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a035896185096ae0cc1e4c54db205d38c" title="Set the trigger type for a sensor.">ch_set_trigger_type()</a></em>, <em><a class="el" href="soniclib_8h.html#ade5083e622e8cc3852a4193f6d8dce9c" title="Trigger a measurement on one sensor.">ch_trigger()</a></em>. </p>

</div>
</div>
<a id="a29a46285cbf72cb4d1c163f6575edf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a46285cbf72cb4d1c163f6575edf2f">&#9670;&nbsp;</a></span>ch_get_tx_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_tx_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ultrasound transmit pulse length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transmit pulse length (number of cycles per transmission)</dd></dl>
<p>This function gets the length of the ultrasonic pulse sent by the sensor when it transmit. The transmit length is expressed in <em>cycles</em>.</p>
<p>For ICU (Shasta architecture) sensors, <em>cycles</em> are in units of Measurement State Machine Clock (SMCLK) cycles.</p>
<p>For CH101 and CH201 (Whitney architecture) sensors, <em>cycles</em> are ultrasonic transducer (PMUT) cycles.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a34baf01ca64b1fd8fe1ec6225988a2d9" title="Set the ultrasound transmit pulse length.">ch_set_tx_length()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="a8a4371e12741e68a16c7d17a72c55fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4371e12741e68a16c7d17a72c55fe9">&#9670;&nbsp;</a></span>ch_get_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_get_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__version__t.html">ch_version_t</a> *&#160;</td>
          <td class="paramname"><em>version_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SonicLib version number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version_ptr</td><td>pointer to a <a class="el" href="structch__version__t.html" title="SonicLib version structure.">ch_version_t</a> structure to receive version</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills the fields in the <em><a class="el" href="structch__version__t.html" title="SonicLib version structure.">ch_version_t</a></em> structure identified by <em>version_ptr</em> with the SonicLib version number.</p>
<p>The version number consists of three x.y.z fields: &lt;major&gt;.&lt;minor&gt;.&lt;rev&gt;</p>
<ul>
<li><em>Major</em> versions are infrequent architectural releases that may include fundamental changes to interfaces and other compatiblity issues.</li>
<li><em>Minor</em> releases introduce new features and may include minor changes to individual interfaces, but are generally backwards compatible.</li>
<li><em>Revision</em> releases include bug fixes and other changes that do not affect public interfaces. </li>
</ul>

</div>
</div>
<a id="a445492118ad79cd042bacbe6f16006f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445492118ad79cd042bacbe6f16006f1">&#9670;&nbsp;</a></span>ch_group_get_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_group_get_frequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the operating frequency for a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor for sensor group</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the nominal acoustic operating frequency for a group of sensors whose frequencies have been adjusted using <em><a class="el" href="soniclib_8h.html#a5c373443ede97b6665a9919b23074328" title="Set the operating frequency for a group of sensors.">ch_group_set_frequency()</a></em>. A return value of zero indicates that no group frequency has been set.</p>
<p>In general, the actual operating frequency for each device will vary slightly from the nominal group value. Use <em><a class="el" href="soniclib_8h.html#a7ae60d24c0b1d0fb5f06e2449c0fa149" title="Get the operating frequency of a sensor.">ch_get_frequency()</a></em> to obtain the adjusted operating frequency for an individual sensor.</p>
<dl class="section return"><dt>Returns</dt><dd>Group nominal frequency, in Hz, or zero if no group frequency has been set</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a5c373443ede97b6665a9919b23074328" title="Set the operating frequency for a group of sensors.">ch_group_set_frequency()</a></em>, <em><a class="el" href="soniclib_8h.html#a7ae60d24c0b1d0fb5f06e2449c0fa149" title="Get the operating frequency of a sensor.">ch_get_frequency()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>For CH101 and CH201 sensors, this function is only available in select sensor firmware versions. </dd></dl>

</div>
</div>
<a id="af80e105e4c2bcee89f2f606d35015050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80e105e4c2bcee89f2f606d35015050">&#9670;&nbsp;</a></span>ch_group_get_pmut_clock_freq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_group_get_pmut_clock_freq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transducer clock input frequency for a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> sensor group descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>frequency of group transducer clock signal in Hz, or zero if no shared clock</dd></dl>
<p>This function is used only in designs in which the ultrasonic transducers (PMUTs) of multiple sensors in a group share a clock source. The clock source may be output from one of the sensors, or it may be from an independent signal source. (See <em><a class="el" href="soniclib_8h.html#a50819630a6c6dc83303090054413866d" title="Configure ultrasound transducer clock.">ch_set_pmut_clock()</a></em>.)</p>
<p>This function returns the frequency of the group PMUT clock signal, in Hz, regardless of its source. The returned frequency will be zero if no sensor is outputting a clock signal and no independent clock rate has been specified using <em>ch_set_pmut_clock_freq()</em>.</p>
<p>The sensors operate at an acoustic frequency of 1/16 the PMUT clock rate. For example, if the reported clock rate is 800 kHz, the sensors are operating at 50 kHz.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#ac5702e109dfbbd351a32df3df36c6e1b" title="Specify the transducer clock input frequency for a group of sensors.">ch_group_set_pmut_clock_freq()</a></em>, <em><a class="el" href="soniclib_8h.html#a50819630a6c6dc83303090054413866d" title="Configure ultrasound transducer clock.">ch_set_pmut_clock()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is not available on CH101 or CH201 sensors. </dd></dl>

</div>
</div>
<a id="aaedc8fdec2ebbecb1b89c6856f63bd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedc8fdec2ebbecb1b89c6856f63bd60">&#9670;&nbsp;</a></span>ch_group_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_group_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num_devices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num_buses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rtc_cal_pulse_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the group descriptor for a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor for sensor group to join </td></tr>
    <tr><td class="paramname">num_devices</td><td>number of the device within the sensor group </td></tr>
    <tr><td class="paramname">num_devices</td><td>number of the buses the sensors use </td></tr>
    <tr><td class="paramname">rtc_cal_pulse_ms</td><td>Length of the pulse used to calibrate the sensors RTC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function is used to initialize few group structure field before initializing sensors</p>
<p>Generally, an application will require only one <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> structure to manage all Chirp sensors.</p>
<dl class="section note"><dt>Note</dt><dd>This function only performs internal initialization of data structures, etc. It does not actually initialize the physical sensor device(s). See <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em>, <em><a class="el" href="soniclib_8h.html#af25e3902b1313e4de920e703564bffb5" title="Restart a sensor.">ch_restart()</a></em>, and <em><a class="el" href="soniclib_8h.html#a69790de1c39a18e73c4b42d4670e80a8" title="Restart a group of sensors.">ch_group_restart()</a></em>. </dd></dl>

</div>
</div>
<a id="a63c386c49a6c8ad4bb506c4d00e3bcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c386c49a6c8ad4bb506c4d00e3bcf5">&#9670;&nbsp;</a></span>ch_group_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_group_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113">ch_reset_t</a>&#160;</td>
          <td class="paramname"><em>reset_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor for this group of sensors </td></tr>
    <tr><td class="paramname">reset_type</td><td>type of reset (<em>CH_RESET_HARD</em> or <em>CH_RESET_SOFT</em>)</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets all sensors in a sensor group. The <em>reset_type</em> parameter indicates if a software reset or full hardware reset is requested. </p>

</div>
</div>
<a id="a69790de1c39a18e73c4b42d4670e80a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69790de1c39a18e73c4b42d4670e80a8">&#9670;&nbsp;</a></span>ch_group_restart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_group_restart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor for sensor group to be restarted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>This function performs a re-start of a group of sensors that have previously been initialized and started.</p>
<p>Each sensor will be reprogrammed with firmware (as specified in the most recent call to <em><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize the device descriptor for a sensor.">ch_init()</a></em>) and then will be started and configured. The sensors will not perform the normal calibration steps (including clock calibration) - they will instead use the values saved by a previous initialization.</p>
<p>After this routine returns successfully, the sensors should be ready to resume measurements.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#af25e3902b1313e4de920e703564bffb5" title="Restart a sensor.">ch_restart()</a></em>, <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em>. </p>

</div>
</div>
<a id="a5c373443ede97b6665a9919b23074328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c373443ede97b6665a9919b23074328">&#9670;&nbsp;</a></span>ch_group_set_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_group_set_frequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>request_op_freq_hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the operating frequency for a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor for sensor group </td></tr>
    <tr><td class="paramname">request_op_freq_hz</td><td>requested operating frequency in Hz, or zero to use group avg</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function requests a desired acoustic operating frequency for a group of sensors. This is the primary frequency of the ultrasonic pulse that is emitted by each device when transmitting.</p>
<p>When a group of sensors are used in paired pitch/catch operation, it is often helpful to set them to a common acoustic operating frequency. A better frequency match between the transmitting and receiving sensors improves the range and reliability.</p>
<p>All sensors in the group must be the same production model (part number). It is not possible to set the frequency to a value that is outside the typical operating frequency range for the sensor model.</p>
<p>If the <em>request_op_freq_hz</em> parameter is <em>CH_OP_FREQ_USE_AVG</em> (zero), all sensors will be set to the average of the unadjusted operating frequencies for the group, which generally gives the best performance. After this call returns, you may use <em><a class="el" href="soniclib_8h.html#a445492118ad79cd042bacbe6f16006f1" title="Get the operating frequency for a group of sensors.">ch_group_get_frequency()</a></em> to determine the average frequency that was used.</p>
<p>If <em>request_op_freq_hz</em> is non-zero, the specified frequency in Hz will be applied to all sensors. Use this option to request a certain operating frequency for all sensors, regardless of their natural operating frequencies.</p>
<p>In general, the actual operating frequency for each device will vary slightly from the requested value or calculated average frequency. The nominal group operating frequency may be obtained by using <em><a class="el" href="soniclib_8h.html#a445492118ad79cd042bacbe6f16006f1" title="Get the operating frequency for a group of sensors.">ch_group_get_frequency()</a></em>. To determine the actual operating frequency for each individual sensor, use <em><a class="el" href="soniclib_8h.html#a7ae60d24c0b1d0fb5f06e2449c0fa149" title="Get the operating frequency of a sensor.">ch_get_frequency()</a></em>.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a445492118ad79cd042bacbe6f16006f1" title="Get the operating frequency for a group of sensors.">ch_group_get_frequency()</a></em>, <em><a class="el" href="soniclib_8h.html#a5c6b0cc10159a9a9bb4dd74f38384d3a" title="Set the operating frequency of a sensor.">ch_set_frequency()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>For CH101 and CH201 sensors, this function is only available in select sensor firmware versions. </dd></dl>

</div>
</div>
<a id="ac5702e109dfbbd351a32df3df36c6e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5702e109dfbbd351a32df3df36c6e1b">&#9670;&nbsp;</a></span>ch_group_set_pmut_clock_freq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_group_set_pmut_clock_freq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pmut_clock_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the transducer clock input frequency for a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> sensor group descriptor structure </td></tr>
    <tr><td class="paramname">pmut_clock_freq</td><td>frequency of input clock signal, in Hz</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function is used only in unusual designs in which the ultrasonic transducers (PMUTs) of multiple sensors share an independent, external clock source. This function is not needed if the sensors each use their own clock (the default) or if one sensor supplies the PMUT clock signal for others. (See <em><a class="el" href="soniclib_8h.html#a50819630a6c6dc83303090054413866d" title="Configure ultrasound transducer clock.">ch_set_pmut_clock()</a></em>.)</p>
<p>This function specifies the frequency of the external clock signal, in Hz. The sensors will operate at an acoustic frequency of 1/16 the input clock rate. For example, if the input clock rate is 800 kHz, the sensor will operate at 50 kHz.</p>
<p>The input clock rate must be appropriate for the specific sensor model being used. Radical shifts in operating frequency are not possible.</p>
<p>The input clock signal must be present, and this function must be called to specify the frequency before <em><a class="el" href="soniclib_8h.html#a50819630a6c6dc83303090054413866d" title="Configure ultrasound transducer clock.">ch_set_pmut_clock()</a></em> is used to enable the external clock input for any sensors.</p>
<p>Only one shared PMUT clock signal can be used within a sensor group.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#af80e105e4c2bcee89f2f606d35015050" title="Get the transducer clock input frequency for a group of sensors.">ch_group_get_pmut_clock_freq()</a></em>, <em><a class="el" href="soniclib_8h.html#a50819630a6c6dc83303090054413866d" title="Configure ultrasound transducer clock.">ch_set_pmut_clock()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is not available on CH101 or CH201 sensors. </dd></dl>

</div>
</div>
<a id="a3d1acc5372d38d7abd7028a5504e5634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1acc5372d38d7abd7028a5504e5634">&#9670;&nbsp;</a></span>ch_group_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_group_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program and start a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor for sensor group to be started</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>This function performs the actual discovery, programming, and initialization sequence for all sensors within a sensor group. Each sensor must have previously been added to the group by calling <em><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize the device descriptor for a sensor.">ch_init()</a></em>.</p>
<p>In brief, this function does the following for each sensor:</p><ul>
<li>Probe the possible sensor ports using SPI/I2C bus and each sensor's PROG line, to discover if sensor is connected.</li>
<li>Reset sensor.</li>
<li>Program sensor with firmware (version specified during <em><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize the device descriptor for a sensor.">ch_init()</a></em>).</li>
<li>For CH101/CH201 sensors only, assign unique I2C address to sensor (specified by board support package, see <em><a class="el" href="chirp__bsp_8h.html#a260d9c119fdb1db98ecaba6da5365576" title="Return I2C information for a sensor port on the board.">chbsp_i2c_get_info()</a></em>).</li>
<li>Start sensor execution.</li>
<li>Wait for sensor to lock (complete initialization, including self-test).</li>
<li>Send timed pulse on INT line to calibrate sensor Real-Time Clock (RTC).</li>
</ul>
<p>After this routine returns successfully, the sensor configuration may be set and ultrasonic measurements may begin.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize the device descriptor for a sensor.">ch_init()</a></em>, <em><a class="el" href="soniclib_8h.html#af25e3902b1313e4de920e703564bffb5" title="Restart a sensor.">ch_restart()</a></em>, <em><a class="el" href="soniclib_8h.html#a69790de1c39a18e73c4b42d4670e80a8" title="Restart a group of sensors.">ch_group_restart()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>When the sensor is programmed, the entire sensor firmware image is normally written in a single, large SPI/I2C transfer. To limit the size of this transfer for a specific hardware platform, define the <b>MAX_PROG_XFER_SIZE</b> symbol in the <b><a class="el" href="chirp__board__config_8h_source.html">chirp_board_config.h</a></b> header file. For more information, see <a class="el" href="chirp__bsp_8h.html" title="User-supplied board support package functions to interface Chirp SonicLib to a specific hardware plat...">chirp_bsp.h</a>. </dd></dl>

</div>
</div>
<a id="aa4e917eea19df611680dc97e2401db3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e917eea19df611680dc97e2401db3a">&#9670;&nbsp;</a></span>ch_group_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_group_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger a measurement on a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor for this group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function generates a pulse on the INT line for each sensor in the sensor group. If a sensor is in either <em>CH_MODE_TRIGGERED_TX_RX</em> or <em>CH_MODE_TRIGGERED_RX_ONLY</em> mode, this pulse will begin a measurement cycle.</p>
<p>If a two or more sensors are operating in pitch-catch mode (in which one transmits and the others receive), this function must be used to start a measurement cycle, so that the devices are synchronized.</p>
<p>To trigger a single sensor, use <em><a class="el" href="soniclib_8h.html#ade5083e622e8cc3852a4193f6d8dce9c" title="Trigger a measurement on one sensor.">ch_trigger()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Do not trigger a new measurement until the previous measurement has completed and all needed data has been read from the device (including I/Q data, if <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor.">ch_get_iq_data()</a></em> is used). If any I/O operations are still active, the new measurement may be corrupted. </dd></dl>

</div>
</div>
<a id="afb33f776f4a2d55c885023798402c2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb33f776f4a2d55c885023798402c2a5">&#9670;&nbsp;</a></span>ch_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a6c5f9dbeb75e38d6e3b81540a35b7fe0">ch_fw_init_func_t</a>&#160;</td>
          <td class="paramname"><em>fw_init_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a Chirp ultrasonic sensor descriptor structure. </p>
<p>Initialize the device descriptor for a sensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>a pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (RET_OK) if successful, non-zero otherwise </dd></dl>

</div>
</div>
<a id="ad725040c45603cc81f47ccb4ab104efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad725040c45603cc81f47ccb4ab104efc">&#9670;&nbsp;</a></span>ch_init_algo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_init_algo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the measurement algorithm on a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">algo_info_ptr</td><td>pointer to a ICU_ALGO_SHASTA_INFO structure to receive info</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function initializes a measurement algorithm that has been loaded into a sensor and configured.</p>
<p>Normally, this routine will only be used by special applications or libraries which interact with specific sensor firmware. It is not used directly in a typical application.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a719bb8d611224839c6d9404d339bc9e8" title="Import an externally defined measurement configuration.">ch_meas_import()</a></em>, <a class="el" href="soniclib_8h.html#abfe62802f4bc1c41bc96d903e3aa323c" title="Get the measurement algorithm state data from a sensor.">ch_get_algo_state()</a>. </p>

</div>
</div>
<a id="a68080a85a27dc680ce55c020f575c5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68080a85a27dc680ce55c020f575c5c3">&#9670;&nbsp;</a></span>ch_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify SonicLib that a sensor interrupt occurred. </p>
<p>Run SonicLib's full-featured interrupt handler.</p>
<p>This function is used from the board support package (BSP) handler routine for the sensor interrupt to notify SonicLib that the interrupt has occurred. The SonicLib driver layer will handle further processing of the interrupt, including a call to the application-supplied callback function. </p>

</div>
</div>
<a id="ae40302a26ef7dd9868f5c28bcfc15cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40302a26ef7dd9868f5c28bcfc15cea">&#9670;&nbsp;</a></span>ch_io_complete_callback_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_io_complete_callback_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a98e3bc51c237abf8b03ce396db3f7caf">ch_io_complete_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback_func_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set callback function for Chirp sensor I/O operation complete. </p>
<p>Register non-blocking I/O complete callback routine for a group of sensors.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>

</div>
</div>
<a id="af3d4045f3510d82596c8231123e890b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d4045f3510d82596c8231123e890b9">&#9670;&nbsp;</a></span>ch_io_int_callback_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_io_int_callback_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a752bd8d2cf0340ffc3707a25b2a88227">ch_io_int_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback_func_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set callback function for Chirp sensor I/O interrupt. </p>
<p>Register sensor interrupt callback routine for a group of sensors.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>

</div>
</div>
<a id="a32b5931001ef934347a12daa46d700a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b5931001ef934347a12daa46d700a7">&#9670;&nbsp;</a></span>ch_io_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_io_notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i2c_bus_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continue a non-blocking readout. </p>
<p>Notify SonicLib that a non-blocking I/O operation has completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors </td></tr>
    <tr><td class="paramname">i2c_bus_index</td><td>index value identifying I2C/SPI bus within group</td></tr>
  </table>
  </dd>
</dl>
<p>Call this function once from your I2C interrupt handler each time it completes an I/O operation. It will call the function previously specified during <em><a class="el" href="soniclib_8h.html#ae40302a26ef7dd9868f5c28bcfc15cea" title="Register non-blocking I/O complete callback routine for a group of sensors.">ch_io_complete_callback_set()</a></em> when all group transactions are complete. </p>

</div>
</div>
<a id="af7b5f63c32c49bf634a00fc6594e57bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b5f63c32c49bf634a00fc6594e57bc">&#9670;&nbsp;</a></span>ch_io_start_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_io_start_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a non-blocking sensor readout. </p>
<p>Start non-blocking I/O operation(s) for a group of sensors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor structure for a group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function starts a non-blocking I/O operation on the specified group of sensors. </p>

</div>
</div>
<a id="ac78bd32dde57faf8200f39786151040c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78bd32dde57faf8200f39786151040c">&#9670;&nbsp;</a></span>ch_iq_to_amplitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_iq_to_amplitude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a> *&#160;</td>
          <td class="paramname"><em>iq_sample_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate amplitude from sample I/Q values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iq_sample_ptr</td><td>pointer to ch_iq_data_t structure containing the I/Q data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amplitude value</dd></dl>
<p>This function converts the I and Q values from a single raw sensor sample to an amplitude value according to the following formula: </p><p class="formulaDsp">
\[Amp = \sqrt{(I)^2 + (Q)^2}\]
</p>
<p>Amplitude values in the sensor are expressed only in internal ADC counts (least-significant bits, or LSBs) and are not calibrated to any standard units.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor.">ch_get_iq_data()</a></em>, <em><a class="el" href="soniclib_8h.html#af95998b37600ae7ef3a2300c10519fdf" title="Get the raw amplitude measurement data from a sensor.">ch_get_amplitude_data()</a></em>. </p>

</div>
</div>
<a id="a89b106baa702f500a55e64787bace2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b106baa702f500a55e64787bace2bb">&#9670;&nbsp;</a></span>ch_log_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_log_append </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>log_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a9b0598bc1d023573411e2831f3d28108">ch_log_fmt_t</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__log__data__t.html">ch_log_data_t</a> *&#160;</td>
          <td class="paramname"><em>log_data_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append received sensor data to log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_id</td><td>log ID to specify the log to use </td></tr>
    <tr><td class="paramname">format</td><td>format of the log </td></tr>
    <tr><td class="paramname">timestamp</td><td>current time in us </td></tr>
    <tr><td class="paramname">log_data_ptr</td><td>pointer to log data structure that contains the log data</td></tr>
  </table>
  </dd>
</dl>
<p>This function appends received sensor data (including I/Q data) to the log in the specified log format. The function takes a new Log ID returns by <em><a class="el" href="soniclib_8h.html#a4a33406081a2392fd38f36cd65e8b8cb" title="Initialize a log in the specified log format.">ch_log_init()</a></em> function to specify the log to use.</p>
<p>The function should be used when the previous measurement has completed and all needed data has been read from the device (including I/Q data) </p>

</div>
</div>
<a id="a4a33406081a2392fd38f36cd65e8b8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a33406081a2392fd38f36cd65e8b8cb">&#9670;&nbsp;</a></span>ch_log_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_log_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a9b0598bc1d023573411e2831f3d28108">ch_log_fmt_t</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__log__cfg__t.html">ch_log_cfg_t</a> *&#160;</td>
          <td class="paramname"><em>config_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a log in the specified log format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> descriptor for this group of sensors </td></tr>
    <tr><td class="paramname">format</td><td>format of the log. For example, CH_LOG_FMT_REDSWALLOW </td></tr>
    <tr><td class="paramname">config_ptr</td><td>pointer to log config structure that contains the input values of the log</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Log ID value to be used later when appending the log</dd></dl>
<p>This function initializes a sensor data log in the specified log format. </p>

</div>
</div>
<a id="a5372b50fccbc80b38dab4722dfaed9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5372b50fccbc80b38dab4722dfaed9fc">&#9670;&nbsp;</a></span>ch_meas_activate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_meas_activate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate a defined measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>number of measurement to activate</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets a measurement to active mode. The specified measurement definition will be used when the sensor makes a measurement. The measurement must have previously been defined, either by using <em><a class="el" href="soniclib_8h.html#a0dfa2a99ca4868b9cd6d363a7f14270e" title="Initialize a measurement.">ch_meas_init()</a></em> and related calls to specify the measurement segments, or by importing a complete measurement definition.</p>
<p>If the measurement specified by <em>meas_num</em> was previously in standby mode (inactive), it is made active. In all cases, this definition will be used during the the next measurement performed by the sensor, even if the other measurement is also active.</p>
<p>This function does not affect the active vs. standby status of the other measurement. If both measurements are active after calling this function, they will alternate each time the sensor performs a measurement.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#afc64afbffb1f34e6881528e31bce9286" title="Put a measurement in standby mode.">ch_meas_standby()</a></em>, <em><a class="el" href="soniclib_8h.html#a20576be17d3be2e6c3293c753c94c434" title="Switch active and standby measurement definitions.">ch_meas_switch()</a></em>, <em><a class="el" href="soniclib_8h.html#a0dfa2a99ca4868b9cd6d363a7f14270e" title="Initialize a measurement.">ch_meas_init()</a></em>, <em><a class="el" href="soniclib_8h.html#a719bb8d611224839c6d9404d339bc9e8" title="Import an externally defined measurement configuration.">ch_meas_import()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is only available for ICU sensors. </dd></dl>

</div>
</div>
<a id="a063940d1f4d8613c4c0abaa421a17b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063940d1f4d8613c4c0abaa421a17b0c">&#9670;&nbsp;</a></span>ch_meas_add_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_add_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *&#160;</td>
          <td class="paramname"><em>seg_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a segment to a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">seg_ptr</td><td>pointer to measurement segment to be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function adds a measurement segment to the measurement specified by <em>meas_num</em>. <em>seg_ptr</em> points to a segment descriptor, which must have already been initialized.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a8214b6c4e8592686ae3bb9daa0833012" title="Add a transmit segment to a measurement.">ch_meas_add_segment_tx()</a></em>,<em><a class="el" href="soniclib_8h.html#a335f7c6b36d077d9c31e151d37f0a5e8" title="Add a receive segment to a measurement.">ch_meas_add_segment_rx()</a></em>, <em><a class="el" href="soniclib_8h.html#adde2d67659346569ec81c5e7f51d7647" title="Initialize a transmit measurement segment.">ch_meas_init_segment_tx()</a></em>, <em><a class="el" href="soniclib_8h.html#aaf5a793e1e01da899f3a64b8bed4acc9" title="Initialize a receive measurement segment.">ch_meas_init_segment_rx()</a></em>, </p>

</div>
</div>
<a id="a414bed6efd64e03e74c13dabf97aa7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414bed6efd64e03e74c13dabf97aa7f1">&#9670;&nbsp;</a></span>ch_meas_add_segment_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_add_segment_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>int_enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a count (delay) segment to a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">num_cycles</td><td>length of the segment, in cycles </td></tr>
    <tr><td class="paramname">int_enable</td><td>if non-zero, the sensor will interrupt at the completion of this segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function adds a count (delay) segment to the measurement specified by <em>meas_num</em>. Such a segment does not transmit a signal nor does it sample received ultrasound. So, no samples are associated with this portion of the measurement time.</p>
<p>This function combines the operations of <em><a class="el" href="soniclib_8h.html#ac1cbeef0db6da0bdafa19165151b4c40" title="Initialize a count (delay) measurement segment.">ch_meas_init_segment_count()</a></em> and <em><a class="el" href="soniclib_8h.html#a063940d1f4d8613c4c0abaa421a17b0c" title="Add a segment to a measurement.">ch_meas_add_segment()</a></em>. </p>

</div>
</div>
<a id="adbf06fb5c8f5fcf8947e71b49957e0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf06fb5c8f5fcf8947e71b49957e0ee">&#9670;&nbsp;</a></span>ch_meas_add_segment_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_add_segment_rx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gain_reduce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>atten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>int_enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a receive segment to a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">num_samples</td><td>length of the segment, in sample periods </td></tr>
    <tr><td class="paramname">gain_reduce</td><td>gain reduction value, 0 = max gain </td></tr>
    <tr><td class="paramname">atten</td><td>attenuation level </td></tr>
    <tr><td class="paramname">int_enable</td><td>if non-zero, the sensor will interrupt at the completion of this segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function adds a receive segment to the measurement specified by <em>meas_num</em>. It combines the operations of <em><a class="el" href="soniclib_8h.html#aaf5a793e1e01da899f3a64b8bed4acc9" title="Initialize a receive measurement segment.">ch_meas_init_segment_rx()</a></em> and <em><a class="el" href="soniclib_8h.html#a063940d1f4d8613c4c0abaa421a17b0c" title="Add a segment to a measurement.">ch_meas_add_segment()</a></em>. </p>

</div>
</div>
<a id="a8214b6c4e8592686ae3bb9daa0833012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8214b6c4e8592686ae3bb9daa0833012">&#9670;&nbsp;</a></span>ch_meas_add_segment_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_add_segment_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pulse_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>int_enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a transmit segment to a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">num_cycles</td><td>length of the segment, in cycles </td></tr>
    <tr><td class="paramname">pulse_width</td><td>transmit pulse width </td></tr>
    <tr><td class="paramname">phase</td><td>transmit phase </td></tr>
    <tr><td class="paramname">int_enable</td><td>if non-zero, the sensor will interrupt at the completion of this segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function adds a transmit segment to the measurement specified by <em>meas_num</em>. It combines the operations of <em><a class="el" href="soniclib_8h.html#adde2d67659346569ec81c5e7f51d7647" title="Initialize a transmit measurement segment.">ch_meas_init_segment_tx()</a></em> and <em><a class="el" href="soniclib_8h.html#a063940d1f4d8613c4c0abaa421a17b0c" title="Add a segment to a measurement.">ch_meas_add_segment()</a></em>.</p>
<p>The <em>cycles</em> parameter specifies the overall length of the transmit pulse that will be generated. The units are internal sensor cycles.</p>
<p>See also <em>ch_meas</em>)add_segment_rx(), <em><a class="el" href="soniclib_8h.html#a414bed6efd64e03e74c13dabf97aa7f1" title="Add a count (delay) segment to a measurement.">ch_meas_add_segment_count()</a></em>, <em><a class="el" href="soniclib_8h.html#a5d8b3ddcc0010bf7bd1f7acc1fba4232" title="Convert microseconds to sensor cycles.">ch_usec_to_cycles()</a></em>. </p>

</div>
</div>
<a id="aa3d2278773b6676145e9d86bb1cdf769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d2278773b6676145e9d86bb1cdf769">&#9670;&nbsp;</a></span>ch_meas_get_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_meas_get_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__meas__info__t.html">ch_meas_info_t</a> *&#160;</td>
          <td class="paramname"><em>info_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get configuration information for a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">info_ptr</td><td>pointer to <a class="el" href="structch__meas__info__t.html" title="Measurement info.">ch_meas_info_t</a> structure to be updated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function obtains configuration information for the measurement specified by <em>meas_num</em>. The <a class="el" href="structch__meas__info__t.html" title="Measurement info.">ch_meas_info_t</a> structure specified by <em>info_ptr</em> will be completed with the settings for the measurement, including:</p><ul>
<li>mode - whether the measurement is active or in standby mode</li>
<li>num_segments - number of active segments in measurement</li>
<li>num_samples - total number of sample periods in all segments</li>
<li>num_ranges - maximum number of separate target range values to report</li>
<li>odr - output data rate for the sensor (time between samples within measurement)</li>
<li>meas_period - repeat period for measurement (0 if not used)</li>
<li>ringdown_cancel_samples - number of samples close to sensor to use ringdown cancellation filter</li>
<li>static_filter_samples - number of samples close to sensor to have static target rejection (STR) filter</li>
<li>iq_output_format - 0=normal (Q,I) pairs; 1=mag,threshold pairs, 2=mag,phase pairs</li>
<li>filter_update_interval - how often to update the ringdown and STR filters </li>
</ul>

</div>
</div>
<a id="a5c76a6684d06acdd7ff60de902ef9cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c76a6684d06acdd7ff60de902ef9cf0">&#9670;&nbsp;</a></span>ch_meas_get_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_meas_get_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the repeat interval for a measurement, in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sensor measurement interval</dd></dl>
<p>This function returns the internal measurement interval in the sensor, in milliseconds.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a52398f9f8bf2f5a20531e7c8ab1852fd" title="Set the repeat interval for a measurement, in milliseconds.">ch_meas_set_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#a2f5c83e0d155e17ab8ac74951f44ea02" title="Get the internal sensing timing interval for a sensor, in milliseconds.">ch_get_freerun_interval()</a></em>. </p>

</div>
</div>
<a id="a2402d08e2043ec130dbbb090b1c67596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2402d08e2043ec130dbbb090b1c67596">&#9670;&nbsp;</a></span>ch_meas_get_interval_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_meas_get_interval_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the repeat interval for a measurement, in sensor RTC clock ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sensor measurement interval</dd></dl>
<p>This function returns the internal measurement interval in the sensor, in sensor RTC clock periods.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a88d3915b3152ca1fda21ddddefb95fec" title="Set the repeat interval for a measurement, in sensor RTC clock ticks.">ch_meas_set_interval_ticks()</a></em>. </p>

</div>
</div>
<a id="aa6062925563a899604cc8665398fa635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6062925563a899604cc8665398fa635">&#9670;&nbsp;</a></span>ch_meas_get_interval_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_meas_get_interval_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the repeat interval for a measurement, in microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sensor measurement interval</dd></dl>
<p>This function returns the internal measurement interval in the sensor, in microseconds.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a4001469a3a233c39cead6f6624d436eb" title="Set the repeat interval for a measurement, in microseconds.">ch_meas_set_interval_us()</a></em>. </p>

</div>
</div>
<a id="abae9547bfdb9eda44b7f3f44c42d815e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae9547bfdb9eda44b7f3f44c42d815e">&#9670;&nbsp;</a></span>ch_meas_get_iq_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="soniclib_8h.html#a5143295fdd1fdd439dad873fb9e04948">ch_output_type_t</a> ch_meas_get_iq_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the I/Q data output format for a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I/Q data output format</dd></dl>
<p>This function returns the measurement I/Q data output format, as follows:</p><ul>
<li>CH_OUTPUT_IQ (0) - Standard pairs of {Q,I} int16_t values</li>
<li>CH_OUTPUT_AMP_THRESH (1) - Output amplitude + threshold uint16_t pair values</li>
<li>CH_OUTPUT_AMP (2) - Output uint16_t amplitude values only</li>
</ul>
<p>See also <em><a class="el" href="soniclib_8h.html#a3fb6e60f175bbb08c87787c0ac680865" title="Set the I/Q data output format for a measurement.">ch_meas_set_iq_output()</a></em>. </p>

</div>
</div>
<a id="a2ea79708279e4f56734234dd07ae23f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea79708279e4f56734234dd07ae23f4">&#9670;&nbsp;</a></span>ch_meas_get_last_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_get_last_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of last completed measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function returns the measurement number (0 or 1) for the last measurement that completed. It is useful if both measurements are active and are being executed alternately.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is only available for ICU sensors. </dd></dl>

</div>
</div>
<a id="acd7763faeec4c696c10410544cb01365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7763faeec4c696c10410544cb01365">&#9670;&nbsp;</a></span>ch_meas_get_max_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_meas_get_max_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum range setting in mm for a specific measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum range setting, in millimeters</dd></dl>
<p>This function returns the current maximum detection range setting for the specified measurement, in millimeters.</p>
<p>The <em><a class="el" href="soniclib_8h.html#a96b6bb2df00b9feb43955902c55835f7" title="Get the maximum range setting in mm for a sensor.">ch_get_max_range()</a></em> function performs the same operation for the default measurement (same as setting <em>meas_num</em> to CH_DEFAULT_MEAS_NUM).</p>
<p>See also <em><a class="el" href="soniclib_8h.html#acfc7192978564ab0f477ee2132870fea" title="Set the maximum range in mm for a specific measurement.">ch_meas_set_max_range()</a></em>, <em><a class="el" href="soniclib_8h.html#a9bf5688451893bddde1d3623dd34f48d" title="Get the number of samples per measurement cycle for a specific measurement.">ch_meas_get_num_samples()</a></em>. </p>

</div>
</div>
<a id="a9bf5688451893bddde1d3623dd34f48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf5688451893bddde1d3623dd34f48d">&#9670;&nbsp;</a></span>ch_meas_get_num_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_meas_get_num_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of samples per measurement cycle for a specific measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor struct </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of samples per measurement cycle</dd></dl>
<p>This function returns the configured number of samples which the Chirp sensor will obtain during each measurement cycle for the specified measurement. The number of samples directly corresponds to the range at which the sensor can detect, so this value is determined by the current maximum range setting for the sensor.</p>
<p>The <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em> function may be used to obtain the number of samples in the most recently completed measurement.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#acd7763faeec4c696c10410544cb01365" title="Get the maximum range setting in mm for a specific measurement.">ch_meas_get_max_range()</a></em>, <em><a class="el" href="soniclib_8h.html#a2806d7b51748c5dcd870d7c3c21b222a" title="Get the number of valid output samples in last measurement.">ch_get_num_output_samples()</a></em>. </p>

</div>
</div>
<a id="abc69e96679d03384c1cf912ebf66c614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc69e96679d03384c1cf912ebf66c614">&#9670;&nbsp;</a></span>ch_meas_get_odr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="soniclib_8h.html#a86140657375a7e7c24ecf430da97c189">ch_odr_t</a> ch_meas_get_odr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the output data rate for a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ODR setting</dd></dl>
<p>This function returns the output data rate (ODR) for the sensor. The ODR setting determines the spacing in time (and therefore in measured distance) between the individual samples within a measurement.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#adc5748ec903986b27b78f4a52b8c9e23" title="Set the output data rate for a measurement.">ch_meas_set_odr()</a></em>. </p>

</div>
</div>
<a id="a591525a8a8a249db1a0e26504391c8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591525a8a8a249db1a0e26504391c8bb">&#9670;&nbsp;</a></span>ch_meas_get_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_get_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">measurement_queue_t *&#160;</td>
          <td class="paramname"><em>meas_queue_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get measurement queue values for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_queue_ptr</td><td>pointer to location to receive measurement queue values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function copies the current measurement queue values for a sensor to the <em>measurement_queue_t</em> structure specified by <em>meas_queue_ptr</em>.</p>
<p>This function may be used to save the original measurement queue values before calling <em><a class="el" href="soniclib_8h.html#a719bb8d611224839c6d9404d339bc9e8" title="Import an externally defined measurement configuration.">ch_meas_import()</a></em> or <em><a class="el" href="soniclib_8h.html#a6d21dc9fdd39ade2eef9c269ba027272" title="Optimize ultrasound measurement sequences for a sensor.">ch_meas_optimize()</a></em>.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a8f9450f4a5d409c8e1474d4ae078fbe4" title="Write measurement configuration to sensor.">ch_meas_write_config()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is only available for ICU sensors. </dd></dl>

</div>
</div>
<a id="a3800e5639a3dae4272db79573180641d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3800e5639a3dae4272db79573180641d">&#9670;&nbsp;</a></span>ch_meas_get_queue_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_meas_get_queue_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__meas__queue__info__t.html">ch_meas_queue_info_t</a> *&#160;</td>
          <td class="paramname"><em>info_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get configuration information for the sensor measurement queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">info_ptr</td><td>pointer to <a class="el" href="structch__meas__queue__info__t.html" title="Measurement queue info.">ch_meas_queue_info_t</a> structure to be updated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function obtains configuration information for the sensor's measurement queue. The measurement queue contains all defined measurements plus common configuration settings. The <a class="el" href="structch__meas__queue__info__t.html" title="Measurement queue info.">ch_meas_queue_info_t</a> structure specified by <em>info_ptr</em> will be completed with the settings for the measurement queue, including:</p><ul>
<li>int_config - interrupt pin selection</li>
<li>meas_start - which measurement do we start on</li>
<li>meas_stop - which measurement do we stop on</li>
<li>current_meas - which measurement do we do next</li>
<li>trig_src - trigger source: INT1, INT2, or internal timer </li>
</ul>

</div>
</div>
<a id="a081ad1d7648bac0ed82f3ff93d7f0321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081ad1d7648bac0ed82f3ff93d7f0321">&#9670;&nbsp;</a></span>ch_meas_get_seg_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_meas_get_seg_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seg_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__meas__seg__info__t.html">ch_meas_seg_info_t</a> *&#160;</td>
          <td class="paramname"><em>info_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get configuration information for a measurement segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">seg_num</td><td>segment number </td></tr>
    <tr><td class="paramname">info_ptr</td><td>pointer to <a class="el" href="structch__meas__seg__info__t.html" title="Measurement segment info.">ch_meas_seg_info_t</a> structure to be updated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function obtains configuration information for the measurement segment specified by <em>meas_num</em> and <em>seg_num</em>.</p>
<p>The <a class="el" href="structch__meas__seg__info__t.html" title="Measurement segment info.">ch_meas_seg_info_t</a> structure specified by <em>info_ptr</em> will be completed with the settings for the measurement segment, including:</p><ul>
<li>num_rx_samples - length in sample periods (determined by num_cycles and output data rate)</li>
<li>num_cycles - length in cycles</li>
<li>rdy_int_en - sensor will interrupt when ready</li>
<li>done_int_en - sensor will interrupt when done with segment</li>
<li>tx_phase - phase (transmit segments only)</li>
<li>tx_pulse_width - pulse width (transmit segments only)</li>
<li>rx_gain_reduce - gain reduction (receive segments only)</li>
<li>rx_atten - attenuation (receive segments only) </li>
</ul>

</div>
</div>
<a id="a90245534189e3893901e90e63fc9e26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90245534189e3893901e90e63fc9e26c">&#9670;&nbsp;</a></span>ch_meas_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="soniclib_8h.html#a00b8943dd0033cdbdd6e4da6334f283b">ch_meas_status_t</a> ch_meas_get_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get measurement status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status</dd></dl>
<p>This function returns the current measurement status in the sensor. It may be used to help determine if valid measurement I/Q data can be read from the sensor.</p>
<p>A status value of CH_MEAS_STATUS_DONE indicates that complete measurement data is available for reading. A value of CH_MEAS_STATUS_PENDING indicates that a measurement is in progress, and the current data values should not be used.</p>
<p>Note that this routine only reports the status at the time it is called.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#ade5083e622e8cc3852a4193f6d8dce9c" title="Trigger a measurement on one sensor.">ch_trigger()</a></em>, <em><a class="el" href="soniclib_8h.html#a2b585794c893ffa579775e060df36915" title="Trigger a measurement using software (SPI) interface.">ch_trigger_soft()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>For CH101 and CH201 sensors, <em>meas_num</em> should be set to CH_DEFAULT_MEAS_NUM.</dd>
<dd>
This function is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="a719bb8d611224839c6d9404d339bc9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719bb8d611224839c6d9404d339bc9e8">&#9670;&nbsp;</a></span>ch_meas_import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_import </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">measurement_queue_t *&#160;</td>
          <td class="paramname"><em>meas_queue_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>algo_cfg_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import an externally defined measurement configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_queue_ptr</td><td>pointer to a complete measurement queue structure, or NULL </td></tr>
    <tr><td class="paramname">algo_cfg_ptr</td><td>pointer to a buffer containing algorithm configuration, or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function allows a fully defined measurement queue structure (measurement_queue_t) and algorithm-specific configuration to be imported as a unit. Taken together, these two structures fully define the measurement to be performed.</p>
<p>Alternatively, it is possible to import either the measurement queue or the algorithm configuration individually, by supplying a NULL pointer for the other structure. In this case, the current settings will continue to be used for the values specified in the other structure. An error is returned if both pointers are NULL.</p>
<p>The format of the algorithm configuration data will vary depending on the sensor firmware and algorithm that are being used.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a6d21dc9fdd39ade2eef9c269ba027272" title="Optimize ultrasound measurement sequences for a sensor.">ch_meas_optimize()</a></em>, which combines importing and optimizing a measurement queue. </p>

</div>
</div>
<a id="a0dfa2a99ca4868b9cd6d363a7f14270e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfa2a99ca4868b9cd6d363a7f14270e">&#9670;&nbsp;</a></span>ch_meas_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structch__meas__config__t.html">ch_meas_config_t</a> *&#160;</td>
          <td class="paramname"><em>meas_config_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>thresh_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">meas_config_ptr</td><td>pointer to measurement configuration settings </td></tr>
    <tr><td class="paramname">thresh_ptr</td><td>deprecated. Parameter not used. Shall be set to NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function initializes the measurement specified by <em>meas_num</em> with the specified configuration. <em>meas_config_ptr</em> is a pointer to a <a class="el" href="structch__meas__config__t.html" title="Measurement configuration - used during ch_meas_init()">ch_meas_config_t</a> structure which must have already been initialized. The fields in this structure specify various parameters for the measurement including</p><ul>
<li>odr - output data rate for the sensor (time between samples within measurement)</li>
<li>meas_period - repeat period for measurement, in ticks (optional, freerun interval may be set later)</li>
<li>mode - if CH_MEAS_MODE_STANDBY, this measurement will initially be put in standby mode (not active), if CH_MEAS_MODE_ACTIVE (zero), this measurement will initially be active and will be performed</li>
</ul>
<p><em>thresh_ptr</em> was used to initialize GPT thresholds. Now use <a class="el" href="icu__gpt_8c.html#a31939a4896b2265281448728ad1f2445" title="Configure GPT Algorithm.">icu_gpt_algo_configure()</a> to configure algo. </p>

</div>
</div>
<a id="a5c5abc7618cd984d09270ec7c2599e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5abc7618cd984d09270ec7c2599e76">&#9670;&nbsp;</a></span>ch_meas_init_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_init_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the sensor measurement queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function resets and re-initializes the sensor measurement queue. All configuration settings and all measurements are cleared. </p>

</div>
</div>
<a id="ac1cbeef0db6da0bdafa19165151b4c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cbeef0db6da0bdafa19165151b4c40">&#9670;&nbsp;</a></span>ch_meas_init_segment_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_meas_init_segment_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *&#160;</td>
          <td class="paramname"><em>seg_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>int_enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a count (delay) measurement segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg_ptr</td><td>pointer to the <a class="el" href="structch__meas__segment__t.html" title="Measurement segment.">ch_meas_segment_t</a> descriptor structure to be initialized </td></tr>
    <tr><td class="paramname">num_cycles</td><td>length of the segment, in cycles </td></tr>
    <tr><td class="paramname">int_enable</td><td>if non-zero, the sensor will interrupt at the completion of this segment</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes the measurement segment descriptor specified by <em>seg_ptr</em> as a count (delay) segment. Such a segment does not transmit a signal nor does it sample received ultrasound. So, no samples are associated with this portion of the measurement time.</p>
<p>The <em>cycles</em> parameter specifies the overall length of the delay. The units are internal sensor cycles. Use the <em><a class="el" href="soniclib_8h.html#a5d8b3ddcc0010bf7bd1f7acc1fba4232" title="Convert microseconds to sensor cycles.">ch_usec_to_cycles()</a></em> function to calculate the number of cycles for a specific delay duration.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error </dd></dl>

</div>
</div>
<a id="a8f42f21b5a63f0717c6b032d77a54507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f42f21b5a63f0717c6b032d77a54507">&#9670;&nbsp;</a></span>ch_meas_init_segment_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_meas_init_segment_rx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *&#160;</td>
          <td class="paramname"><em>seg_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a86140657375a7e7c24ecf430da97c189">ch_odr_t</a>&#160;</td>
          <td class="paramname"><em>odr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gain_reduce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>atten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>int_enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a receive measurement segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg_ptr</td><td>pointer to the <a class="el" href="structch__meas__segment__t.html" title="Measurement segment.">ch_meas_segment_t</a> descriptor structure to be initialized </td></tr>
    <tr><td class="paramname">num_samples</td><td>length of the segment, in sample periods </td></tr>
    <tr><td class="paramname">odr</td><td>output data rate setting to be used (set during <em><a class="el" href="soniclib_8h.html#a0dfa2a99ca4868b9cd6d363a7f14270e" title="Initialize a measurement.">ch_meas_init()</a></em>) </td></tr>
    <tr><td class="paramname">gain_reduce</td><td>gain reduction value, 0 = max gain </td></tr>
    <tr><td class="paramname">atten</td><td>attenuation level </td></tr>
    <tr><td class="paramname">int_enable</td><td>if non-zero, the sensor will interrupt at the completion of this segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function initializes the measurement segment descriptor specified by <em>seg_ptr</em> as a receive segment. The number of samples of added to the segments is limited by the maximum number of rx samples that firmware can read and by the number of cycles a segment can store. The length of segment in samples is converted to a number of cycles. A segment have a maximum length of 65535 cycles. If the number of sample exceeds the limitation, define the segments manually and import them to a measure queue using <em><a class="el" href="soniclib_8h.html#a719bb8d611224839c6d9404d339bc9e8" title="Import an externally defined measurement configuration.">ch_meas_import()</a></em> </p>

</div>
</div>
<a id="adde2d67659346569ec81c5e7f51d7647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde2d67659346569ec81c5e7f51d7647">&#9670;&nbsp;</a></span>ch_meas_init_segment_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_meas_init_segment_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *&#160;</td>
          <td class="paramname"><em>seg_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pulse_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>int_enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a transmit measurement segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg_ptr</td><td>pointer to the <a class="el" href="structch__meas__segment__t.html" title="Measurement segment.">ch_meas_segment_t</a> descriptor structure to be initialized </td></tr>
    <tr><td class="paramname">num_cycles</td><td>length of the segment, in cycles </td></tr>
    <tr><td class="paramname">pulse_width</td><td>transmit pulse width </td></tr>
    <tr><td class="paramname">phase</td><td>transmit phase </td></tr>
    <tr><td class="paramname">int_enable</td><td>if non-zero, the sensor will interrupt at the completion of this segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function initializes the measurement segment descriptor specified by <em>seg_ptr</em> as a transmit segment.</p>
<p>The <em>cycles</em> parameter specifies the overall length of the transmit pulse that will be generated. The units are internal sensor cycles.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#aaf5a793e1e01da899f3a64b8bed4acc9" title="Initialize a receive measurement segment.">ch_meas_init_segment_rx()</a></em>, <em><a class="el" href="soniclib_8h.html#ac1cbeef0db6da0bdafa19165151b4c40" title="Initialize a count (delay) measurement segment.">ch_meas_init_segment_count()</a></em>, <em><a class="el" href="soniclib_8h.html#a5d8b3ddcc0010bf7bd1f7acc1fba4232" title="Convert microseconds to sensor cycles.">ch_usec_to_cycles()</a></em>. </p>

</div>
</div>
<a id="ab2c95d14cdd3f9656e2f4e9b9a805c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c95d14cdd3f9656e2f4e9b9a805c4b">&#9670;&nbsp;</a></span>ch_meas_insert_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_insert_instruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *&#160;</td>
          <td class="paramname"><em>inst_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index_to_insert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an instruction(segment) to a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">inst_ptr</td><td>pointer to measurement instruction(segment) to be inserted </td></tr>
    <tr><td class="paramname">index_to_insert</td><td>instruction(segment) number to be remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function inserts a measurement instruction(segment) to the measurement specified by <em>meas_num</em>. <em>inst_ptr</em> points to an instruction(segment) descriptor, which must have already been initialized. </p>

</div>
</div>
<a id="a15e8410407cea43d44abada1eb739f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e8410407cea43d44abada1eb739f42">&#9670;&nbsp;</a></span>ch_meas_insert_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_insert_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structch__meas__segment__t.html">ch_meas_segment_t</a> *&#160;</td>
          <td class="paramname"><em>inst_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index_to_insert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an instruction(segment) to a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">inst_ptr</td><td>pointer to measurement instruction(segment) to be inserted </td></tr>
    <tr><td class="paramname">index_to_insert</td><td>instruction(segment) number to be inserted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function inserts a measurement instruction(segment) to the measurement specified by <em>meas_num</em>. <em>inst_ptr</em> points to an instruction(segment) descriptor, which must have already been initialized.</p>
<p>Will be deprecated by the new equivalent function ch_meas_insert_instruction. </p>

</div>
</div>
<a id="a4203c97c07e47db67bf2e1c1eb16b054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4203c97c07e47db67bf2e1c1eb16b054">&#9670;&nbsp;</a></span>ch_meas_mm_to_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_meas_mm_to_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_mm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert millimeters to sample count for a specific measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">num_mm</td><td>number of millimeters to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of samples</dd></dl>
<p>This function converts the distance in millimeters specified by <em>num_mm</em> and converts it to the corresponding number of sensor samples for a specific measurement number. The conversion uses values set during device initialization and calibration that describe the internal timing of the sensor, which affects how many samples correspond to a given distance.</p>
<dl class="section note"><dt>Note</dt><dd>In ICU sensors, the ODR is configurable. The default is one sample per 8 transceiver cycles (CH_ODR_FREQ_DIV_8, also known as CH_ODR_DEFAULT). If the default ODR will not be not used, the new ODR must be set for the specified measurement before this function is called, either as a standard parameter during <em><a class="el" href="soniclib_8h.html#a0dfa2a99ca4868b9cd6d363a7f14270e" title="Initialize a measurement.">ch_meas_init()</a></em>, or by calling <em><a class="el" href="soniclib_8h.html#adc5748ec903986b27b78f4a52b8c9e23" title="Set the output data rate for a measurement.">ch_meas_set_odr()</a></em>.</dd></dl>
<p>The <em><a class="el" href="soniclib_8h.html#aa256c720961a6d327c515da60d8071c2" title="Convert millimeters to sample count for a sensor.">ch_mm_to_samples()</a></em> function performs the same operation for the default measurement (same as setting <em>meas_num</em> to CH_DEFAULT_MEAS_NUM).</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a290f3e5de2ee174e37ff4522df51d376" title="Convert sample count to millimeters for a sensor.">ch_samples_to_mm()</a></em>, <em><a class="el" href="soniclib_8h.html#adc5748ec903986b27b78f4a52b8c9e23" title="Set the output data rate for a measurement.">ch_meas_set_odr()</a></em>. </p>

</div>
</div>
<a id="a6d21dc9fdd39ade2eef9c269ba027272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d21dc9fdd39ade2eef9c269ba027272">&#9670;&nbsp;</a></span>ch_meas_optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">measurement_queue_t *&#160;</td>
          <td class="paramname"><em>meas_queue_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>algo_cfg_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize ultrasound measurement sequences for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_queue_ptr</td><td>pointer to measurement queue to optimize, or NULL </td></tr>
    <tr><td class="paramname">algo_cfg_ptr</td><td>pointer to a buffer containing algorithm configuration, or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function optimizes the transmit sequences during measurements for a sensor. The original transmit segments are replaced by a longer sequence that is tuned to the specific sensor. In particular, the "ringdown" in the sensor following a transmission is actively reduced. The sensor is able to receive the echo signal sooner, thus permitting measurements at closer distances.</p>
<p>Optimization is performed on a defined measurement, such as the result of combining measurement segments using <em><a class="el" href="soniclib_8h.html#a063940d1f4d8613c4c0abaa421a17b0c" title="Add a segment to a measurement.">ch_meas_add_segment()</a></em> etc. These segments are part of the "measurement queue" for the sensor.</p>
<p>To optimize the current measurement settings and make no other changes to the configuration, specify NULL for both <em>meas_queue_ptr</em> and <em>algo_cfg_ptr</em>.</p>
<p>Alternatively, a new measurement queue may be imported, optimized, and applied using this function, similar to the <em><a class="el" href="soniclib_8h.html#a719bb8d611224839c6d9404d339bc9e8" title="Import an externally defined measurement configuration.">ch_meas_import()</a></em> function (e.g. to use an exported measurement queue definition from the SonicLink development kit). In this case, set <em>meas_queue_ptr</em> to the location containing the measurement queue to be optimized. The new measurement queue will be optimized, and the resulting settings will be written to the sensor. The input measurement queue definition specified by <em>meas_queue_ptr</em> will not be modified.</p>
<p>The <em>algo_cfg_ptr</em> parameter specifies a new measurement algorithm configuration to be applied. If <em>algo_cfg_ptr</em> is NULL, the current configuration will be left unchanged.</p>
<p>When optimization occurs, the sensor will be briefly re-programmed with special initialization firmware that analyzes the sensor's operation and determines the appropriate optimization. The results are read from the sensor and are combined with the original settings. Finally, the measurement firmware is again programmed into the sensor, and the new settings are applied. This entire sequence will typically take about 250 ms to complete.</p>
<dl class="section note"><dt>Note</dt><dd>A single set of measurement queue values should only be optimized <b>once</b>, because new transmit segments will be inserted each time. If your application needs to perform optimization periodically, it should maintain a copy of the original measurement queue values (before optimization) and pass that in again during each call to this function. A copy of the internal <em>measurement_queue_t</em> structure can be obtained using <em><a class="el" href="soniclib_8h.html#a591525a8a8a249db1a0e26504391c8bb" title="Get measurement queue values for a sensor.">ch_meas_get_queue()</a></em>.</dd>
<dd>
This feature is only available for ICU sensors.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a719bb8d611224839c6d9404d339bc9e8" title="Import an externally defined measurement configuration.">ch_meas_import()</a></em>, <em><a class="el" href="soniclib_8h.html#a591525a8a8a249db1a0e26504391c8bb" title="Get measurement queue values for a sensor.">ch_meas_get_queue()</a></em>. </p>

</div>
</div>
<a id="a8224fdbf97c25d75219f9fee87ab9a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8224fdbf97c25d75219f9fee87ab9a98">&#9670;&nbsp;</a></span>ch_meas_remove_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_remove_instruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index_to_remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an instruction(segment) in a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">index_to_remove</td><td>instruction(segment) number to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function removes a measurement instruction(segment) to the measurement specified by <em>meas_num</em>. <em>inst_ptr</em> points to an instruction(segment) descriptor, which must have already been initialized. </p>

</div>
</div>
<a id="a0ee0747d4c1668e07ef242f4c17dbdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee0747d4c1668e07ef242f4c17dbdbf">&#9670;&nbsp;</a></span>ch_meas_remove_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_remove_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index_to_remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an instruction(segment) in a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">index_to_remove</td><td>instruction(segment) number to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function removes a measurement instruction(segment) to the measurement specified by <em>meas_num</em>. <em>inst_ptr</em> points to an instruction(segment) descriptor, which must have already been initialized.</p>
<p>Will be deprecated by the new equivalent function ch_meas_remove_instruction. </p>

</div>
</div>
<a id="a8d2b49af5ae78b7b277666ff7c4f0937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2b49af5ae78b7b277666ff7c4f0937">&#9670;&nbsp;</a></span>ch_meas_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function resets and re-initializes the measurement specified by <em>meas_num</em>. All segments in the measurement are removed.</p>
<p>After calling this function, transmit and receive segments may be added to the measurement. See <em><a class="el" href="soniclib_8h.html#a063940d1f4d8613c4c0abaa421a17b0c" title="Add a segment to a measurement.">ch_meas_add_segment()</a></em>. </p>

</div>
</div>
<a id="a70baf4591a0f4031f566ca7fcb73b0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70baf4591a0f4031f566ca7fcb73b0cd">&#9670;&nbsp;</a></span>ch_meas_samples_to_mm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_meas_samples_to_mm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert sample count to millimeters for a specific measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">num_samples</td><td>sample count to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of millimeters</dd></dl>
<p>This function converts the sample count specified in <em>num_samples</em> and converts it to the corresponding physical distance in millimeters for the specified measurement. The conversion uses values set during device initialization and calibration that describe the internal timing of the sensor.</p>
<p>This function may be helpful when working with both physical distances (as reported by the <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor.">ch_get_range()</a></em> function) and sample-oriented values, such as data obtained from <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor.">ch_get_iq_data()</a></em> or parameters for static target rejection (see <em><a class="el" href="ch__rangefinder_8c.html#ab7b5aecb6cfe54c6d2df428e26192d9a" title="Configure static target rejection.">ch_set_static_range()</a></em>).</p>
<dl class="section note"><dt>Note</dt><dd>The number of samples corresponding to a certain distance is determined by the ODR (output data rate) for the sensor, which is the rate at which the received ultrasound is sampled within each measurement. So, the ODR must be known to calculate this conversion.</dd>
<dd>
In ICU sensors, the ODR is configurable. The default is one sample per 8 transceiver cycles (CH_ODR_FREQ_DIV_8, also known as CH_ODR_DEFAULT). If the default ODR will not be not used, the new ODR must be set for the specified measurement before this function is called, either as a standard parameter during <em><a class="el" href="soniclib_8h.html#a0dfa2a99ca4868b9cd6d363a7f14270e" title="Initialize a measurement.">ch_meas_init()</a></em>, or by calling <em><a class="el" href="soniclib_8h.html#adc5748ec903986b27b78f4a52b8c9e23" title="Set the output data rate for a measurement.">ch_meas_set_odr()</a></em>.</dd></dl>
<p>The <em><a class="el" href="soniclib_8h.html#a290f3e5de2ee174e37ff4522df51d376" title="Convert sample count to millimeters for a sensor.">ch_samples_to_mm()</a></em> function performs the same operation for the default measurement (same as setting <em>meas_num</em> to CH_DEFAULT_MEAS_NUM).</p>
<p>See also <em><a class="el" href="soniclib_8h.html#aa256c720961a6d327c515da60d8071c2" title="Convert millimeters to sample count for a sensor.">ch_mm_to_samples()</a></em>, <em><a class="el" href="soniclib_8h.html#adc5748ec903986b27b78f4a52b8c9e23" title="Set the output data rate for a measurement.">ch_meas_set_odr()</a></em>. </p>

</div>
</div>
<a id="a52398f9f8bf2f5a20531e7c8ab1852fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52398f9f8bf2f5a20531e7c8ab1852fd">&#9670;&nbsp;</a></span>ch_meas_set_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_set_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interval_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the repeat interval for a measurement, in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">interval_ms</td><td>measurement interval, in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the internal measurement interval in the sensor. The sensor will perform a measurement every <em>interval_ms</em> milliseconds. No external trigger is required.</p>
<p>To set the sensing interval with greater precision, use <em><a class="el" href="soniclib_8h.html#a4001469a3a233c39cead6f6624d436eb" title="Set the repeat interval for a measurement, in microseconds.">ch_meas_set_interval_us()</a></em> or <em><a class="el" href="soniclib_8h.html#a88d3915b3152ca1fda21ddddefb95fec" title="Set the repeat interval for a measurement, in sensor RTC clock ticks.">ch_meas_set_interval_ticks()</a></em>.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a8d3ad9e2c87572430228205103a28927" title="Set the internal sensing interval for freerunning mode, in milliseconds.">ch_set_freerun_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#a5c76a6684d06acdd7ff60de902ef9cf0" title="Get the repeat interval for a measurement, in milliseconds.">ch_meas_get_interval()</a></em>. </p>

</div>
</div>
<a id="a88d3915b3152ca1fda21ddddefb95fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d3915b3152ca1fda21ddddefb95fec">&#9670;&nbsp;</a></span>ch_meas_set_interval_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_set_interval_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rtc_ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the repeat interval for a measurement, in sensor RTC clock ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">rtc_ticks</td><td>measurement interval, in sensor RTC clock periods</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the internal measurement interval in the sensor. The sensor will perform a measurement every <em>rtc_ticks</em> sensor RTC clock periods. No external trigger is required.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a52398f9f8bf2f5a20531e7c8ab1852fd" title="Set the repeat interval for a measurement, in milliseconds.">ch_meas_set_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#a2402d08e2043ec130dbbb090b1c67596" title="Get the repeat interval for a measurement, in sensor RTC clock ticks.">ch_meas_get_interval_ticks()</a></em>. </p>

</div>
</div>
<a id="a4001469a3a233c39cead6f6624d436eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4001469a3a233c39cead6f6624d436eb">&#9670;&nbsp;</a></span>ch_meas_set_interval_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_set_interval_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interval_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the repeat interval for a measurement, in microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">interval_us</td><td>measurement interval, in microseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the internal measurement interval in the sensor. The sensor will perform a measurement every <em>interval_us</em> microseconds. No external trigger is required.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a52398f9f8bf2f5a20531e7c8ab1852fd" title="Set the repeat interval for a measurement, in milliseconds.">ch_meas_set_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#a2402d08e2043ec130dbbb090b1c67596" title="Get the repeat interval for a measurement, in sensor RTC clock ticks.">ch_meas_get_interval_ticks()</a></em>. </p>

</div>
</div>
<a id="a3fb6e60f175bbb08c87787c0ac680865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb6e60f175bbb08c87787c0ac680865">&#9670;&nbsp;</a></span>ch_meas_set_iq_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_set_iq_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a5143295fdd1fdd439dad873fb9e04948">ch_output_type_t</a>&#160;</td>
          <td class="paramname"><em>output_format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the I/Q data output format for a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">output_format</td><td>I/Q output format 0=normal (Q,I) pairs; 1=amplitude,threshold pairs, 2=amplitude array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the measurement I/Q data output format. The data may be output in three different formats, based on the value of <em>output_format:</em> </p><ul>
<li>CH_OUTPUT_IQ - Standard pairs of {Q,I} int16_t values</li>
<li>CH_OUTPUT_AMP_THRESH - Output amplitude + threshold uint16_t pair values</li>
<li>CH_OUTPUT_AMP - Output uint16_t amplitude values only</li>
</ul>
<p>See also <em><a class="el" href="soniclib_8h.html#abae9547bfdb9eda44b7f3f44c42d815e" title="Get the I/Q data output format for a measurement.">ch_meas_get_iq_output()</a></em>, <em><a class="el" href="soniclib_8h.html#aab1ee2f0dd09e40fbf286bb1da8b00b8" title="Set data output format and rate.">ch_set_data_output()</a></em>, <em><a class="el" href="soniclib_8h.html#a0dfa2a99ca4868b9cd6d363a7f14270e" title="Initialize a measurement.">ch_meas_init()</a></em>. </p>

</div>
</div>
<a id="acfc7192978564ab0f477ee2132870fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc7192978564ab0f477ee2132870fea">&#9670;&nbsp;</a></span>ch_meas_set_max_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_set_max_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_range_mm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum range in mm for a specific measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">max_range</td><td>maximum range, in millimeters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero if error</dd></dl>
<p>This function sets the maximum detection range for the specified measurement, in millimeters. The detection range setting controls how long the sensor will listen (i.e. how many samples it will capture) during each measurement cycle. (The number of samples is automatically calculated for the specified range.)</p>
<p>Note that this function changes the number of samples in an existing measurement. The existing measurement definition will be shortened or extended to match the new sample count. If the measurement is extended, the new samples will use the same settings as in the final receive segment.</p>
<p>The <em><a class="el" href="soniclib_8h.html#a41a264ebc25b13778176e83c0c910997" title="Set the maximum range for a sensor.">ch_set_max_range()</a></em> function performs the same operation for the default measurement (same as setting <em>meas_num</em> to CH_DEFAULT_MEAS_NUM).</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a7d24256fc81eaadb687786ee41bec7c9" title="Set the sensor sample count for a specific measurement.">ch_meas_set_num_samples()</a></em>, <em><a class="el" href="soniclib_8h.html#acd7763faeec4c696c10410544cb01365" title="Get the maximum range setting in mm for a specific measurement.">ch_meas_get_max_range()</a></em>. </p>

</div>
</div>
<a id="a7d24256fc81eaadb687786ee41bec7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d24256fc81eaadb687786ee41bec7c9">&#9670;&nbsp;</a></span>ch_meas_set_num_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_set_num_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sensor sample count for a specific measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor struct </td></tr>
    <tr><td class="paramname">meas_num</td><td>measurement number </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples during each measurement cycle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful</dd></dl>
<p>This function directly sets the number of samples which the Chirp sensor will obtain during a specific measurement (0 or 1). The number of samples directly corresponds to the range at which the sensor can detect.</p>
<p>Note that this function changes the number of samples in an existing measurement. The existing measurement definition will be shortened or extended to match the new sample count. If the measurement is extended, the new samples will use the same settings as in the final receive segment.</p>
<p>The <em><a class="el" href="soniclib_8h.html#a8a92fdea71bf1aff4b05891a933a5e84" title="Set the sensor sample count directly.">ch_set_num_samples()</a></em> function performs the same operation for the default measurement (same as setting <em>meas_num</em> to CH_DEFAULT_MEAS_NUM).</p>
<p>See also <em><a class="el" href="soniclib_8h.html#acfc7192978564ab0f477ee2132870fea" title="Set the maximum range in mm for a specific measurement.">ch_meas_set_max_range()</a></em>, <em><a class="el" href="soniclib_8h.html#a8a92fdea71bf1aff4b05891a933a5e84" title="Set the sensor sample count directly.">ch_set_num_samples()</a></em>. </p>

</div>
</div>
<a id="adc5748ec903986b27b78f4a52b8c9e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5748ec903986b27b78f4a52b8c9e23">&#9670;&nbsp;</a></span>ch_meas_set_odr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_set_odr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a86140657375a7e7c24ecf430da97c189">ch_odr_t</a>&#160;</td>
          <td class="paramname"><em>odr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the output data rate for a measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the output data rate (ODR) for the sensor. The ODR setting determines the spacing in time (and therefore in measured distance) between the individual sample points within a measurement.</p>
<p>The standard ODR value is CH_ODR_FREQ_DIV_8 (also known as CH_ODR_DEFAULT), or one sample per 8 transceiver cycles. The ODR may be adjusted higher or lower - each higher or value will increase or decrease the output rate (i.e. the time between samples) by a factor of 2. The maximum ODR is CH_ODR_FREQ_DIV_2 (one sample every 2 transceiver cycles); the minimum ODR is CH_ODR_FREQ_DIV_32 (one sample every 32 transceiver cycles).</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a0dfa2a99ca4868b9cd6d363a7f14270e" title="Initialize a measurement.">ch_meas_init()</a></em>, <em><a class="el" href="soniclib_8h.html#abc69e96679d03384c1cf912ebf66c614" title="Get the output data rate for a measurement.">ch_meas_get_odr()</a></em>. </p>

</div>
</div>
<a id="afc64afbffb1f34e6881528e31bce9286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc64afbffb1f34e6881528e31bce9286">&#9670;&nbsp;</a></span>ch_meas_standby()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_meas_standby </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put a measurement in standby mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>number of measurement to place in standby mode</td></tr>
  </table>
  </dd>
</dl>
<p>This function places the specified measurement in standby mode. This measurement's definition will not be used by the sensor - the other measurement definition will be used to perform all readings.</p>
<p>Because there must always be at least one active measurement, this function will activate the other measurement if it was not already active. It is not possible to have both measurements in standby mode simultaneously.</p>
<p>A measurement may be set to initially be in standby mode, see <em><a class="el" href="soniclib_8h.html#a0dfa2a99ca4868b9cd6d363a7f14270e" title="Initialize a measurement.">ch_meas_init()</a></em>.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a5372b50fccbc80b38dab4722dfaed9fc" title="Activate a defined measurement.">ch_meas_activate()</a></em>, <em><a class="el" href="soniclib_8h.html#a20576be17d3be2e6c3293c753c94c434" title="Switch active and standby measurement definitions.">ch_meas_switch()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is only available for ICU sensors. </dd></dl>

</div>
</div>
<a id="a20576be17d3be2e6c3293c753c94c434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20576be17d3be2e6c3293c753c94c434">&#9670;&nbsp;</a></span>ch_meas_switch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_switch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch active and standby measurement definitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_num</td><td>number of measurement to place in standby mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>measurement number of newly active measurement</dd></dl>
<p>This function switches the roles of the two measurement definitions between active and standby. The currently active measurement is put into standby mode, and the standby measurement is made active.</p>
<p>If this function is called when both measurements are active, the next measurement due to operate (the current measurement) will be placed into standby mode, and the other measurement will remain active.</p>
<p>This routine returns the number of the new active measurement. This will be the next measurement performed by the sensor.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a5372b50fccbc80b38dab4722dfaed9fc" title="Activate a defined measurement.">ch_meas_activate()</a></em>, <em><a class="el" href="soniclib_8h.html#afc64afbffb1f34e6881528e31bce9286" title="Put a measurement in standby mode.">ch_meas_standby()</a></em>, <em><a class="el" href="soniclib_8h.html#aa3d2278773b6676145e9d86bb1cdf769" title="Get configuration information for a measurement.">ch_meas_get_info()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is only available for ICU sensors. </dd></dl>

</div>
</div>
<a id="a8421a242bc38e92a27e96814c64c1c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8421a242bc38e92a27e96814c64c1c95">&#9670;&nbsp;</a></span>ch_meas_time_hop_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_time_hop_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable time-hopping on measure period freerunning mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful.</dd></dl>
<p>This function disable the time-hopping for a sensor operating in freerunning mode (<em>CH_MODE_FREERUN</em>).</p>
<dl class="section note"><dt>Note</dt><dd>This function has no effect for a sensor operating in one of the triggered modes</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#aa2b5b2e869a15194c08ae15f0e20cb14" title="Enable time-hopping on measure period freerunning mode.">ch_meas_time_hop_enable()</a></em>, <em><a class="el" href="soniclib_8h.html#a2402d08e2043ec130dbbb090b1c67596" title="Get the repeat interval for a measurement, in sensor RTC clock ticks.">ch_meas_get_interval_ticks()</a></em>, <em><a class="el" href="soniclib_8h.html#a52398f9f8bf2f5a20531e7c8ab1852fd" title="Set the repeat interval for a measurement, in milliseconds.">ch_meas_set_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#a4001469a3a233c39cead6f6624d436eb" title="Set the repeat interval for a measurement, in microseconds.">ch_meas_set_interval_us()</a></em>, <em><a class="el" href="soniclib_8h.html#a88d3915b3152ca1fda21ddddefb95fec" title="Set the repeat interval for a measurement, in sensor RTC clock ticks.">ch_meas_set_interval_ticks()</a></em>. </p>

</div>
</div>
<a id="aa2b5b2e869a15194c08ae15f0e20cb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b5b2e869a15194c08ae15f0e20cb14">&#9670;&nbsp;</a></span>ch_meas_time_hop_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_time_hop_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable time-hopping on measure period freerunning mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful.</dd></dl>
<p>This function enables the time-hopping for a sensor operating in freerunning mode (<em>CH_MODE_FREERUN</em>). The sensor will use its internal real-time clock (RTC) to wake and perform a measurement every <em>measure</em> interval plus a random delay to avoid coexistence with other sensors. Mean measure period is however equals to <em>measure</em> interval.</p>
<dl class="section note"><dt>Note</dt><dd>This function has no effect for a sensor operating in one of the triggered modes.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a8421a242bc38e92a27e96814c64c1c95" title="Disable time-hopping on measure period freerunning mode.">ch_meas_time_hop_disable()</a></em>, <em><a class="el" href="soniclib_8h.html#a2402d08e2043ec130dbbb090b1c67596" title="Get the repeat interval for a measurement, in sensor RTC clock ticks.">ch_meas_get_interval_ticks()</a></em>, <em><a class="el" href="soniclib_8h.html#a52398f9f8bf2f5a20531e7c8ab1852fd" title="Set the repeat interval for a measurement, in milliseconds.">ch_meas_set_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#a4001469a3a233c39cead6f6624d436eb" title="Set the repeat interval for a measurement, in microseconds.">ch_meas_set_interval_us()</a></em>, <em><a class="el" href="soniclib_8h.html#a88d3915b3152ca1fda21ddddefb95fec" title="Set the repeat interval for a measurement, in sensor RTC clock ticks.">ch_meas_set_interval_ticks()</a></em>. </p>

</div>
</div>
<a id="a8f9450f4a5d409c8e1474d4ae078fbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9450f4a5d409c8e1474d4ae078fbe4">&#9670;&nbsp;</a></span>ch_meas_write_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_meas_write_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write measurement configuration to sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function writes a complete measurement queue configuration to the sensor device. The measurement queue settings must have already been defined, by using the standard API functions (initializing one or more measurements and adding a sequence of measurement segments).</p>
<p>This function additionally sanitizes the measurement queue by performing several checks to ensure it is compatible with the selected sensor mode. This function potentially modifies the queue, so users should examine the passed queue after loading it. </p>

</div>
</div>
<a id="aa77a85293f155a6f5c045a15a7154ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77a85293f155a6f5c045a15a7154ad1">&#9670;&nbsp;</a></span>ch_measure_pmut_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_measure_pmut_frequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure PMUT frequency on an ICU device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> config structure for a sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PMUT operating frequency in Hz</dd></dl>
<p>This function must only be called after initialization (ie after calling <a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a>). </p>

</div>
</div>
<a id="ae89c9e6ef3d8a200f741e81dca0e324c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89c9e6ef3d8a200f741e81dca0e324c">&#9670;&nbsp;</a></span>ch_minimal_int_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_minimal_int_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify SonicLib that a sensor interrupt was received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> config structure for a group of sensors </td></tr>
    <tr><td class="paramname">dev_num</td><td>interrupting sensor's device number within group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, non-zero otherwise.</dd></dl>
<p>This function should be called from the board support package when an interrupt from the sensor is received. The <em>dev_num</em> parameter indicates which sensor interrupted.</p>
<p>Unlike <em><a class="el" href="soniclib_8h.html#a68080a85a27dc680ce55c020f575c5c3" title="Run SonicLib&#39;s full-featured interrupt handler.">ch_interrupt()</a></em>, this function does not call the user supplied callback. It is intended to be used when the user would like more control of exactly what happens when an interrupt is received from the sensor.</p>
<p>Other differences from <em><a class="el" href="soniclib_8h.html#a68080a85a27dc680ce55c020f575c5c3" title="Run SonicLib&#39;s full-featured interrupt handler.">ch_interrupt()</a></em>:</p>
<ul>
<li>This function does not disable interrupt handling. This must be done in user code if needed.</li>
<li>This function does not read any metadata from the sensor, with one exception. During sensor programming, this funciton performs one SPI read in order to cause the ASIC to release the interrupt line.</li>
<li>This function does not update state of the dev_ptr</li>
</ul>
<p>See also <em><a class="el" href="soniclib_8h.html#a68080a85a27dc680ce55c020f575c5c3" title="Run SonicLib&#39;s full-featured interrupt handler.">ch_interrupt()</a></em>. </p>

</div>
</div>
<a id="aa256c720961a6d327c515da60d8071c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa256c720961a6d327c515da60d8071c2">&#9670;&nbsp;</a></span>ch_mm_to_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_mm_to_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_mm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert millimeters to sample count for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">num_mm</td><td>number of millimeters to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of samples</dd></dl>
<p>This function converts the distance in millimeters specified by <em>num_mm</em> and converts it to the corresponding number of sensor samples. The conversion uses values set during device initialization and calibration that describe the internal timing of the sensor, which affects how many samples correspond to a given distance.</p>
<p>This function may be helpful when working with both physical distances (as reported by the <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor.">ch_get_range()</a></em> function) and sample-oriented values, such as data obtained from <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor.">ch_get_iq_data()</a></em> or parameters for filtering such as static target rejection (see <em><a class="el" href="ch__rangefinder_8c.html#ab7b5aecb6cfe54c6d2df428e26192d9a" title="Configure static target rejection.">ch_set_static_range()</a></em>).</p>
<dl class="section note"><dt>Note</dt><dd>The number of samples corresponding to a certain distance is determined by the ODR (output data rate) for the sensor, which is the rate at which the received ultrasound is sampled within each measurement. So, the ODR must be known to calculate this conversion. This function always uses the ODR value for the default measurement (CH_DEFAULT_MEAS_NUM). To get the conversion for a specific measurement, use <em><a class="el" href="soniclib_8h.html#a4203c97c07e47db67bf2e1c1eb16b054" title="Convert millimeters to sample count for a specific measurement.">ch_meas_mm_to_samples()</a></em>.</dd>
<dd>
In ICU sensors, the ODR is configurable. The default is one sample per 8 transceiver cycles (CH_ODR_FREQ_DIV_8, also known as CH_ODR_DEFAULT). If the default ODR will not be not used, the new ODR must be applied before this function is called, either as a standard parameter during <em><a class="el" href="soniclib_8h.html#a0dfa2a99ca4868b9cd6d363a7f14270e" title="Initialize a measurement.">ch_meas_init()</a></em>, or by calling <em><a class="el" href="soniclib_8h.html#adc5748ec903986b27b78f4a52b8c9e23" title="Set the output data rate for a measurement.">ch_meas_set_odr()</a></em> using CH_DEFAULT_MEAS_NUM as the measurement number.</dd>
<dd>
For ICU sensors, this function always returns the conversion values for the default measurement. If multiple measurements are being used with different ODR settings, use the <em><a class="el" href="soniclib_8h.html#a4203c97c07e47db67bf2e1c1eb16b054" title="Convert millimeters to sample count for a specific measurement.">ch_meas_mm_to_samples()</a></em> function to get the correct value for the specific measurement.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a290f3e5de2ee174e37ff4522df51d376" title="Convert sample count to millimeters for a sensor.">ch_samples_to_mm()</a></em>, <em><a class="el" href="soniclib_8h.html#adc5748ec903986b27b78f4a52b8c9e23" title="Set the output data rate for a measurement.">ch_meas_set_odr()</a></em>. </p>

</div>
</div>
<a id="a38861d5f023ea837a9ee15bdca5fa114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38861d5f023ea837a9ee15bdca5fa114">&#9670;&nbsp;</a></span>ch_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113">ch_reset_t</a>&#160;</td>
          <td class="paramname"><em>reset_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">reset_type</td><td>type of reset (<em>CH_RESET_HARD</em> or <em>CH_RESET_SOFT</em>)</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets a sensor. The <em>reset_type</em> parameter indicates if a software reset or full hardware reset is requested. </p>

</div>
</div>
<a id="af25e3902b1313e4de920e703564bffb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25e3902b1313e4de920e703564bffb5">&#9670;&nbsp;</a></span>ch_restart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_restart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>This function performs a re-start of a sensor that has previously been initialized and started. The sensor is reset, the sensor firmware is reloaded, and the configuration settings are re-applied. The sensor will not perform the normal calibration steps (including clock calibration) - it will instead use the values saved during a previous initialization.</p>
<p>Normally, this function should not be needed. It may be useful for special error handling or other application-specific requirements.</p>
<p>Different sensor firmware can be loaded, by calling <em><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize the device descriptor for a sensor.">ch_init()</a></em> before this function and specifying a new firmware init routine. This is normally not recommended for applications, but this mechanism is sometimes used internally by SonicLib.</p>
<p>After this routine returns successfully, the sensor should be ready to resume measurements.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a69790de1c39a18e73c4b42d4670e80a8" title="Restart a group of sensors.">ch_group_restart()</a></em>, <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em>. </p>

</div>
</div>
<a id="a3bf5b05b264ae9dce5a4b9f752dceb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf5b05b264ae9dce5a4b9f752dceb24">&#9670;&nbsp;</a></span>ch_samples_to_cycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_samples_to_cycles </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a86140657375a7e7c24ecf430da97c189">ch_odr_t</a>&#160;</td>
          <td class="paramname"><em>odr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert samples to sensor cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_samples</td><td>number of samples </td></tr>
    <tr><td class="paramname">odr</td><td>output data rate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sensor cycles.</dd></dl>
<p>This function takes a count of samples and converts it to the corresponding number of internal sensor cycles. The cycles are the same units used to specify measurement segment lengths.</p>
<p>The <em>odr</em> parameter is the current output data rate setting for the sensor. The ODR affects the timing between samples, and therefore the number of internal cycles per sample.</p>
<p>See also <em>ch_cycles_to_samples</em>, <em>ch_meas_get_odr</em>. </p>

</div>
</div>
<a id="a290f3e5de2ee174e37ff4522df51d376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290f3e5de2ee174e37ff4522df51d376">&#9670;&nbsp;</a></span>ch_samples_to_mm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_samples_to_mm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert sample count to millimeters for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">num_samples</td><td>sample count to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of millimeters</dd></dl>
<p>This function converts the sample count specified in <em>num_samples</em> and converts it to the corresponding physical distance in millimeters. The conversion uses values set during device initialization and calibration that describe the internal timing of the sensor.</p>
<p>This function may be helpful when working with both physical distances (as reported by the <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor.">ch_get_range()</a></em> function) and sample-oriented values, such as data obtained from <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor.">ch_get_iq_data()</a></em> or parameters for static target rejection (see <em><a class="el" href="ch__rangefinder_8c.html#ab7b5aecb6cfe54c6d2df428e26192d9a" title="Configure static target rejection.">ch_set_static_range()</a></em>).</p>
<dl class="section note"><dt>Note</dt><dd>The number of samples corresponding to a certain distance is determined by the ODR (output data rate) for the sensor, which is the rate at which the received ultrasound is sampled within each measurement. So, the ODR must be known to calculate this conversion.</dd>
<dd>
In ICU sensors, the ODR is configurable. The default is one sample per 8 transceiver cycles (CH_ODR_FREQ_DIV_8, also known as CH_ODR_DEFAULT). If the default ODR will not be not used, the new ODR must be specified before this function is called, either as a standard parameter during <em><a class="el" href="soniclib_8h.html#a0dfa2a99ca4868b9cd6d363a7f14270e" title="Initialize a measurement.">ch_meas_init()</a></em>, or by calling <em><a class="el" href="soniclib_8h.html#adc5748ec903986b27b78f4a52b8c9e23" title="Set the output data rate for a measurement.">ch_meas_set_odr()</a></em> using CH_DEFAULT_MEAS_NUM as the measurement number.</dd>
<dd>
For ICU sensors, this function always returns the conversion values for the default measurement. If multiple measurements are being used with different ODR settings, use the <em><a class="el" href="soniclib_8h.html#a70baf4591a0f4031f566ca7fcb73b0cd" title="Convert sample count to millimeters for a specific measurement.">ch_meas_samples_to_mm()</a></em> function to get the correct value for the specific measurement.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#aa256c720961a6d327c515da60d8071c2" title="Convert millimeters to sample count for a sensor.">ch_mm_to_samples()</a></em>, <em><a class="el" href="soniclib_8h.html#adc5748ec903986b27b78f4a52b8c9e23" title="Set the output data rate for a measurement.">ch_meas_set_odr()</a></em>. </p>

</div>
</div>
<a id="a1ea97825e46bd60eeb79cd5a155f80d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea97825e46bd60eeb79cd5a155f80d0">&#9670;&nbsp;</a></span>ch_sensor_is_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_sensor_is_connected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate if a sensor is connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the sensor is connected, 0 otherwise </dd></dl>

</div>
</div>
<a id="a0946a2fe093c2eb4c8de5d4d7535c159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0946a2fe093c2eb4c8de5d4d7535c159">&#9670;&nbsp;</a></span>ch_set_algo_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_algo_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>algo_cfg_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the measurement algorithm configuration data to a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">algo_cfg_ptr</td><td>pointer to a buffer to send configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function writes the configuration data to an algorithm running on the ICU sensor. This interface is independent of the specific algorithm or configuration format.</p>
<p>Normally, this routine will only be used by special applications or libraries which interact with specific sensor firmware. </p>

</div>
</div>
<a id="a0d01cb587379697f451459a2e4204d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d01cb587379697f451459a2e4204d0c">&#9670;&nbsp;</a></span>ch_set_cal_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_cal_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__cal__result__t.html">ch_cal_result_t</a> *&#160;</td>
          <td class="paramname"><em>cal_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the calibration result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">cal_ptr</td><td>pointer to <a class="el" href="structch__cal__result__t.html" title="Calibration result structure.">ch_cal_result_t</a> structure to receive calibration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>WARNING: This function should not be used to set the calibration result to a fixed value, even one individually calculated for each sensor, as this could change over the lifetime of the sensor; rather, this function could be used to update the calibration result if the calibration result calculated by CHx01 at startup (i.e. returned by <a class="el" href="soniclib_8h.html#a28fd271636e1b3aa3137cd812bd6b19c" title="Get the calibration result.">ch_get_cal_result()</a>) is sufficiently different than expected or sensor performance is not good.</p>
<p>This function sets the calibration result with a <a class="el" href="structch__cal__result__t.html" title="Calibration result structure.">ch_cal_result_t</a> structure specified by <em>cal_ptr</em> for the sensor. The <a class="el" href="structch__cal__result__t.html" title="Calibration result structure.">ch_cal_result_t</a> structure contains DCO period and reverse drive cycles.</p>
<p>To use this function, first initialize the <a class="el" href="structch__cal__result__t.html" title="Calibration result structure.">ch_cal_result_t</a> DCO period/reverse drive cycles pair of values</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a28fd271636e1b3aa3137cd812bd6b19c" title="Get the calibration result.">ch_get_cal_result()</a></em>. </p>

</div>
</div>
<a id="a210dcd310e0c16c343f11c2e3c53984f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210dcd310e0c16c343f11c2e3c53984f">&#9670;&nbsp;</a></span>ch_set_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__config__t.html">ch_config_t</a> *&#160;</td>
          <td class="paramname"><em>config_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set multiple configuration settings for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">config_ptr</td><td>pointer to a <a class="el" href="structch__config__t.html" title="Combined configuration structure.">ch_config_t</a> structure containing new configuration values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>This function sets multiple configuration options within the sensor. The configuration settings are passed in a <a class="el" href="structch__config__t.html" title="Combined configuration structure.">ch_config_t</a> structure, whose address is specified by <em>config_ptr</em>. The fields in the <a class="el" href="structch__config__t.html" title="Combined configuration structure.">ch_config_t</a> structure must have been set with your new configuration values before this function is called.</p>
<dl class="section note"><dt>Note</dt><dd>The individual configuration values set by this function may also be set using dedicated single-value functions. These two methods are completely equivalent and may be freely mixed. See <em><a class="el" href="soniclib_8h.html#af427c34df885a028ee0f7cdddc981001" title="Configure a sensor for the specified operating mode.">ch_set_mode()</a></em>, <em><a class="el" href="soniclib_8h.html#a41a264ebc25b13778176e83c0c910997" title="Set the maximum range for a sensor.">ch_set_max_range()</a></em>, <em><a class="el" href="soniclib_8h.html#a8d3ad9e2c87572430228205103a28927" title="Set the internal sensing interval for freerunning mode, in milliseconds.">ch_set_freerun_interval()</a></em>, <em><a class="el" href="ch__rangefinder_8c.html#ab7b5aecb6cfe54c6d2df428e26192d9a" title="Configure static target rejection.">ch_set_static_range()</a></em>, <em><a class="el" href="ch__rangefinder_8c.html#a7e948bfbdc2cbca2f04bc97459541e5f" title="Set detection thresholds.">ch_set_thresholds()</a></em>, and <em><a class="el" href="soniclib_8h.html#ab462c77e75fd5b959eb3d49e918d49e8" title="Configure target interrupt filtering mode.">ch_set_target_interrupt()</a></em>. </dd></dl>

</div>
</div>
<a id="aab1ee2f0dd09e40fbf286bb1da8b00b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1ee2f0dd09e40fbf286bb1da8b00b8">&#9670;&nbsp;</a></span>ch_set_data_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_data_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__output__t.html">ch_output_t</a> *&#160;</td>
          <td class="paramname"><em>output_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set data output format and rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">output_ptr</td><td>pointer to the data output type, including format and decimation factor</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets both the data output format type and rate for sample data within a measurement. The values are passed in a <em><a class="el" href="structch__output__t.html" title="Data output structure.">ch_output_t</a></em> structure specified by <em>output_ptr</em>, which contains two fields, <em>output_type</em> and <em>decimation_factor</em>. The decimation factor is equivalent to the sample output data rate (ODR) of the sensor, expressed differently.</p>
<p>The possible values for output_type are:</p><ul>
<li>CH_OUTPUT_IQ - Standard pairs of {Q,I} int16_t values (<em><a class="el" href="structch__iq__sample__t.html" title="Sensor I/Q data value.">ch_iq_sample_t</a></em>)</li>
<li>CH_OUTPUT_AMP_THRESH - Output amplitude + threshold uint16_t pair values (<em><a class="el" href="structch__amp__thresh__t.html" title="Sensor combined amplitude + detection threshold sample value.">ch_amp_thresh_t</a></em>)</li>
<li>CH_OUTPUT_AMP - Output uint16_t amplitude values only</li>
</ul>
<p>The possible values for decimation_factor and the equivalent output rate (ODR) values are as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Decimation Factor   </th><th class="markdownTableHeadNone">ODR Value   </th><th class="markdownTableHeadNone">Sample Rate vs. Default    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CH_DECIMATION_NONE   </td><td class="markdownTableBodyNone">CH_ODR_FREQ_DIV_8 (CH_ODR_DEFAULT)   </td><td class="markdownTableBodyNone">default    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CH_DECIMATION_0_25   </td><td class="markdownTableBodyNone">CH_ODR_FREQ_DIV_2   </td><td class="markdownTableBodyNone">4 x default    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CH_DECIMATION_0_50   </td><td class="markdownTableBodyNone">CH_ODR_FREQ_DIV_4   </td><td class="markdownTableBodyNone">2 x default    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CH_DECIMATION_2   </td><td class="markdownTableBodyNone">CH_ODR_FREQ_DIV_16   </td><td class="markdownTableBodyNone">1/2 default    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CH_DECIMATION_3   </td><td class="markdownTableBodyNone"><em>no</em> <em>equivalent</em>   </td><td class="markdownTableBodyNone">1/3 default - only in special CHx01 f/w    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CH_DECIMATION_4   </td><td class="markdownTableBodyNone">CH_ODR_FREQ_DIV_32   </td><td class="markdownTableBodyNone">1/4 default   </td></tr>
</table>
<p>For ICU sensors, both measurements will be set to the specified output type. To change the output format for a single measurement, use <em><a class="el" href="soniclib_8h.html#a3fb6e60f175bbb08c87787c0ac680865" title="Set the I/Q data output format for a measurement.">ch_meas_set_iq_output()</a></em>. To change the output data rate for a single measurement, use <em><a class="el" href="soniclib_8h.html#adc5748ec903986b27b78f4a52b8c9e23" title="Set the output data rate for a measurement.">ch_meas_set_odr()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>For CH101 and CH201 sensors, this function is only available in select sensor firmware versions. </dd></dl>

</div>
</div>
<a id="a0fd13d9b1ba62dca747988e1b4abc1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd13d9b1ba62dca747988e1b4abc1e0">&#9670;&nbsp;</a></span>ch_set_data_ready_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_data_ready_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delay_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set data ready interrupt delay interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">delay_ms</td><td>time, in milliseconds, for sensor to delay after measurement</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets a delay interval that will cause the sensor to wait slightly after a measurement completes before issuing a data ready interrupt. It is used in special circumstances to handle unusual timing constraints. Normally, this function should not be used.</p>
<p><em>delay_ms</em> specifies the time, in milliseconds, that the sensor will delay after the measurement completes before generating the interrupt signal.</p>
<p>The granularity of this delay is limited by the period of the sensor's internal wake cycle timer, so in some cases the <em>delay_ms</em> value will be increased to match the next whole number of wake cycles. (A granularity of about 4 ms is typical.)</p>
<p>The <em><a class="el" href="soniclib_8h.html#aacf8233ee597b2795c3e478e70f3aefd" title="Get data ready interrupt delay interval.">ch_get_data_ready_delay()</a></em> function may be used to determine the actual delay period, after any adjustment to match the sensor wake cycles.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="afa29a954eea0f9c7d1f4172390aa02b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa29a954eea0f9c7d1f4172390aa02b8">&#9670;&nbsp;</a></span>ch_set_freerun_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_freerun_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interval_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the internal sensing interval for freerunning mode, in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">interval_ms</td><td>interval between samples, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if arguments are invalid.</dd></dl>
<p>This function sets the sample interval for a sensor operating in freerunning mode (<em>CH_MODE_FREERUN</em>). The sensor will use its internal clock to wake and perform a measurement every <em>interval_ms</em> milliseconds. A value of zero for <em>interval_ms</em> is not valid.</p>
<p>To set the sensing interval with greater precision, use <em><a class="el" href="soniclib_8h.html#a3312f5018fc80ed86d32205efd643e48" title="Set the internal sensing interval for freerunning mode, in microseconds.">ch_set_freerun_interval_us()</a></em> or <em><a class="el" href="soniclib_8h.html#af210149982301db673e5ad03095d8b06" title="Set the internal sensing interval for freerunning mode, in RTC clock ticks.">ch_set_freerun_interval_ticks()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This function has no effect for a sensor operating in one of the triggered modes. The sample interval for a triggered device is determined by the external trigger timing.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a2f5c83e0d155e17ab8ac74951f44ea02" title="Get the internal sensing timing interval for a sensor, in milliseconds.">ch_get_freerun_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#a3312f5018fc80ed86d32205efd643e48" title="Set the internal sensing interval for freerunning mode, in microseconds.">ch_set_freerun_interval_us()</a></em>, <em>ch_set_sense_interval_cycles()</em>. </p>

</div>
</div>
<a id="aa250f16c28b6ff8aa11b66ffc69c1a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa250f16c28b6ff8aa11b66ffc69c1a0c">&#9670;&nbsp;</a></span>ch_set_freerun_interval_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_freerun_interval_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interval_ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the internal sensing interval for freerunning mode, in RTC clock ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">interval_ticks</td><td>interval between samples, in sensor RTC clock periods </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if arguments are invalid.</dd></dl>
<p>This function sets the sample interval for a sensor operating in freerunning mode (<em>CH_MODE_FREERUN</em>). The sensor will use its internal real-time clock (RTC) to wake and perform a measurement every <em>interval_ticks</em> clock periods. A value of zero for <em>interval_ticks</em> is not valid.</p>
<dl class="section note"><dt>Note</dt><dd>This function has no effect for a sensor operating in one of the triggered modes. The sample interval for a triggered device is determined by the external trigger timing.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#aaa6ab6e5862a95c8610a176bf3e88554" title="Get the internal sensing timing interval for a sensor, in RTC clock ticks.">ch_get_freerun_interval_ticks()</a></em>, <em><a class="el" href="soniclib_8h.html#a8d3ad9e2c87572430228205103a28927" title="Set the internal sensing interval for freerunning mode, in milliseconds.">ch_set_freerun_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#a3312f5018fc80ed86d32205efd643e48" title="Set the internal sensing interval for freerunning mode, in microseconds.">ch_set_freerun_interval_us()</a></em>. </p>

</div>
</div>
<a id="ae3c0d862213e31f2f8f6fc16775aa01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c0d862213e31f2f8f6fc16775aa01e">&#9670;&nbsp;</a></span>ch_set_freerun_interval_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_freerun_interval_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interval_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the internal sensing interval for freerunning mode, in microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">interval_us</td><td>interval between samples, in microseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if arguments are invalid.</dd></dl>
<p>This function sets the sample interval for a sensor operating in freerunning mode (<em>CH_MODE_FREERUN</em>). The sensor will use its internal clock to wake and perform a measurement every <em>interval_us</em> microseconds. A value of zero for <em>interval_us</em> is not valid.</p>
<dl class="section note"><dt>Note</dt><dd>This function has no effect for a sensor operating in one of the triggered modes. The sample interval for a triggered device is determined by the external trigger timing.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a94c77bb8b753ccc41de9b11f316e9c7e" title="Get the internal sensing timing interval for a sensor, in microseconds.">ch_get_freerun_interval_us()</a></em>, <em><a class="el" href="soniclib_8h.html#a8d3ad9e2c87572430228205103a28927" title="Set the internal sensing interval for freerunning mode, in milliseconds.">ch_set_freerun_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#af210149982301db673e5ad03095d8b06" title="Set the internal sensing interval for freerunning mode, in RTC clock ticks.">ch_set_freerun_interval_ticks()</a></em>. </p>

</div>
</div>
<a id="a5c6b0cc10159a9a9bb4dd74f38384d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6b0cc10159a9a9bb4dd74f38384d3a">&#9670;&nbsp;</a></span>ch_set_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_frequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>request_op_freq_hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the operating frequency of a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">request_op_freq_hz</td><td>requested operating frequency in Hz</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function requests a desired acoustic operating frequency for a sensor. This is the primary frequency of the ultrasonic pulse that is emitted by the device when transmitting.</p>
<p>The <em>request_op_freq_hz</em> parameter specifies the frequency, in Hz, that is requested. The operating frequency for the sensor will be set as close as possible to this value. The operating frequency cannot be set to a value that is outside the typical operating frequency range for the sensor model.</p>
<p>In general, the actual operating frequency will be slightly different than the requested value. Use <em><a class="el" href="soniclib_8h.html#a7ae60d24c0b1d0fb5f06e2449c0fa149" title="Get the operating frequency of a sensor.">ch_get_frequency()</a></em> to obtain the sensor's operating frequency after the adjustment.</p>
<p>Often, a group of sensors will be set to a common acoustic operating frequency to optimize the transmit/receive efficiency for sensors operating in paired pitch/catch operation. Use <em><a class="el" href="soniclib_8h.html#a5c373443ede97b6665a9919b23074328" title="Set the operating frequency for a group of sensors.">ch_group_set_frequency()</a></em>, instead of this function, to set all sensors in a group to a common value. That function can automatically apply a calculated value based on the sensors' natural frequencies.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a7ae60d24c0b1d0fb5f06e2449c0fa149" title="Get the operating frequency of a sensor.">ch_get_frequency()</a></em>, <em><a class="el" href="soniclib_8h.html#a5c373443ede97b6665a9919b23074328" title="Set the operating frequency for a group of sensors.">ch_group_set_frequency()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>For CH101 and CH201 sensors, this function is only available in select sensor firmware versions. </dd></dl>

</div>
</div>
<a id="ab06071a7f3eeb6376fcf9ab4a2da9a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06071a7f3eeb6376fcf9ab4a2da9a2e">&#9670;&nbsp;</a></span>ch_set_init_firmware()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_init_firmware </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a6c5f9dbeb75e38d6e3b81540a35b7fe0">ch_fw_init_func_t</a>&#160;</td>
          <td class="paramname"><em>fw_init_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the init firmware to use for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">fw_init_func</td><td>pointer to the sensor init firmware initialization function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function is used to define the init firmware for a sensor if the main firwmware (determined with ch_init) doesn't have initialization features in it. It can be necessary to set a specific initialization firmware (with tx optimization) if using measure optimization API.</p>
<dl class="section note"><dt>Note</dt><dd>This function only performs internal initialization of data structures, etc. It does not actually initialize the physical sensor device(s). See <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em>, <em><a class="el" href="soniclib_8h.html#af25e3902b1313e4de920e703564bffb5" title="Restart a sensor.">ch_restart()</a></em>, <em><a class="el" href="soniclib_8h.html#a69790de1c39a18e73c4b42d4670e80a8" title="Restart a group of sensors.">ch_group_restart()</a></em> and <em><a class="el" href="soniclib_8h.html#a6d21dc9fdd39ade2eef9c269ba027272" title="Optimize ultrasound measurement sequences for a sensor.">ch_meas_optimize()</a></em>. </dd></dl>

</div>
</div>
<a id="a1ddffdfb6704d3598c34f7ba93094bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddffdfb6704d3598c34f7ba93094bbd">&#9670;&nbsp;</a></span>ch_set_interrupt_drive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_interrupt_drive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a3406ad6d96900bf23674fc44468caf5d">ch_interrupt_drive_t</a>&#160;</td>
          <td class="paramname"><em>drive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt drive (open drain or push pull) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">drive</td><td>CH_INTERRUPT_DRIVE_OPEN_DRAIN for open drain interrupt drive, CH_INTERRUPT_DRIVE_PUSH_PULL for push pull drive</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the sensor interrupt to use an open-drain or push-pull drive. In open drain, the sensor will actively drive the line low and use a pull-up resistor for the hight level. In push-pull drive, the sensor will actively drive the line both low and high. Additionally, the pull-up resistor on the interrupt pin used for hardware trigger is disabled. By default, ICU sensors use open drain interrupt drive (CH_INTERRUPT_DRIVE_OPEN_DRAIN).</p>
<p>To use this function, set <em>drive</em> to CH_INTERRUPT_DRIVE_OPEN_DRAIN to enable open drain drive. Set <em>drive</em> to CH_INTERRUPT_DRIVE_PUSH_PULL to use push-pull drive.</p>
<dl class="section note"><dt>Note</dt><dd>This option is only available for ICU sensors. CH101 and CH201 sensors always use active-high, pull low interrupts. Attempting to set <em>drive</em> to CH_INTERRUPT_MODE_PUSH_PULL on a CH101 or CH201 will return an error. </dd></dl>

</div>
</div>
<a id="ab1611f339f145d08e71ed5405d72e1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1611f339f145d08e71ed5405d72e1bc">&#9670;&nbsp;</a></span>ch_set_interrupt_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_interrupt_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a4962ca7e356fbfa6e40863fe5abf519c">ch_interrupt_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt mode (pulsed or latching) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">mode</td><td>CH_INTERRUPT_MODE_PULSE for pulse interrupt mode, CH_INTERRUPT_MODE_LATCH for latching mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the sensor interrupt to use a pulsed or latching level change. In pulse mode, the sensor will briefly change the INT line level and then restore it to the original state. In latching mode, the sensor will change the INT line level, and it will stay at that level until reset by the interrupt handler in the board support package. By default, ICU sensors use latching interrupt mode (CH_INTERRUPT_MODE_LATCH).</p>
<p>To use this function, set <em>mode</em> to CH_INTERRUPT_MODE_PULSE to enable pulsed interrupt mode. Set <em>mode</em> to CH_INTERRUPT_MODE_LATCH to disable the pulse interrupt mode and use latching behavior.</p>
<dl class="section note"><dt>Note</dt><dd>This option is only available for ICU sensors. CH101 and CH201 sensors always use pulse interrupt mode for normal sensor interrupts. Attempting to set <em>mode</em> to CH_INTERRUPT_MODE_LATCH on a CH101 or CH201 will return an error. </dd></dl>

</div>
</div>
<a id="a41a264ebc25b13778176e83c0c910997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a264ebc25b13778176e83c0c910997">&#9670;&nbsp;</a></span>ch_set_max_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_max_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum range for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">max_range</td><td>maximum range, in millimeters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero if error</dd></dl>
<p>This function sets the maximum detection range for the sensor, in millimeters. The detection range setting controls how long the sensor will listen (i.e. how many samples it will capture) during each measurement cycle. (The number of samples is automatically calculated for the specified range.)</p>
<p>For ICU sensors, this function always controls the default measurement definition. To specify which measurement to modify, use the <em><a class="el" href="soniclib_8h.html#acfc7192978564ab0f477ee2132870fea" title="Set the maximum range in mm for a specific measurement.">ch_meas_set_max_range()</a></em> function.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a8a92fdea71bf1aff4b05891a933a5e84" title="Set the sensor sample count directly.">ch_set_num_samples()</a></em>, <em><a class="el" href="soniclib_8h.html#a96b6bb2df00b9feb43955902c55835f7" title="Get the maximum range setting in mm for a sensor.">ch_get_max_range()</a></em>, <em><a class="el" href="soniclib_8h.html#a210dcd310e0c16c343f11c2e3c53984f" title="Set multiple configuration settings for a sensor.">ch_set_config()</a></em>. </p>

</div>
</div>
<a id="af427c34df885a028ee0f7cdddc981001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af427c34df885a028ee0f7cdddc981001">&#9670;&nbsp;</a></span>ch_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">ch_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a sensor for the specified operating mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">mode</td><td>the new operating mode for the sensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful.</dd></dl>
<p>This function sets the sensor to operate in the specified mode, which must be one of the following:</p><ul>
<li><em>CH_MODE_IDLE</em> - low power idle mode, no measurements take place</li>
<li><em>CH_MODE_FREERUN</em> - free-running mode, sensor uses internal clock to wake and measure</li>
<li><em>CH_MODE_TRIGGERED_TX_RX</em> - hardware-triggered, sensor both transmits and receives</li>
<li><em>CH_MODE_TRIGGERED_RX_ONLY</em> - hardware triggered, sensor only receives</li>
<li><em>CH_MODE_CONTINUOUS_RX</em> - (ICU parts only) In this mode, the sensor receives continuously. There is no frame-based trigger. Receive samples are double-buffered. While the host is reading one buffer, the sensor is writing new samples into the other buffer. </li>
</ul>

</div>
</div>
<a id="a8a92fdea71bf1aff4b05891a933a5e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a92fdea71bf1aff4b05891a933a5e84">&#9670;&nbsp;</a></span>ch_set_num_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_num_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sensor sample count directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor struct </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples during each measurement cycle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful</dd></dl>
<p>This function directly sets the number of samples which the Chirp sensor will perform during a single measurement cycle. The number of samples directly corresponds to the range at which the sensor can detect.</p>
<p>For ICU sensors, note that this function changes the number of samples in an existing measurement. The existing measurement definition will be shortened or extended to match the new sample count. If the measurement is extended, the new samples will use the same settings as in the final receive segment. This function always controls the default measurement definition. To specify which measurement to modify, use the <em><a class="el" href="soniclib_8h.html#a7d24256fc81eaadb687786ee41bec7c9" title="Set the sensor sample count for a specific measurement.">ch_meas_set_num_samples()</a></em> function.</p>
<dl class="section note"><dt>Note</dt><dd>Often, the sample is count is not set using this function, but is instead set indirectly using <em><a class="el" href="soniclib_8h.html#a41a264ebc25b13778176e83c0c910997" title="Set the maximum range for a sensor.">ch_set_max_range()</a></em>, which will automatically set the sample count based on a specified range in millimeters.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a41a264ebc25b13778176e83c0c910997" title="Set the maximum range for a sensor.">ch_set_max_range()</a></em>, <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em>. </p>

</div>
</div>
<a id="a50819630a6c6dc83303090054413866d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50819630a6c6dc83303090054413866d">&#9670;&nbsp;</a></span>ch_set_pmut_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_pmut_clock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#aca9006600c4c232750578f7ed6c0416e">ch_pmut_clk_cfg_t</a>&#160;</td>
          <td class="paramname"><em>clock_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure ultrasound transducer clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">clock_cfg</td><td>clock configuration setting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function configures the PMUT clock input and output settings to allow the multiple sensors to share a common clock signal. One sensor may be set to output the signal from the PMUT clock, while others may be set to use that signal as a clock input. This permits very exact frequency matching for critical applications. Alternatively, all sensors may be set to use an independent, external clock signal.</p>
<p>This function may only be called after <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em> has initialized the sensors. The original PMUT clock settings will be modified, and the new settings will be applied immediately. The PMUT clock settings must be set separately for each sensor.</p>
<ul>
<li>Normally, the PMUT clock is internal and the signal is not output on the sensor MUTCLK pad. This function is not needed in this case. (This is the default CH_PMUT_CLK_DEFAULT configuration.)</li>
<li>To enable output of the sensor's PMUT clock on the MUTCLK pad, set <em>clock_cfg</em> to CH_PMUT_CLK_OUTPUT_AUTO or CH_PMUT_CLK_OUTPUT_ENABLE. The AUTO setting allows the ICU part to control the power state of the clock. In this case, the clock will only be available while the ICU part is actively performing a measurement. This is a good option to use when multiple parts will be active simultaneously. The ENABLE option will unconditionally force the clock on. This can be used in situations where the clock should be available even if the part providing it is inactive, such as during transmit optimization.</li>
<li>The output frequency of the signal on the pad will be 16 times the sensor's acoustic operating frequency.</li>
<li>To use an input signal on the MUTCLK pad as the external PMUT clock source, set <em>clock_cfg</em> to CH_PMUT_CLK_SRC_EXTERNAL. In this configuration, the sensor's PMUT will operate at 1/16 the input clock signal frequency.</li>
<li>To restore the default PMUT clock configuration (i.e. to un-do either operation), set <em>clock_cfg</em> to CH_PMUT_CLK_DEFAULT.</li>
</ul>
<p>When one sensor supplies the clock for one or more other sensors, the sequence of enabling and disabling the clock settings across the sensors is important. The clock source must be present whenever a secondary sensor is configured to use an external clock source.</p><ul>
<li>When enabling, the clock source sensor should be set to CH_PMUT_CLK_OUTPUT_AUTO or CH_PMUT_CLK_OUTPUT_ENABLE first, then the other sensor(s) should be set to CH_PMUT_CLK_SRC_EXTERNAL.</li>
<li>When disabling, the secondary sensor(s) should be set to CH_PMUT_CLK_DEFAULT first, then the clock source sensor should be set to CH_PMUT_CLK_DEFAULT.</li>
</ul>
<p>If an independent clock source (not from a sensor) is used, that input signal must be present and <em><a class="el" href="soniclib_8h.html#ac5702e109dfbbd351a32df3df36c6e1b" title="Specify the transducer clock input frequency for a group of sensors.">ch_group_set_pmut_clock_freq()</a></em> must be called to specify the clock frequency before the sensors are set to CH_PMU_CLK_SRC_EXTERNAL.</p>
<p>The <em><a class="el" href="soniclib_8h.html#a7ae60d24c0b1d0fb5f06e2449c0fa149" title="Get the operating frequency of a sensor.">ch_get_frequency()</a></em> function will report the current acoustic operating frequency of the PMUT, regardless of the clock source. So, if the sensor is using an external clock source, the indicated frequency will match that of the sensor supplying the clock signal, or 1/16 the input clock rate if an independent signal.</p>
<p>Only one shared PMUT clock signal can be used within a sensor group. Individual sensors are not required to use the shared clock.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a80da2e1dc19b0f3a40c775b818ead954" title="Get ultrasound transducer clock configuration.">ch_get_pmut_clock()</a></em>, <em><a class="el" href="soniclib_8h.html#ac5702e109dfbbd351a32df3df36c6e1b" title="Specify the transducer clock input frequency for a group of sensors.">ch_group_set_pmut_clock_freq()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is not available on CH101 or CH201 sensors. </dd></dl>

</div>
</div>
<a id="a5e0552ddb44341f86d96a9c5b4d9a1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0552ddb44341f86d96a9c5b4d9a1ca">&#9670;&nbsp;</a></span>ch_set_rtc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_rtc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a95396c4034eb6e41fffcfa7d9dbcd830">ch_rtc_src_t</a>&#160;</td>
          <td class="paramname"><em>rtc_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rtc_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the sensor real-time clock (RTC). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">rtc_source</td><td>RTC source (internal or external) </td></tr>
    <tr><td class="paramname">rtc_freq</td><td>RTC frequency in Hz, or CH_RTC_USE_BUS_SPEED, or zero to use factory test result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function changes the default real-time clock (RTC) configuration to meet special requirements and system limitations. In most applications, this function is not needed and should not be called.</p>
<p>Two options may be set. For the internal RTC clock, this function can specify alternatives to the standard clock calibration. Or, this function can indicate that an external clock source be used to drive the sensor's RTC functions.</p>
<p>An accurate measurement of the sensor's RTC clock is an important part of the time-of-flight calculations performed by the ultrasonic sensor and SonicLib. Any inaccuracy in the RTC frequency value will directly result in inaccuracy in time-of-flight, and therefore range, measurements.</p>
<h3>Internal RTC Calibration</h3>
<p>Normally, the sensor's internal RTC clock frequency is measured during sensor initialization, using an external timed pulse (typically 100 ms) on the sensor INT line. This pulse takes place during <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em>. Using a timed calibration pulse is recommended, because it gives the best overall sensor accuracy. In some situations, however, it may be impossible or inconvenient to apply a sufficiently accurate timed pulse to calibrate the RTC. This function provides two alternative ways to set the frequency value, with some sacrifice in ultimate sensor accuracy.</p>
<p>This function can specify the frequency, in Hz, for the RTC using either the stored factory test result or a custom value. This function does not actually change the sensor's internal RTC frequency, it simply sets the numeric value that will be used in calculations where the RTC frequency is needed.</p>
<h4>Using the Factory RTC Calibration</h4>
<p>ICU sensors contain factory test data that includes a measurement of the sensor's internal RTC frequency. This value provides a reasonable substitute for performing full calibration using a calibration pulse.</p>
<p>To use the factory RTC calibration data, specify <em>CH_RTC_SRC_INTERNAL</em> for <em>rtc_source</em> and a value of zero for <em>rtc_freq</em>.</p>
<p>Factory RTC calibration values are not available for CH101 or CH201 sensors.</p>
<h4>Using the I/O Bus Clock to Estimate RTC Frequency</h4>
<p>In some cases, it is possible to use the I/O bus clock as a reference for calibrating the RTC. (This feature is only available in select sensor f/w variants.)</p>
<p>To use the bus clock for calibration, specify <em>CH_RTC_SRC_INTERNAL</em> for <em>rtc_source</em>, and set <em>rtc_freq</em> to <em>CH_RTC_USE_BUS_SPEED</em>.</p>
<p>For CH101/CH201 sensor types that support this calibration mode, the I2C bus clock (SCL) speed is assumed to be 400000 Hz by default. If a different, more accurate value for the bus clock speed is available, it can be specified by defining <em>CHIRP_I2C_BUS_SPEED_HZ</em> in the <b><a class="el" href="chirp__board__config_8h_source.html">chirp_board_config.h</a></b> file in the board support package, and setting the value to the correct bus speed. Inaccuracies in the bus clock rate value will affect frequency and range measurements by the sensor.</p>
<h4>Supplying an Estimated RTC Frequency</h4>
<p>If <em>rtc_freq</em> is not zero or CH_RTC_USE_BUS_SPEED, the specified value will be used in all calculations requiring the RTC frequency. Normal calibration using a pulse is not performed. The <em>rtc_freq</em> value should be the best available estimate of the RTC frequency for this device.</p>
<p>To use an estimated RTC frequency, specify <em>CH_RTC_SRC_INTERNAL</em> for <em>rtc_source</em>, and set <em>rtc_freq</em> to the approximate RTC frequency, in Hz.</p>
<p>If no other estimate is available, <em>rtc_freq</em> may be specified as <em>CH_RTC_FREQ_TYPICAL</em> (29000 Hz) for a rough approximation of a typical RTC frequency.</p>
<p>This option is a last choice, due to the impact on measurement accuracy, but it will allow measurements to be completed.</p>
<h3>Using an External RTC Clock</h3>
<p>This function can also set the source of the sensor's real-time clock. By default, the sensor will use its internal oscillator as the RTC clock time base. To use the internal RTC, no special action is required, and this routine does not have to be called unless you are changing the calibration values described above.</p>
<p>For enhanced timing accuracy, an external clock source (e.g. crystal oscillator) may be connected to the ICU sensor. This may be used to maintain a more exact measurement interval for sensors operating in free-running mode (CH_MODE_FREERUN).</p>
<p>To enable an external clock source for the RTC, set <em>rtc_source</em> to <em>CH_RTC_SRC_EXTERNAL</em>, and set <em>rtc_freq</em> to the frequency of the clock signal in Hz (e.g. 32768 for a 32.768 kHz crystal).</p>
<h3>When to Call this Function</h3>
<p>This function should be called after <em><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize the device descriptor for a sensor.">ch_init()</a></em> but before <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em>. This function must be called before <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em>, because RTC calibration is normally done then. When this function is used, the sensor will not require or perform automatic RTC calibration using a timed pulse.</p>
<p>All sensors in a sensor group must use the same calibration method, automatic (default) or manual (using this routine for each sensor in the group before <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em>).</p>
<dl class="section note"><dt>Note</dt><dd>This function may only be called during sensor initialization, after <em><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize the device descriptor for a sensor.">ch_init()</a></em> and before <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors.">ch_group_start()</a></em>. Use at any other time will result in undefined behavior.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a3157748b36bfb84930fd16ab06570eb7" title="Get the sensor real-time clock (RTC) frequency, in Hz.">ch_get_rtc_frequency()</a></em>. </p>

</div>
</div>
<a id="aba0abd6a2546fb40cb8fc9b832a6d63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0abd6a2546fb40cb8fc9b832a6d63b">&#9670;&nbsp;</a></span>ch_set_rx_low_gain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_rx_low_gain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the receive low-gain sample count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples that have low gain at beginning of measurement</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the receive (rx) low-gain range in the sensor. The low-gain range consists of samples at the beginning of a measurement that will have a lower gain applied during the sensor receive operation. (These samples correspond to the closest distances from the sensor.)</p>
<p>The low-gain range must be less than the current maximum range setting. If <em>num_samples</em> is greater than or equal to the maximum range setting, it will automatically be reduced.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a1379e10c0c9af1f916ca08092916227b" title="Get the receive low-gain sample count.">ch_get_rx_low_gain()</a></em>, <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle.">ch_get_num_samples()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only available in CH201 sensor firmware. </dd></dl>

</div>
</div>
<a id="aee0bbd8d9e2d5e1064fa8eb9ace180f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0bbd8d9e2d5e1064fa8eb9ace180f7">&#9670;&nbsp;</a></span>ch_set_rx_pretrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_set_rx_pretrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable receive-only sensor pre-triggering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group descriptor structure.">ch_group_t</a> group descriptor structure </td></tr>
    <tr><td class="paramname">enable</td><td>1 to enable pre-triggering, 0 to disable</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables or disables pre-triggering of the receive-only sensor during Pitch-Catch operation. When pre-triggering is enabled, sensors in CH_MODE_TRIGGERED_RX_ONLY mode will be triggered slightly before sensors in CH_MODE_TRIGGERED_TX_RX mode when <em><a class="el" href="soniclib_8h.html#aa4e917eea19df611680dc97e2401db3a" title="Trigger a measurement on a group of sensors.">ch_group_trigger()</a></em> is called. This improves the ability of a receive-only sensor to detect the transmitted pulse at very short distances.</p>
<p>If enabled, pre-triggering is used for all receive-only sensors in the sensor group.</p>
<p>To use this function, set <em>enable</em> to 1 to enable pre-triggering, or 0 to disable pre-triggering.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a295d2393cc610d13bfa63987de35c303" title="Get receive-only sensor pre-triggering setting.">ch_get_rx_pretrigger()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Enabling pre-triggering will reduce the maximum range of the receive-only sensor(s), relative to the setting specified in <em><a class="el" href="soniclib_8h.html#a41a264ebc25b13778176e83c0c910997" title="Set the maximum range for a sensor.">ch_set_max_range()</a></em>, by about 200mm. You may want to increase the maximum range setting accordingly. </dd></dl>

</div>
</div>
<a id="ae8e112bfba8024d98de650b8f2184f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e112bfba8024d98de650b8f2184f9b">&#9670;&nbsp;</a></span>ch_set_sample_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_sample_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interval_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the internal sensing interval (deprecated). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">interval_ms</td><td>interval between samples, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if arguments are invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is DEPRECATED and is provided for backwards compatibility only. New applications should use the equivalent <em><a class="el" href="soniclib_8h.html#a8d3ad9e2c87572430228205103a28927" title="Set the internal sensing interval for freerunning mode, in milliseconds.">ch_set_freerun_interval()</a></em> function.</dd></dl>
<p>This function sets the sample interval for a sensor operating in freerunning mode (<em>CH_MODE_FREERUN</em>). The sensor will use its internal clock to wake and perform a measurement every <em>interval_ms</em> milliseconds. A value of zero for <em>interval_ms</em> is not valid. </p>

</div>
</div>
<a id="a183c63e3d6794848986656895b918d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183c63e3d6794848986656895b918d10">&#9670;&nbsp;</a></span>ch_set_sample_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_sample_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sample window for amplitude averaging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">start_sample</td><td>sample number of first sample in window </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples to include in window</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero if error</dd></dl>
<p>This function sets the sample range to be included in the sample window used for amplitude averaging. <em>start_sample</em> is the number of the first sample that will be included in the averaging window. <em>num_samples</em> is the total number of samples that will be included.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#aecd6ee85a061f71da4e98aab683fef5b" title="Get the averaged measured amplitude over the sample window.">ch_get_amplitude_avg()</a></em>, <em><a class="el" href="soniclib_8h.html#a56c552c6a09c2400766ee329efcaeaa1" title="Get the sample window for amplitude averaging.">ch_get_sample_window()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Internal sample window averaging is available when using special sensor firmware packages from Chirp. In General Purpose Rangefinding (GPR) firmware, a software only implementation is used. </dd></dl>

</div>
</div>
<a id="a21906ecff45b2f188d8cf6b4b7b2e596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21906ecff45b2f188d8cf6b4b7b2e596">&#9670;&nbsp;</a></span>ch_set_target_int_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_target_int_counter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>meas_hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>thresh_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target interrupt counter filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">meas_hist</td><td>number of previous measurements to include in target count </td></tr>
    <tr><td class="paramname">thresh_count</td><td>number of target detections req'd to generate interrupt </td></tr>
    <tr><td class="paramname">reset</td><td>if non-zero, counter filter resets when int is generated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the counter filter used to control target interrupts. The counter filter is by enabled using the <em><a class="el" href="soniclib_8h.html#ab462c77e75fd5b959eb3d49e918d49e8" title="Configure target interrupt filtering mode.">ch_set_target_interrupt()</a></em> function and specifying <em>CH_TGT_INT_FILTER_COUNTER</em> as the filter type.</p>
<p>When the counter filter is used, a certain threshold number of positive target detections must be observed within a specified number of measurements in order for an interrupt to be generated by the sensor.</p>
<p><em>meas_hist</em> specifies the number of previous measurements that will be included in the history buffer for filtering. The current measurement is combined with these previous measurements, so a total of <em>meas_hist</em> + 1 measurements are used.</p>
<p><em>thresh_count</em> is the number of those measurements that must positively detect a target for an interrupt to be generated.</p>
<p>At the end of each measurement, the total number of measurements with target detection within all the history and the new measurement is compared against the threshold value. If it meets the threshold, the sensor will interrupt. For example, if <em>meas_hist</em> is 5 and <em>thresh_count</em> is 3, an interrupt will be generated if 3 of the most recent 6 measurements (the 5 in the history plus the new result) detected a target.</p>
<p>If <em>reset</em> is non-zero, the counter filter counts are reset when an interrupt is generated. The sensor will not interrupt again until <em>thresh_count</em> new measurements detect a target, using the same threshold conditions as before. If <em>reset</em> is zero, the sensor will maintain its history and will continue to interrupt after each measurement if the threshold number of detections within recent results is met. Counter filter resetting is disabled by default.</p>
<p>The maximum value for both <em>meas_hist</em> and <em>thresh_count</em> is 15.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#abf08ef3543bda6135f4f5663283241cf" title="Get the target interrupt counter filter settings.">ch_get_target_int_counter()</a></em>, <em><a class="el" href="soniclib_8h.html#ab462c77e75fd5b959eb3d49e918d49e8" title="Configure target interrupt filtering mode.">ch_set_target_interrupt()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Target counter filtering is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="ab462c77e75fd5b959eb3d49e918d49e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab462c77e75fd5b959eb3d49e918d49e8">&#9670;&nbsp;</a></span>ch_set_target_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_target_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#ac2d701c38ecfaa08151839826667df20">ch_tgt_int_filter_t</a>&#160;</td>
          <td class="paramname"><em>tgt_int_filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target interrupt filtering mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">tgt_int_filter</td><td>target interrupt filter mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function configures the filtering of data ready interrupts from the sensor based on target detection.</p>
<p>In normal operation (if target detection interrupt filtering is not enabled), the sensor will assert the INT line at the end of each measurement even if no target is detected. This is the default behavior if this function is not used, or if <em>tgt_int_filter</em> is CH_TGT_INT_FILTER_OFF.</p>
<p>When basic target interrupt filtering is enabled, the sensor will assert the INT line at the end of each measurement only if a target object was detected. If no target is detected, the sensor will not interrupt, and there is no indication from the sensor that the measurement has completed.</p>
<p>To use basic target interrupt filtering, set <em>tgt_int_filter</em> to <em>CH_TGT_INT_FILTER_ANY</em>.</p>
<p>Target counter mode provides another level of filtering, across multiple measurements. When counter filtering is enabled, the sensor will only interrupt after multiple measurements have detected a target within a certain total number of consecutive recent measurements. A configurable history of previous measurements is recorded, and the results are compared against a threshold number of target detections. The sensor will generate an interrupt only when the count of target detections within the set of recent measurements meets the threshold value,</p>
<p>To use counter mode filtering, set <em>tgt_int_filter</em> to <em>CH_TGT_INT_FILTER_COUNTER</em>. The measurement history and target detection threshold count used in the filter can be set by using the <em><a class="el" href="soniclib_8h.html#a21906ecff45b2f188d8cf6b4b7b2e596" title="Configure the target interrupt counter filter.">ch_set_target_int_counter()</a></em> function.</p>
<p>If not otherwise specified, the default measurement history length is 5 measurements. The current measurement is combined with the measurements from the history, so a total of 6 measurements are used. The default interrupt threshold is 3 target detections. So by default, 3 of the 6 most recent measurements must detect a target to generate an interrupt.</p>
<p>By default, the counter filter maintains its history and counter values after an interrupt is generated, so the next measurement may again interrupt based on the threshold comparison as usual. The counter filter may instead be configured to reset after generating an interrupt by using <em><a class="el" href="soniclib_8h.html#a21906ecff45b2f188d8cf6b4b7b2e596" title="Configure the target interrupt counter filter.">ch_set_target_int_counter()</a></em>. In this case, the full <em>thresh_count</em> threshold must be met based on new detections, so that minimum number of measurements must occur before another interrupt will be generated.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a21906ecff45b2f188d8cf6b4b7b2e596" title="Configure the target interrupt counter filter.">ch_set_target_int_counter()</a></em>, <em><a class="el" href="soniclib_8h.html#abdc2253cbd8774013965ab82eadba27c" title="Get the target interrupt filtering mode setting.">ch_get_target_interrupt()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Target interrupt filtering is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="a035896185096ae0cc1e4c54db205d38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035896185096ae0cc1e4c54db205d38c">&#9670;&nbsp;</a></span>ch_set_trigger_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_set_trigger_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#aa18105c6986688c2700df504020bc2f2">ch_trigger_type_t</a>&#160;</td>
          <td class="paramname"><em>trig_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the trigger type for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">trig_type</td><td>trigger type to be used, CH_TRIGGER_TYPE_HW or CH_TRIGGER_TYPE_SW</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the trigger type to be used to initiate a measurement on a sensor that is in triggered mode. (Sensors in free-running mode are self-triggered based on an internal timer.)</p>
<p>By default (if this routine is not called), sensors are triggered using a hardware signal on the INT line. For ICU sensors, either there are two INT lines, INT1 and INT2. The line to be used for triggering is selected by the CHIRP_SENSOR_TRIG_PIN definition in the <a class="el" href="chirp__board__config_8h_source.html">chirp_board_config.h</a> file.</p>
<p>Alternatively, a measurement may be initiated via software, using a SPI command sent to the sensor. This may be used in place of a standard hardware trigger using a GPIO line, although there will be more latency and less exact timing control. To enable software triggering, set <em>trig_type</em> to CH_TRIGGER_TYPE_SW.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#ade5083e622e8cc3852a4193f6d8dce9c" title="Trigger a measurement on one sensor.">ch_trigger()</a></em>, <em><a class="el" href="soniclib_8h.html#a2b585794c893ffa579775e060df36915" title="Trigger a measurement using software (SPI) interface.">ch_trigger_soft()</a></em>, <em><a class="el" href="soniclib_8h.html#a74355ffe5e8887d74e9cdf5b3bd48a6f" title="Get the trigger type for a sensor.">ch_get_trigger_type()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Software triggering is not available for CH101 and CH201 sensors, so hardware triggering is always used. Calling this routine will have no effect. </dd></dl>

</div>
</div>
<a id="af6ef44ae8846913a1caf11212bdef116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ef44ae8846913a1caf11212bdef116">&#9670;&nbsp;</a></span>ch_set_tx_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_tx_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the ultrasound transmit pulse length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">num_cycles</td><td>transmit pulse length (number of cycles per transmission)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the length (duration) of the ultrasonic pulse sent by the sensor when it transmits. <em>num_cycles</em> specifies the length of the pulse.</p>
<p>For ICU (Shasta architecture) sensors, <em>num_cycles</em> are in units of Measurement State Machine Clock (SMCLK) cycles.</p>
<p>For CH101 and CH201 (Whitney architecture) sensors, <em>num_cycles</em> are ultrasonic transducer (PMUT) cycles, so are 1/16 the corresponding ICU sensor value.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a29a46285cbf72cb4d1c163f6575edf2f" title="Get the ultrasound transmit pulse length.">ch_get_tx_length()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="a505a6478f9e04cc440e3e3a05a565da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505a6478f9e04cc440e3e3a05a565da9">&#9670;&nbsp;</a></span>ch_ticks_to_usec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_ticks_to_usec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert sensor RTC clock ticks to microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">rtc_ticks</td><td>number of sensor RTC clock periods</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of microseconds.</dd></dl>
<p>This function takes a number of internal sensor RTC clock periods and converts it to the corresponding time in microseconds.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a6b94b407af323faa524787e399347594" title="Convert microseconds to sensor RTC clock ticks.">ch_usec_to_ticks()</a></em>, <em><a class="el" href="soniclib_8h.html#a5e0552ddb44341f86d96a9c5b4d9a1ca" title="Configure the sensor real-time clock (RTC).">ch_set_rtc()</a></em>. </p>

</div>
</div>
<a id="ade5083e622e8cc3852a4193f6d8dce9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5083e622e8cc3852a4193f6d8dce9c">&#9670;&nbsp;</a></span>ch_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger a measurement on one sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function generates a pulse on the INT line for a single sensor. If the sensor is in either <em>CH_MODE_TRIGGERED_TX_RX</em> or <em>CH_MODE_TRIGGERED_RX_ONLY</em> mode, this pulse will begin a measurement cycle.</p>
<p>To simultaneously trigger all sensors in a group, use <em><a class="el" href="soniclib_8h.html#aa4e917eea19df611680dc97e2401db3a" title="Trigger a measurement on a group of sensors.">ch_group_trigger()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Do not trigger a new measurement until the previous measurement has completed and all needed data has been read from the device (including I/Q data, if <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor.">ch_get_iq_data()</a></em> is used). If any I/O operations are still active, the new measurement may be corrupted. </dd></dl>

</div>
</div>
<a id="a2b585794c893ffa579775e060df36915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b585794c893ffa579775e060df36915">&#9670;&nbsp;</a></span>ch_trigger_soft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_trigger_soft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger a measurement using software (SPI) interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sends a special command to the sensor over the SPI bus to trigger a measurement. The software interface is always used regardless of the trigger type that has been set using <em><a class="el" href="soniclib_8h.html#a035896185096ae0cc1e4c54db205d38c" title="Set the trigger type for a sensor.">ch_set_trigger_type()</a></em>.</p>
<p>This may be used in place of a standard hardware trigger using a GPIO line, although there will be more latency and less exact timing control.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#ade5083e622e8cc3852a4193f6d8dce9c" title="Trigger a measurement on one sensor.">ch_trigger()</a></em>. </p>

</div>
</div>
<a id="ace58b8e6d9e75d368ddcb69c99db2f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace58b8e6d9e75d368ddcb69c99db2f3f">&#9670;&nbsp;</a></span>ch_update_metadata_from_iq0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_update_metadata_from_iq0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a> *&#160;</td>
          <td class="paramname"><em>iq_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the metadata from the first IQ sample and update the device pointer. </p>
<p>The ICU-X0201 can be configured to place metadata in the first IQ sample, which is otherwise always read out as 0. If enabled, this will place the IQ buffer address as well as the last measurement index in the first IQ sample. See <em><a class="el" href="soniclib_8h.html#a0bc64b2a0305210e1394331a6b2dd734" title="Enable or disable placing metadata in the first IQ sample.">ch_enable_metadata_in_iq0()</a></em>.</p>
<p>This function is used to extract metadata from the read IQ data. The metadata will be updated into <em>dev_ptr</em>. That is, after calling this function, the device pointer will be updated with the correct buffer address and last measurement index.</p>
<p>After running this function and getting a 0 exit status, the last measurement index can be retrieved using <a class="el" href="soniclib_8h.html#a2ea79708279e4f56734234dd07ae23f4" title="Get number of last completed measurement.">ch_meas_get_last_num()</a> and the next buffer address with <a class="el" href="soniclib_8h.html#a2fd0582578cba1dff9d781a4ce516e84" title="Get the address of the IQ buffer that will be written by the next measurement.">ch_get_next_buf_addr()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>The device pointer </td></tr>
    <tr><td class="paramname">iq_data</td><td>Pointer to the read IQ data. The metadata is extracted from the first sample, then the first sample is set back to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success and non-zero otherwise. If this function returns non-zero, then the device pointer is not updated. This most likely means that data was read from the incorrect buffer in double buffer mode. The situation should resolve itself on the next read since the same buffer will be read again, and the ASIC will swap write buffers on each measurement. </dd></dl>

</div>
</div>
<a id="a5d8b3ddcc0010bf7bd1f7acc1fba4232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8b3ddcc0010bf7bd1f7acc1fba4232">&#9670;&nbsp;</a></span>ch_usec_to_cycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_usec_to_cycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert microseconds to sensor cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">num_usec</td><td>number of microseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sensor cycles.</dd></dl>
<p>This function takes a period of time specified in microseconds and converts it to the corresponding number of internal sensor cycles.</p>
<p>For ICU (Shasta architecture) sensors, <em>cycles</em> are in units of PMUT State Machine Clock (SMCLK) cycles. The PMUT clock rate is 16 times the ultrasonic transducer acoustic operating frequency. These are the same cycle units used to specify measurement transmit and count segment lengths.</p>
<p>For CH101 and CH201 (Whitney architecture) sensors, <em>cycles</em> are ultrasonic transducer cycles, so are 1/16 the corresponding ICU sensor value.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#acde0dc4f438051bd4fcfd19aad8b3f9c" title="Convert sensor cycles to microseconds.">ch_cycles_to_usec()</a></em>. </p>

</div>
</div>
<a id="a6b94b407af323faa524787e399347594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b94b407af323faa524787e399347594">&#9670;&nbsp;</a></span>ch_usec_to_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_usec_to_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert microseconds to sensor RTC clock ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">num_usec</td><td>number of microseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sensor RTC clock ticks.</dd></dl>
<p>This function takes a time specified in microseconds and converts it to the corresponding number of sensor RTC clock periods.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#a505a6478f9e04cc440e3e3a05a565da9" title="Convert sensor RTC clock ticks to microseconds.">ch_ticks_to_usec()</a></em>, <a class="el" href="soniclib_8h.html#a5e0552ddb44341f86d96a9c5b4d9a1ca" title="Configure the sensor real-time clock (RTC).">ch_set_rtc()</a>. </p>

</div>
</div>
<a id="aabaaeecabbda3d134a582405cc2ec812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabaaeecabbda3d134a582405cc2ec812">&#9670;&nbsp;</a></span>ch_watchdog_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_watchdog_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable watchdog timer in sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function disables the watchdog timer function in the sensor.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is only available on ICU sensors. For CH101 and CH201 sensors, the watchdog timer is enabled or disabled by using a different sensor firmware image.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#a6703bf9649051f66c8c8acff42db746d" title="Enable watchdog timer in sensor.">ch_watchdog_enable()</a></em>. </p>

</div>
</div>
<a id="a6703bf9649051f66c8c8acff42db746d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6703bf9649051f66c8c8acff42db746d">&#9670;&nbsp;</a></span>ch_watchdog_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_watchdog_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable watchdog timer in sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device descriptor structure.">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function enables the watchdog timer function in the sensor. When the watchdog timer is enabled, the sensor must complete a measurement within approximately one second or the timer will expire. The timer is reset every time a measurement completes.</p>
<p>If the watchdog timer expires, the sensor will generate an interrupt and will specify CH_INTERRUPT_TYPE_WATCHDOG as the interrupt type. This interrupt type is passed as a parameter to the application's sensor interrupt callback routine that was registered using <em><a class="el" href="soniclib_8h.html#af3d4045f3510d82596c8231123e890b9" title="Register sensor interrupt callback routine for a group of sensors.">ch_io_int_callback_set()</a></em>. That callback routine should examine the interrupt type and take appropriate action if a watchdog timeout occurred.</p>
<dl class="section note"><dt>Note</dt><dd>This feature is only available on ICU sensors. For CH101 and CH201 sensors, the watchdog timer is enabled by using a different sensor firmware image (these firmware types have "_wd" in their names). Not all CH101 and CH201 firmware types have equivalent watchdog-enabled versions.</dd></dl>
<p>See also <em><a class="el" href="soniclib_8h.html#aabaaeecabbda3d134a582405cc2ec812" title="Disable watchdog timer in sensor.">ch_watchdog_disable()</a></em>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
